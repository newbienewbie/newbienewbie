<html>
  <head>

        <script type="text/javascript">
          var wsUri = "ws://localhost:8080/websocket";
      function init()
      {
        websocket = new WebSocket(wsUri);
        websocket.onclose = function(evt) { onClose(evt) };
      }
      function onClose(evt)
      {
        console.log('closing');
        websocket.close();
        document.location.reload();
      }
      window.addEventListener("load", init, false);
      </script>
            <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="/style/style.css"/>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="/">
            <img src="/images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item is-active" href="/">
            Home
          </a>
          <a class="navbar-item" href="/about.html">
            About
          </a>
          <a class="navbar-item" href="/contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="/posts/WindWhisper/WASM/基本原理/WASM基本原理4——Table.html">
                    WebAssembly基本原理4——Table
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-01-20
                </p>
              </div>
              <div class="content article-body">
                <p>总的来说，<code>Table</code>是一个<code>JavaScript</code>包装对象，具有<code>array-like</code>结构，目前只能用来存储的函数引用。不管是<code>JavaScript</code>还是<code>WASM</code>，都可以访问、修改<code>Table</code>。</p>
<p>为什么需要<code>Table</code>? <code>call</code>指令可以直接调用函数名来调用函数，然而这种方式是静态的，编译时就需要确定函数名。如果我们有一个运行时才能确定的函数，又如何才能调用？设想有一段<code>C</code>函数<code>dispatch()</code>，可以接收一个函数指针作为参数，然后调用之。</p>
<pre><code class="language-c">typedef void(*fp)();

void dispatch(fp x) {
  x();
}
</code></pre>
<p>注意这里<code>fp</code>类型的函数指针所指向的内容是运行期才能确定的，怎么构造与之等价的<code>WASM</code>？</p>
<p>直观的解决办法当然是给出一个函数地址，然后让<code>WASM</code>根据函数地址找到相关函数，这样就不用写死函数名了。问题是在线性内存中存储函数，再直接给出一个函数地址让<code>WASM</code>调用的做法是十分不安全的，因为线性内存暴露了所存储的原始内容。在计算机编程中，没有什么纸老虎问题是不能用封装解决的；如果有，那就再加一层。所以解决办法是引入一个包装对象——<code>table</code>。从<code>JavaScript</code>的角度看，<code>table</code>是个<code>array-like</code>，在<code>table</code>中可以存储一系列的函数引用，可以按索引来访问相关位置上的元素(函数引用)。最后，通过向<code>call_indirect</code>指令传递一个表格索引值（也就是<code>i32</code>型索引值，代表函数指针在表格中的位置），而非一个具体的函数指针，就可以实现运行时的动态函数调用。</p>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="/posts/WindWhisper/WASM/基本原理/WASM基本原理3——Memory.html">
                    WebAssembly基本原理3——Memory
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-01-19
                </p>
              </div>
              <div class="content article-body">
                <p><code>WebAssembly.Memory</code>是一段字节数组（a large array of bytes），用于在<code>WebAssembly</code>和<code>JavaScript</code>之间共享内存。<code>WebAssembly</code>包含诸如<code>i32.load</code>和<code>i32.store</code>指令来实现对线性内存的读写；从<code>JavaScript</code>的角度来看，<code>Memory</code>就是一个可以包含一切内容的、可变尺寸的<code>ArrayBuffer</code>。</p>
<h2>创建<code>Memory</code>对象</h2>
<p>如何创建一个<code>WebAssembly.Memory</code>实例？有两种方法，一是使用<code>JavaScript</code>创建一个<code>WebAssembly.Memory</code>对象并导入到<code>WebAssembly</code>模块实例中；二是，当我们不手动提供一个<code>Memory</code>实例时，<code>WebAssembly</code>模块会自动创建一个<code>Memory</code>对象，并把它和相应模块实例挂接起来，我们可以将之导出给<code>JavaScript</code>。</p>
<h3>如何使用 <code>JavaScript</code> 创建<code>WebAssembly.Memory</code>对象</h3>
<p><code>JavaScript</code>能够通过<code>WebAssembly.Memory()</code>接口创建<code>WebAssembly.Memory</code>内存实例</p>
<pre><code class="language-javascript">var memory = new WebAssembly.Memory({initial:10, maximum:100})
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="/posts/WindWhisper/WASM/基本原理/WASM基本原理2——文本格式.html">
                    WebAssembly基本原理2——文本格式
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-01-18
                </p>
              </div>
              <div class="content article-body">
                <p><code>WASM</code>的文本格式通常用<code>S-expression</code>来表示。其中，每个节点位于一对括号之中，其中的第一个标签指示节点类型，其后是属性列表或者子节点列表。例如：</p>
<pre><code class="language-wasm">(module (memory 1) (func)) 
</code></pre>
<p>该表达式的意思是：有一个模块，它有两个子节点，分别为<code>memory</code>和<code>func</code>，其中<code>memory</code>节点有属性为1。</p>
<h2>数据类型</h2>
<p><code>WASM</code>当前支持的数据类型还很少，只有四个可用类型：</p>
<ul>
<li><code>i32</code>：32位整数</li>
<li><code>i64</code>：64位整数</li>
<li><code>f32</code>：32位浮点数</li>
<li><code>f64</code>：64位浮点数</li>
</ul>
<h2>函数</h2>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="/posts/WindWhisper/WASM/基本原理/WASM基本原理1——世界观.html">
                    WebAssembly基本原理1——世界观
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-01-17
                </p>
              </div>
              <div class="content article-body">
                <h2>世界观</h2>
<p><code>WebAssembly</code>是<code>W3C</code>组织制定的一项开放标准，正如其名字暗示的那样，它是<code>Web</code>平台上的“汇编语言”，具有速度快、效率高、可移植、安全、向后兼容等特点。</p>
<p>模块是一段可执行的机器码，经过加载、编译、实例化后，即可与<code>JavaScript</code>充分互动。基本的样板代码为：</p>
<pre><code class="language-JavaScript">fetch('simple.wasm')
    // 获取字节码
    .then(response =&gt;response.arrayBuffer())
    // 编译和实例化
    .then(bytes =&gt;WebAssembly.instantiate(bytes, importObject))
    .then(results =&gt; {
        results.instance // 使用实例
    });
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="/posts/WindWhisper/IoT/PLC/基本原理/PLC基本原理——世界观.html">
                    PLC基本原理——世界观
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-01-16
                </p>
              </div>
              <div class="content article-body">
                <p>可编程控制器(<code>Programmable Logic Controller</code>,<code>PLC</code>) 是一种专门为工业环境下应用而设计的数字运算操作的电子装置，<code>PLC</code>是在电器控制技术和计算机技术的基础上发展起来的。在<code>PLC</code>之前，大规模应用的是继电器，但是继电器体积大、接线复杂、可复用性差、速度慢、不易更改、适应性差，为了克服这些缺点，在1969年美国数字公司研制出了世界第一台PLC，开创了工业控制领域的新纪元。相比于继电器控制，<code>PLC</code>具有以下优点：</p>
<ul>
<li>高可靠性</li>
<li>I/O接口模块多</li>
<li>模块化结构</li>
<li>编程简单</li>
<li>安装简单、维修方便</li>
</ul>
<h2>基本结构</h2>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <div class="container">
      <div class="container has-text-centered">
        <a href="/posts/page10.html">
          Previous
        </a>
        12 of 32
        <a href="/posts/page12.html">
          Next
        </a>
      </div>
    </div>
  </body>
</html>