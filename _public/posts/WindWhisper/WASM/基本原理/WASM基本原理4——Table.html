<html>
  <head>

        <script type="text/javascript">
          var wsUri = "ws://localhost:8080/websocket";
      function init()
      {
        websocket = new WebSocket(wsUri);
        websocket.onclose = function(evt) { onClose(evt) };
      }
      function onClose(evt)
      {
        console.log('closing');
        websocket.close();
        document.location.reload();
      }
      window.addEventListener("load", init, false);
      </script>
            <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="/style/style.css"/>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="/">
            <img src="/images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item" href="/">
            Home
          </a>
          <a class="navbar-item" href="/about.html">
            About
          </a>
          <a class="navbar-item" href="/contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="/posts/WindWhisper/WASM/基本原理/WASM基本原理4——Table.html">
                    WebAssembly基本原理4——Table
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-01-20
                </p>
              </div>
              <div class="content article-body">
                <p>总的来说，<code>Table</code>是一个<code>JavaScript</code>包装对象，具有<code>array-like</code>结构，目前只能用来存储的函数引用。不管是<code>JavaScript</code>还是<code>WASM</code>，都可以访问、修改<code>Table</code>。</p>
<p>为什么需要<code>Table</code>? <code>call</code>指令可以直接调用函数名来调用函数，然而这种方式是静态的，编译时就需要确定函数名。如果我们有一个运行时才能确定的函数，又如何才能调用？设想有一段<code>C</code>函数<code>dispatch()</code>，可以接收一个函数指针作为参数，然后调用之。</p>
<pre><code class="language-c">typedef void(*fp)();

void dispatch(fp x) {
  x();
}
</code></pre>
<p>注意这里<code>fp</code>类型的函数指针所指向的内容是运行期才能确定的，怎么构造与之等价的<code>WASM</code>？</p>
<p>直观的解决办法当然是给出一个函数地址，然后让<code>WASM</code>根据函数地址找到相关函数，这样就不用写死函数名了。问题是在线性内存中存储函数，再直接给出一个函数地址让<code>WASM</code>调用的做法是十分不安全的，因为线性内存暴露了所存储的原始内容。在计算机编程中，没有什么纸老虎问题是不能用封装解决的；如果有，那就再加一层。所以解决办法是引入一个包装对象——<code>table</code>。从<code>JavaScript</code>的角度看，<code>table</code>是个<code>array-like</code>，在<code>table</code>中可以存储一系列的函数引用，可以按索引来访问相关位置上的元素(函数引用)。最后，通过向<code>call_indirect</code>指令传递一个表格索引值（也就是<code>i32</code>型索引值，代表函数指针在表格中的位置），而非一个具体的函数指针，就可以实现运行时的动态函数调用。</p>
<p>于是与上面这段<code>C</code>代码等价的<code>WASM</code>可以写成: <!--more--></p>
<pre><code class="language-wasm">(module
    (table 0 anyfunc)                             ;; 定义一个table 

    (type $fp (func))                             ;; 定义$fp 函数的签名 void (*fp)();

    (func $dispatch  (param $0 i32)               ;; 定义$dispatch 函数
        (call_indirect $fp (get_local $0))        ;; 间接调用$fp函数，该引用位于table第0个位置
    )

    (export &quot;dispatch&quot; (func $dispatch))          ;; 导出$dispatch函数为&quot;dispatch&quot;
)
</code></pre>
<h2>实例化</h2>
<p><code>Table</code>既可以用<code>WASM</code>创建，也可以用<code>JavaScript</code>创建。</p>
<h2>在<code>JavaScript</code>中创建</h2>
<p><code>JavaScript</code>创建<code>WebAssembly.Table</code>的接口为：</p>
<pre><code class="language-javascript">var tbl = new WebAssembly.Table(tableDescriptor);
</code></pre>
<p>其中，<code>tableDescriptor</code>拥有如下属性:</p>
<ul>
<li><code>element</code>：字符串，代表<code>Table</code>中元素的值的类型，目前只能为<code>anyfunc</code> (函数)。这里之所以叫<code>anyfunc</code>类型，是因为该类型可以容纳任何签名的函数。</li>
<li><code>initial</code> 指定<code>Table</code>中初始元素数量。</li>
<li><code>maximum</code> 可选的，指定<code>Table</code>可增长到的最大元素数</li>
</ul>
<p>所创建的<code>Table</code>实例有如下关键的属性和方法：</p>
<ul>
<li><code>Table.prototype.length</code>：表的长度</li>
<li><code>Table.prototype.grow()</code>：令表的长度增加指定大小</li>
<li><code>Table.prototype.get()</code>: 根据索引值，返回相应位置的元素</li>
<li><code>Table.prototype.set()</code>: 设置指定索引值位置的元素</li>
</ul>
<p>除了可以使用<code>JavaScript</code>创建<code>WebAssembly.Table</code>，还可以使用<code>JavaScript</code>填充<code>Table</code>中的元素：</p>
<pre><code class="language-javascript">function() {
    var tbl = new WebAssembly.Table({initial:2, element:&quot;anyfunc&quot;});

    var f1 = function() { … }
    var f2 = function() { … }

    tbl.set(0, f1);
    tbl.set(1, f2);
};
</code></pre>
<h3>在<code>WASM</code>中创建</h3>
<p>我们还可以直接用<code>WASM</code>创建<code>Table</code>，并把相关函数指针作为元素填充到其中：</p>
<pre><code class="language-wasm">(module
    (table 2 anyfunc)                         ;; 创建一个Table

    (func $f1 (result i32)
        i32.const 42
    )
    (func $f2 (result i32)
        i32.const 13
    )

    (elem (i32.const 0) $f1 $f2)             ;; 填充Table元素，偏移量为0

    ;; ... 
)
</code></pre>
<p>这里<code>(table 2 anyfunc)</code>中的<code>anyfunc</code>，和<code>JavaScript</code>中的含义相同。</p>
<h3>在<code>WASM</code>中调用</h3>
<p>要想在<code>WASM</code>中间接调用相关函数，先要声明其函数签名，然后采用<code>call_indirect</code>指令间接调用即可</p>
<pre><code class="language-wasm">(type $some_func (func (result i32)))                     ;; 定义函数签名

(func (export &quot;callByIndex&quot;) (param $i i32) (result i32)
    (call_indirect $some_func (get_local $i) )            ;; 间接调用函数引用
)
</code></pre>
<p>看起来似乎有点古怪，是不是?其实很好理解：</p>
<ul>
<li>这个<code>(type $some_func (func (result i32)))</code>，作用其实是类似于<code>C</code>的<code>typedef</code>，或者类似于<code>Rust</code>的<code>type</code>，都是在声明一个函数的原型。</li>
<li>这个<code>(call_indirect $some_func (get_local $i) )</code>，效果则十分类似于<code>JavaScript</code>里的<code>table[$i]()</code>，即是找到<code>Table</code>中偏移量为<code>$i</code>的元素，然后调用该元素所指向的函数。</li>
</ul>
<h3>在<code>JavaScript</code>中调用</h3>
<p>在<code>JavaScript</code>中，将<code>Table</code>实例导入<code>WebAssembly</code>后，即可通过<code>#get()</code>方法直接使用：</p>
<pre><code class="language-javascript">var tbl = new WebAssembly.Table({initial:2, element:&quot;anyfunc&quot;});

var importObj = {
    js: { tbl:tbl }
};

fetchAndInstantiate('tbl_example.wasm', importObject)
    .then(function(instance) {
        console.log(tbl.length);    // &quot;2&quot;
        console.log(tbl.get(0)());  // 获取第0个函数，然后调用之 &quot;42&quot;
        console.log(tbl.get(1)());  // 获取第1个函数，然后调用之 &quot;83&quot;
    });
</code></pre>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
  </body>
</html>