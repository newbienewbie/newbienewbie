<html>
  <head>

        <script type="text/javascript">
          var wsUri = "ws://localhost:8080/websocket";
      function init()
      {
        websocket = new WebSocket(wsUri);
        websocket.onclose = function(evt) { onClose(evt) };
      }
      function onClose(evt)
      {
        console.log('closing');
        websocket.close();
        document.location.reload();
      }
      window.addEventListener("load", init, false);
      </script>
            <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="/style/style.css"/>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="/">
            <img src="/images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item" href="/">
            Home
          </a>
          <a class="navbar-item" href="/about.html">
            About
          </a>
          <a class="navbar-item" href="/contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="/posts/WindWhisper/CSharp/ASP.NET Core/Security/Authentication/Authentication — (5) 如何自定义认证处理器.html">
                    Authentication — (5) 如何自定义认证处理器
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2019-08-15
                </p>
              </div>
              <div class="content article-body">
                <p>设想有这样一个场景，我们开发了一个<code>SaaS</code>服务，正如微软在暴露<code>Azure</code>的某些服务那样，我们要求开发者提供相应的订阅（<code>SubScriptionKey</code>）才能访问我们的资源。我们约定，开发者需要在<code>HTTP</code>请求中添加如下形式的报头：</p>
<pre><code>Authorization: subscription-key {KEY}
</code></pre>
<p>此外，服务提供商还会定期公布一些供新用户试用的订阅，使用这些试用订阅也能通过认证。</p>
<p>为了巩固前几篇源码分析笔记的相关知识，我们通过自定义一个新的认证处理器来解决这个问题。</p>
<h2>自定义认证处理器</h2>
<p>首先，我们新建一个类来表示与此认证相关的配置项：</p>
<pre><code class="language-csharp">public class SubsKeyAuthNSchemeOptions : AuthenticationSchemeOptions
{
    public string SubscriptionKeyPrefix { get; set; } = &quot;subscription-key&quot;;
    public string TrialKey { get; set; } = &quot;42 is the answer&quot;;
}
</code></pre>
<p>认证处理器需要首先从报头中提取<code>Token</code>（也即订阅的<code>Key</code>）；然后判断当前Key是否为试用的订阅，然后从数据库中检索该Key是否有效；如果有效，则生成认证成功凭证、认证票据，最后返回认证成功结果。</p>
<p>下面给出认证处理器的完整实现：<!-- more --></p>
<pre><code class="language-csharp">public class SubsKeyAuthNHandler : AuthenticationHandler&lt;SubsKeyAuthNSchemeOptions&gt;
{
    public SubsKeyAuthNHandler(IOptionsMonitor&lt;SubsKeyAuthNSchemeOptions&gt; options, ILoggerFactory logger, UrlEncoder encoder, ISystemClock clock)
        : base(options, logger, encoder, clock)
    {
    }
    // 一段虚构的用于校验Key的代码
    private Task&lt;bool&gt; ValidateSubscriptionKeyAsync(string key)
    {
        Func&lt;string,bool&gt; validateKeyAgainstDb = (skey)=&gt; {
            // ... check this subscription key
            return false;
        };
        var result = key == this.Options.TrialKey || validateKeyAgainstDb(key) ;
        return Task.FromResult(result);
    }

    protected override async Task&lt;AuthenticateResult&gt; HandleAuthenticateAsync()
    {
        // 获取Key
        string key = null;
        string authorization = Request.Headers[&quot;Authorization&quot;];
        if (string.IsNullOrEmpty(authorization)) {
            return AuthenticateResult.NoResult();
        }
        if (authorization.StartsWith(this.Options.SubscriptionKeyPrefix, StringComparison.OrdinalIgnoreCase)) {
            key = authorization.Substring(this.Options.SubscriptionKeyPrefix.Length).Trim();
        }
        if (string.IsNullOrEmpty(key)) { return AuthenticateResult.NoResult(); }

        // 校验Key
        var res =await this.ValidateSubscriptionKeyAsync(key);
        if (!res) {
            return AuthenticateResult.Fail($&quot;token {this.Options.SubscriptionKeyPrefix} not match&quot;);
        } else {
            var id=new ClaimsIdentity( 
                new Claim[] { new Claim(&quot;Key&quot;, key) },  // not safe , just as an example , should custom claims on your own
                Scheme.Name 
            );
            ClaimsPrincipal principal=new ClaimsPrincipal( id);
            var ticket = new AuthenticationTicket(principal, new AuthenticationProperties(), Scheme.Name);
            return AuthenticateResult.Success(ticket);
        }
    }

    protected override Task HandleChallengeAsync(AuthenticationProperties properties)
    {
        Response.StatusCode = 401;
        var message = &quot;tell me your token&quot;;
        Response.Body.Write(Encoding.UTF8.GetBytes(message));
        return Task.CompletedTask;
    }

    protected override Task HandleForbiddenAsync(AuthenticationProperties properties)
    {
        Response.StatusCode = 403;
        var message = &quot;you have no rights&quot;;
        Response.Body.Write(Encoding.UTF8.GetBytes(message));
        return Task.CompletedTask;
    }
}
</code></pre>
<p>为了后续可以方便地表述这种认证模式，我们不妨定义两个常量字符串：</p>
<pre><code class="language-csharp">public class SubsKeyAuthNDefaults {
    public const string Scheme = &quot;SubscriptionKeyAuthenticationScheme&quot;;
    public const string DisplayName= &quot;Subscription Key Authentication Scheme&quot;;
}
</code></pre>
<h2>配置认证</h2>
<p>在<code>Startup.cs</code>的配置认证服务，为了让我们的程序稍显复杂一点，我故意把默认的认证模式改成了<code>JwtBearer</code>；另外我还重写了默认的<code>TrialKey</code>:</p>
<pre><code class="language-csharp">services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =&gt; {
        options.TokenValidationParameters = new TokenValidationParameters{ /* ... */ };
        options.ForwardAuthenticate = SubsKeyAuthNDefaults.Scheme;
    })
    .AddScheme&lt;SubsKeyAuthNSchemeOptions, SubsKeyAuthNHandler&gt;(
        SubsKeyAuthNDefaults.Scheme, 
        SubsKeyAuthNDefaults.DisplayName, 
        opts =&gt; {
            opts.TrialKey = &quot;42 is not the answer&quot;;
        }
    );
</code></pre>
<h2>测试</h2>
<p>最后，新建一个<code>API</code>用于测试我们的代码，其中<code>Get</code>方法要求<code>JwtBearer</code>认证，而<code>Post</code>方法需要进行<code>SubsKeyAuthNDefaults.Scheme</code>认证。</p>
<pre><code class="language-csharp">[Route(&quot;api/[controller]&quot;)]
[ApiController]
public class ValuesController : ControllerBase
{

    [Authorize(AuthenticationSchemes =JwtBearerDefaults.AuthenticationScheme)]
    [HttpGet(&quot;{id}&quot;)]
    public ActionResult&lt;string&gt; Get(int id)
    {
        return &quot;value&quot;;
    }

    [Authorize(AuthenticationSchemes = SubsKeyAuthNDefaults.Scheme)]
    [HttpPost]
    public string Post([FromBody] string value)
    {
        return value;
    }
}
</code></pre>
<h4>测试 JwtBearer 转发认证</h4>
<p>我们分别提交错误的Key、默认的Key和自定义的Key进行测试：</p>
<pre><code>### 返回 401
GET https://localhost:5001/api/values/5 HTTP/1.1
Authorization: subscription-key Houston, we have had a problem


### 返回 401
GET https://localhost:5001/api/values/5 HTTP/1.1
Authorization: subscription-key 42 is the answer

### 返回 200
GET https://localhost:5001/api/values/5 HTTP/1.1
Authorization: subscription-key 42 is not the answer
</code></pre>
<h4>测试 SubsKey 认证</h4>
<ol>
<li>测试 POST方法 + SubsKey 认证（提交错误的Key）</li>
</ol>
<pre><code>POST https://localhost:5001/api/values HTTP/1.1
Authorization: subscription-key Houston, we have had a problem
Content-Type: application/json

&quot;Hello, World&quot;
</code></pre>
<p>以上的请求会返回 <code>401</code> + &quot;tell me your token&quot; ：</p>
<pre><code>HTTP/1.1 401 Unauthorized
Connection: close
Server: Kestrel
Transfer-Encoding: chunked

tell me your token
</code></pre>
<ol start="2">
<li>测试 POST方法 + SubsKey 认证 （提交正确的Key）</li>
</ol>
<pre><code>POST https://localhost:5001/api/values HTTP/1.1
Authorization: subscription-key 42 is not the answer
Content-Type: application/json

&quot;It works&quot;
</code></pre>
<p>以上的请求会返回 <code>200</code>  + &quot;It works&quot;:</p>
<pre><code>HTTP/1.1 200 OK
Connection: close
Date: Thu, 15 Aug 2019 03:06:33 GMT
Content-Type: text/plain; charset=utf-8
Server: Kestrel
Transfer-Encoding: chunked

It works
</code></pre>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
  </body>
</html>