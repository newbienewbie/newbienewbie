<html>
  <head>

        <script type="text/javascript">
          var wsUri = "ws://localhost:8080/websocket";
      function init()
      {
        websocket = new WebSocket(wsUri);
        websocket.onclose = function(evt) { onClose(evt) };
      }
      function onClose(evt)
      {
        console.log('closing');
        websocket.close();
        document.location.reload();
      }
      window.addEventListener("load", init, false);
      </script>
            <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="/style/style.css"/>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="/">
            <img src="/images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item" href="/">
            Home
          </a>
          <a class="navbar-item" href="/about.html">
            About
          </a>
          <a class="navbar-item" href="/contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="/posts/WindWhisper/CSharp/ASP.NET Core/Security/Authorization/Authorization — (3) ASP.NET Core 的授权中间件和MVC授权过滤器.html">
                    Authorization — (3) ASP.NET Core 的授权中间件和MVC授权过滤器
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2019-08-20
                </p>
              </div>
              <div class="content article-body">
                <h2>授权中间件</h2>
<p>和<code>ASP.NET Core 2.1</code>中的路由中间件不同，在<code>3.0</code>中新的<code>EndPoint</code>路由机制无需实际执行路由便可获取当前所匹配的<code>EndPoint</code>。正是得益于这套新引入的<code>EndPoint</code>路由系统，<code>ASP.NET Core</code>框架可在执行<code>MVC</code>路由之前，就可以捕捉到相应<code>EndPoint</code>的授权配置信息(<code>IAuthorizeData</code>)。基于此，<code>ASP.NET Core</code> <code>3.0</code>中为授权机制做了重大调整，即引入了<strong>授权中间件</strong>。这意味着在<code>3.0</code>中我们需要在<code>UseAuthentication()</code>之后尽快调用<code>UseAuthorization()</code>方法：</p>
<pre><code class="language-csharp">    app.UseRouting();
    // ...
    app.UseAuthentication();
    app.UseAuthorization();           // 启用授权中间件
    // ...
    app.UseEndpoints(endpoints =&gt;
    {
        endpoints.MapHub&lt;ChatHub&gt;(&quot;/chat&quot;);
        endpoints.MapControllerRoute(&quot;default&quot;, &quot;{controller=Home}/{action=Index}/{id?}&quot;);
    })
</code></pre>
<p>新引入的授权中间件的核心工作主要分成两部分：</p>
<ul>
<li>借助于<code>IAuthorizationPolicyProvider</code>服务和当前<code>EndPoint</code>的<code>IAuthorizeData</code>，构建一个<code>Policy</code>对象。如果没有相应的<code>Policy</code>，则直接调用后续中间件（跳过剩余的授权过程）。</li>
<li>通过<code>IPolicyEvaluator</code>服务判断当前<code>HttpContext</code>是否满足<code>Policy</code>。如果不满足，根据授权结果决定是<code>Challenge</code>还是<code>Forbid</code>；否则，则继续调用后续中间件对请求进行处理。<!-- more --></li>
</ul>
<pre><code class="language-csharp">public class AuthorizationMiddleware
{
    // Property key is used by other systems, e.g. MVC, to check if authorization middleware has run
    private const string AuthorizationMiddlewareInvokedKey = &quot;__AuthorizationMiddlewareInvoked&quot;;
    private static readonly object AuthorizationMiddlewareInvokedValue = new object();

    private readonly RequestDelegate _next;
    private readonly IAuthorizationPolicyProvider _policyProvider;

    public AuthorizationMiddleware(RequestDelegate next, IAuthorizationPolicyProvider policyProvider)
    {
        _next = next ?? throw new ArgumentNullException(nameof(next));
        _policyProvider = policyProvider ?? throw new ArgumentNullException(nameof(policyProvider));
    }

    public async Task Invoke(HttpContext context)
    {
        if (context == null){ /*  throw */}

        var endpoint = context.GetEndpoint();

        // Flag to indicate to other systems, e.g. MVC, that authorization middleware was run for this request
        context.Items[AuthorizationMiddlewareInvokedKey] = AuthorizationMiddlewareInvokedValue;

        // IMPORTANT: Changes to authorization logic should be mirrored in MVC's AuthorizeFilter
        var authorizeData = endpoint?.Metadata.GetOrderedMetadata&lt;IAuthorizeData&gt;() ?? Array.Empty&lt;IAuthorizeData&gt;();
        var policy = await AuthorizationPolicy.CombineAsync(_policyProvider, authorizeData);
        if (policy == null)
        {
            await _next(context);
            return;
        }

        // Policy evaluator has transient lifetime so it fetched from request services instead of injecting in constructor
        var policyEvaluator = context.RequestServices.GetRequiredService&lt;IPolicyEvaluator&gt;();

        var authenticateResult = await policyEvaluator.AuthenticateAsync(policy, context);

        // Allow Anonymous skips all authorization
        if (endpoint?.Metadata.GetMetadata&lt;IAllowAnonymous&gt;() != null)
        {
            await _next(context);
            return;
        }

        // Note that the resource will be null if there is no matched endpoint
        var authorizeResult = await policyEvaluator.AuthorizeAsync(policy, authenticateResult, context, resource: endpoint);

        if (authorizeResult.Challenged)
        {
            if (policy.AuthenticationSchemes.Any())
            {
                foreach (var scheme in policy.AuthenticationSchemes)
                {
                    await context.ChallengeAsync(scheme);
                }
            } else {
                await context.ChallengeAsync();
            }

            return;
        } else if (authorizeResult.Forbidden) {
            if (policy.AuthenticationSchemes.Any())
            {
                foreach (var scheme in policy.AuthenticationSchemes)
                {
                    await context.ForbidAsync(scheme);
                }
            } else {
                await context.ForbidAsync();
            }

            return;
        }

        await _next(context);
    }
}
</code></pre>
<h2>MVC授权过滤器</h2>
<p><code>MVC</code>内置了一个授权过滤器<code>AuthorizeFilter</code>，其基本实现非常类似于授权中间件：</p>
<pre><code class="language-csharp">namespace Microsoft.AspNetCore.Mvc.Authorization
{
    public class AuthorizeFilter : IAsyncAuthorizationFilter, IFilterFactory
    {
        // ...  构造函数与属性

        /// &lt;inheritdoc /&gt;
        public virtual async Task OnAuthorizationAsync(AuthorizationFilterContext context)
        {
            if (context == null){ /* throw */ }
            var effectivePolicy = await GetEffectivePolicyAsync(context);
            if (effectivePolicy == null) { return; }

            var policyEvaluator = context.HttpContext.RequestServices.GetRequiredService&lt;IPolicyEvaluator&gt;();

            var authenticateResult = await policyEvaluator.AuthenticateAsync(effectivePolicy, context.HttpContext);

            // Allow Anonymous skips all authorization
            if (HasAllowAnonymous(context.Filters)) { return; }

            var authorizeResult = await policyEvaluator.AuthorizeAsync(effectivePolicy, authenticateResult, context.HttpContext, context);

            if (authorizeResult.Challenged)
            {
                context.Result = new ChallengeResult(effectivePolicy.AuthenticationSchemes.ToArray());
            }
            else if (authorizeResult.Forbidden)
            {
                context.Result = new ForbidResult(effectivePolicy.AuthenticationSchemes.ToArray());
            }
        }

    }
}
</code></pre>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
  </body>
</html>