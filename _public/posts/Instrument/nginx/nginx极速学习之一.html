<html>
  <head>

        <script type="text/javascript">
          var wsUri = "ws://localhost:8080/websocket";
      function init()
      {
        websocket = new WebSocket(wsUri);
        websocket.onclose = function(evt) { onClose(evt) };
      }
      function onClose(evt)
      {
        console.log('closing');
        websocket.close();
        document.location.reload();
      }
      window.addEventListener("load", init, false);
      </script>
            <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="/style/style.css"/>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="/">
            <img src="/images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item" href="/">
            Home
          </a>
          <a class="navbar-item" href="/about.html">
            About
          </a>
          <a class="navbar-item" href="/contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="/posts/Instrument/nginx/nginx极速学习之一.html">
                    nginx极速学习之一
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2016-11-14
                </p>
              </div>
              <div class="content article-body">
                <p><code>Nginx</code> 是非常优秀的开源 Web Server，基本功能包括：</p>
<ul>
<li>Web Server</li>
<li>Serving static content</li>
<li>Reverse Proxy</li>
<li>Compression and decompression</li>
<li>Web content cache</li>
</ul>
<p>充当 Web Server ，是 <code>Nginx</code> 最核心的功能。</p>
<h2>Nginx 是如何处理请求的？</h2>
<p>我们知道，HTTP 协议可以抽象为<code>Request-Response</code>模型，那么它是如何根据请求做出响应的呢？</p>
<p><code>Request-Response</code>模型实际是要完成请求到响应文件的映射。
一个正常的 HTTP Request 类似于：</p>
<pre><code>{Verb} {路径}
Host: {域名}或者{IP}:{端口号}
其他headers
\r\n
data
</code></pre>
<p>对于 <code>Nginx</code> ，首先关注的不同点就是 <code>Host</code> 、<code>路径</code>。</p>
<h3>Nginx 是如何匹配 server 的</h3>
<p>考虑一个常见情况：我们知道，一个物理机之上可以放置多个虚拟服务器，拥有同一个IP、共享80端口，但是拥有不同的域名。</p>
<p>合理的响应方式必然是要根据收到的<code>HTTP</code>请求中的<code>Host</code>来生成相应网站的响应。 <code>Nginx</code> 的处理方式也符合这样的直觉：</p>
<ol>
<li>测试<code>Request</code>的<code>IP</code>、<code>PORT</code>是否和<code>listen</code>指令配置的<code>IP</code>、<code>PORT</code>是否一致，找到匹配<code>IP:PORT</code>的相应服务器。</li>
<li>在上一步找到的Server基础上，测试<code>Request</code>的<code>HOST</code>是否和<code>server_name</code>指令配置的服务器名是否一致；</li>
<li>如果匹配<code>server_name</code>这一步未找到，则会交由默认的Server处理（如果未显示定义默认服务器，则默认是第一个）。</li>
</ol>
<p>一个常见的 <code>Nginx</code> 配置类似于：</p>
<pre><code>server {
    listen      192.168.1.1:80;
    server_name example.org www.example.org;
    ...
}

server {
    listen      192.168.1.1:80;
    server_name example.net www.example.net;
    ...
}

server {
    listen      192.168.1.2:80;
    server_name example.com www.example.com;
    ...
}
</code></pre>
<p>那么，一个请求满足条件：</p>
<pre><code>IP 192.168.1.1 
PORT 80
域名 www.example.net
</code></pre>
<p>则会匹配到配置好的第二个 server 。</p>
<h3>Nginx 是如何匹配 location 的</h3>
<p><code>Nginx</code> 对<code>location</code>的匹配顺序规则为：</p>
<ol>
<li>first searches for the most specific prefix location given by literal strings regardless of the listed order</li>
<li>Then nginx checks locations given by regular expression in the order listed in the configuration file ,The first matching expression stops the search and nginx will use this location</li>
<li>If no regular expression matches a request, then nginx uses the most specific prefix location found earlier.</li>
</ol>
<p><code>Nginx</code> 配置：</p>
<pre><code>server {
    listen      80;
    server_name example.org www.example.org;
    root        /data/www;

    location / {
        index   index.html index.php;
    }

    location ~* \.(gif|jpg|png)$ {
        expires 30d;
    }

    location ~ \.php$ {
        fastcgi_pass  localhost:9000;
        fastcgi_param SCRIPT_FILENAME
                      $document_root$fastcgi_script_name;
        include       fastcgi_params;
    }
}
</code></pre>
<p>这段配置中，列出了若干 <code>location</code>配置，所以，一个<code>/index.php</code>请求的匹配过程应该是:</p>
<ol>
<li>首先会命中最为具体的prefix location <code>/</code></li>
<li>然后又会找到第一个匹配到的正则表达式location <code>\.php$</code>，匹配结束</li>
</ol>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
  </body>
</html>