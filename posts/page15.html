<!DOCTYPE html><html>
  <head>

        <script type="text/javascript">
          var wsUri = "ws://localhost:8080/websocket";
      function init()
      {
        websocket = new WebSocket(wsUri);
        websocket.onclose = function(evt) { onClose(evt) };
      }
      function onClose(evt)
      {
        console.log('closing');
        websocket.close();
        document.location.reload();
      }
      window.addEventListener("load", init, false);
      </script>
            <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="/style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="/">
            <img src="/images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item is-active" href="/">
            Home
          </a>
          <a class="navbar-item" href="/about.html">
            About
          </a>
          <a class="navbar-item" href="/contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="/posts/Boulevard/Database/数据库理论/数据库并发调度与封锁协议.html">
                    数据库笔记 数据库并发调度与封锁协议
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-09-29
                </p>
              </div>
              <div class="content article-body">
                <h2>并发调度</h2>
<h3>事务</h3>
<p>事务是在数据库上一个或者多个操作的序列，必须以原子的形式执行。当对数据库进行查询、或者更新的任何SQL语句开始时，事务就开始。</p>
<p>在SQL中事务的开始语句为<code> begin transaction</code>。</p>
<p>必须明确地结束一个事务。结束事务通常有两种方式：</p>
<ul>
<li>SQL语句 <code>COMMMIT</code> 提交事务，使得事务成功结束，事务对数据库的任何改变都将被存放到数据库中。</li>
<li>SQL语句 <code>ROLLBACK</code> 回滚事务，使得事务不成功终止，事务对数据库的任何改变都将撤销。</li>
</ul>
<p>事务管理必须具有四个特性：</p>
<ul>
<li><code>acid</code> 原子性：事务的操作要么都做，要么都不做。</li>
<li><code>consistency</code> 一致性：当数据库只包含成功事务提交的结果时，称数据库处于一致性状态。事务的执行结果必须保证数据库从一个一致性状态到另一个一致性状态。</li>
<li><code>isolation</code> 隔离性：事务相互隔离，当多个事务并发执行，任一事务的更新操作直到其成功提交的整个过程，对其他事务不可见。</li>
<li><code>durability</code> 持久性：一旦事务成功提交，即使数据库崩溃，其对数据库的更新操作也将永久有效。</li>
</ul>
<h3>数据不一致</h3>
<p>并发操作是指多用户可能对同一个数据进行操作。并发不正确调度会带来数据不一致问题，其主要原因是破坏了数据的 <em>隔离性</em> 。</p>
<!-- more -->
<p>数据不一致共有三种情况：</p>
<ul>
<li><code>丢失修改(lost update)</code>： 事务T1、T2读入同一数据各自修改，T1先完成修改并将更新的数据写回数据库；随后T2也完成修改并将结果写回数据库，从而覆盖T1的修改，导致T1对数据的修改好像从未发生。</li>
<li><code>读脏数据(dirty read)</code>： 事务T1修改了某数据并将其写回数据库，事务T2 随之读入T1修改过的值，之后T1被撤销修改，则T2读取的值与数据库中的值不同。</li>
<li><code>不可重复读(non-repeatable read)</code>： 事务T1按一定条件读入若干数据，随后事务T2对其更新并写回数据库，当T1再次按照同一条件读入数据，发现跟刚才不一致。</li>
</ul>
<h3>可串行化调度</h3>
<p>要保证并发操作得到正确的结果，可以去要求所有事务都是串行执行的——一个事务执行过程时完全不受其他事务影响，只有一个事务结束之后，另一个事务才开始运行。</p>
<p>但是在实际的执行方式上要求事务串行依次执行是不科学的，并发执行是基本需求。那么，怎么样的并发调度才能认为是对的？对于多个事务，其并发执行的结果只要和其中任意一种串行执行的结果相同，即认为是正确的调度，称之为可串行化的调度。</p>
<p>为了保证对并发操作的调度满足可串行化条件，数据库管理系统必须提供一定的手段，通常采用的是 <em>封锁机制</em></p>
<h2>封锁管理</h2>
<p><em>封锁</em> ： 事务在对数据对象操作前，先申请对其加锁，成功加锁之后，事务就对该数据对象有了控制权，只有该事务对其解锁之后，其他事务才能使用它。</p>
<h3>封锁分类</h3>
<p>封锁包括两类：</p>
<ul>
<li><code>排他锁(exclusive lock，X lock)</code>：事务T对对象A加了X锁，则T可以读取和更新A；在T释放对A的X锁之前，其他事务不能再对A加任何类型的锁（从而不能读也不能写A）。</li>
<li><code>共享锁(share lock ，S lock)</code> : 事务T 对对象A加了S锁之后，T可以读取，但是不能更新A，在T释放对A的S锁之前，其他事务可以再对A进行加锁，但是不能加X锁。</li>
</ul>
<h3>封锁协议（<code>locking protocal</code>）</h3>
<h4>三级封锁协议</h4>
<p><em><code>一级封锁协议</code></em>  ：要求事务T在修改数据A之前必须先对其加X锁，直到事务结束才释放该锁。该级协议解决了<code>丢失修改</code>问题。但是它不要求事务在读数据之前进行加锁，故不能解决<code>读脏数据</code>、<code>不可重复读取</code>问题。</p>
<p><em><code>二级封锁协议</code></em> ：在<code>一级封锁协议</code>的基础上，要求事务T在读取数据A之前必须先对其加S锁，读入数据后立刻是否S锁。这样，不仅解决了<code>丢失修改</code>问题，还防止了<code>读脏数据</code>问题。但是该级协议不能解决<code>不可重复读取</code>问题，例如：</p>
<ol>
<li>现有事务T1，尝试读取A，加共享锁 lock-s(A)；读完之后立刻释放共享锁，unlock-s(A)。此时事务T1尚未继续。</li>
<li>事务T2尝试修改A，加排他锁 lock-x(A)；T2事务执行完毕，释放排他锁，unlock-x(A)。</li>
<li>事务T1再次尝试读取A，加共享锁 lock-s(A)，按照同一条件读取A之后，释放共享锁 unlock-s(A)。</li>
</ol>
<p>此时，即出现了不可重复读问题。</p>
<p><em><code>三级封锁协议</code></em> ：在<code>二级封锁协议</code>的基础上，要求事务T在读取A之前，必须先对其加S锁，但是直到事务结束，才释放S锁。<code>三级封锁协议</code>解决了<code>丢失修改</code>、<code>读脏数据</code>、<code>不可重复读</code>问题。</p>
<p>注意，和<code>二级封锁协议</code>规定的共享锁在读完数据后立即释放不同，<code>一级封锁协议</code>、<code>三级封锁协议</code>都要求锁一旦加上，直到事务结束之前，都不能释放。</p>
<h3>两段锁协议（<code>two-phase locking</code>）</h3>
<p><em>两段锁协议</em> ： 事务T对数据A进行读写操作以前，必须先活得对A的封锁；并且，在释放一个封锁之后，T不能再获得其他任何封锁。也即事务分成 <em>加锁</em>  和 <em>解锁</em> 两个阶段。</p>
<p>事务遵循两段封锁协议是保证操作可串行化的充分条件（但不是必要条件）。</p>
<p>eg: 以下序列遵行两段封锁协议：</p>
<pre><code>lock-x(A)
lock-s(B)
lock-s(C)
unlock(A)
unlock(C)
unlock(B)
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="/posts/Boulevard/Database/数据库理论/函数依赖.html">
                    数据库笔记 函数依赖
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-09-20
                </p>
              </div>
              <div class="content article-body">
                <h2>函数依赖的定义</h2>
<p><em>函数依赖</em> 与 <em>函数决定</em>  ：如果关系<code>R</code>的两个元组在属性<code>$A_1,A2_2,A_3,...,A_n$</code>上一致，则它们在另一个属性<code>B</code>上也一致，则称“关系<code>R</code>中属性<code>B</code>函数依赖于属性<code>$A_1 A_2 A_3 ... A_n$</code>”，记作：</p>
<pre><code class="language-math">%% KaTex
A_1 A_2 A_3 ... A_n \rightarrow B
</code></pre>
<p>或者称“<code>$A_1,A_2,A_3,...,A_n$</code>函数决定B”，其中，<code>$A_1 A_2 A_3 ... A_n$</code>称为 <em>决定因素</em> 。</p>
<p>如果有一组属性函数决定：</p>
<pre><code class="language-math">%% KaTex
A_1 A_2 A_3 ... A_n \rightarrow B_1 

A_1 A_2 A_3 ... A_n \rightarrow B_2

A_1 A_2 A_3 ... A_n \rightarrow B_3

A_1 A_2 A_3 ... A_n \rightarrow B_m
</code></pre>
<p>则可以简记作：</p>
<pre><code class="language-math">%% KaTex
A_1 A_2 A_3 ... A_n \rightarrow B_1 B_2 B_3 ... B_m
</code></pre>
<!-- more -->
<h2>关系的键码</h2>
<p>一个或者多个属性的集合 <code>$\{ A_1,A_2,...,A_n \}$</code>如果满足以下条件，则称该集合为关系<code>R</code>的键码(<code>key</code>):</p>
<ol>
<li>这些属性 <em>函数决定</em> 关系<code>R</code>的所有其他属性。</li>
<li>集合的<code>$\{ A_1,A_2,...,A_n \}$</code>任何真子集都不能函数决定关系<code>R</code>的所有其他属性。(键码最小)</li>
</ol>
<p>如果只满足条件1，而不满足条件2，则称之为 <em>超键码(superkey)</em></p>
<h2>函数依赖的原则</h2>
<h3>合并分解原则</h3>
<h4>分解原则(spiltting rule)</h4>
<p><code>$ A_1 A_2 A_3 ... A_n \rightarrow B_1 B_2 B_3 ... B_m $</code> 可以用一组函数依赖<code>$ A_1 A_2 A_3 ... A_n \rightarrow B_i (i=1,2,...,m) $</code>来代替。</p>
<h4>合并原则(combining rule)</h4>
<p>一组函数依赖<code>$ A_1 A_2 A_3 ... A_n \rightarrow B_i (i=1,2,...,m) $</code> 可以用一个依赖<code>$ A_1 A_2 A_3 ... A_n \rightarrow B_1 B_2 B_3 ... B_m $</code>来代替。</p>
<h4>平凡依赖原则(trivial dependency rule)</h4>
<ul>
<li>对函数依赖 <code>$ A_1 A_2 A_3 ... A_n \rightarrow B $</code>，如果B是A中的一个，称之为“平凡的”。</li>
<li>对函数依赖<code>$ A_1 A_2 A_3 ... A_n \rightarrow B_i (i=1,2,...,m) $</code> ，
<ul>
<li>如果B是A的子集，则称该依赖是“平凡的”</li>
<li>如果B中至少一个属性不在A中，则称为该依赖是“非平凡的”</li>
<li>如果B中所有属性都不在A中，则称为该依赖是“完全非平凡的”</li>
</ul>
</li>
</ul>
<p>一个平凡的函数依赖，是有冗余信息的。事实上平凡依赖原则的英文表述<code>trivial dependency rule</code>就有 <em>琐碎的、不重要的</em> 的意思。</p>
<h3>传递规则</h3>
<p>如果：</p>
<pre><code class="language-math">%% KaTex
A_1 A_2 A_3 ... A_n \rightarrow B_1 B_2 B_3 ... B_m

B_1 B_2 B_3 ... B_m \rightarrow  C_1 C_2 C_3 ... C_k
</code></pre>
<p>则有</p>
<pre><code class="language-math">%% KaTex
A_1 A_2 A_3 ... A_n \rightarrow  C_1 C_2 C_3 ... C_k
</code></pre>
<h2>属性的封闭集(closure)</h2>
<p>记属性集<code>$\{ A_1,A_2,...,A_n \}$</code>为A，S 为函数依赖集。属性集A 函数决定的属性的集合称之为 <em>属性集A在依赖集S下的封闭集</em> 。</p>
<p>属性集<code>$\{ A_1,A_2,...,A_n \}$</code>的封闭集记作
<code>$\{ A_1,A_2,...,A_n \}^+$</code>。</p>
<p>对于任一函数依赖<code>$A_1 A_2 ... A_n \rightarrow B$</code>，利用依赖集S计算出封闭集<code>$\{ A_1,A_2,...,A_n \}^+$</code>，如果B在此封闭集之中，则说明函数依赖<code>$A_1 A_2 ... A_n \rightarrow B$</code>蕴含于依赖集S中。</p>
<p>由于键码可以函数决定其他所有属性，故键码属性的封闭集必然是属性全集。反过来看，若某属性集的封闭集为属性全集，则该属性集为键码。</p>
<h2>冗余、异常及依赖的关系</h2>
<h3>完全依赖和部分依赖</h3>
<p>对于函数依赖<code>$W \rightarrow A$</code></p>
<ul>
<li>如果<code>$\exists V  \subset W$</code>，使得<code>$V \rightarrow A $</code>，则称A <code>部分依赖(partitial dependency)</code>于W</li>
<li>如果不存在这种V，则成A<code>完全依赖(full dependency)</code>于W</li>
</ul>
<h3>传递依赖与直接依赖</h3>
<p>对于函数依赖<code>$X \rightarrow Y $</code>，如果<code>$Y \nrightarrow X$</code>，而函数依赖<code>$Y \rightarrow Z$</code>成立，则称<code>Z对X传递依赖(transitive depedency)</code>，传递依赖也称为 <em>间接依赖</em></p>
<p>如果<code>$X \rightarrow Y$</code> ，且<code>$Y \rightarrow X$</code>，则X和Y相互依赖，称之为 <em>直接依赖</em> 。</p>
<p>直接依赖和传递依赖反映了属性对键码的函数依赖的性质和程度。</p>
<h3>冗余和异常的根源</h3>
<ul>
<li>关系模式中非主属性对键码的部分依赖和传递依赖是产生数据冗余和更新异常的主要根源</li>
<li>主属性对键码的部分依赖或传递依赖是产生数据冗余和更新异常的另一个重要根源</li>
<li>多值依赖</li>
</ul>
<h2>关系模式规范化</h2>
<p>把低级范式的关系模式转换为几个属于高级范式的关系模式的集合，称之为规范化（<code>normalization</code>）。</p>
<p>从函数依赖的角度来看，关系模式规范化的基本思路就是：从非主属性到主属性，逐步消除决定因素不是键码的非平凡函数依赖，从而使每个决定因素都包含键码（而不是键码的一部分）。</p>
<p>各级范式的关系图为：</p>
<pre><code>1NF
 |  消除非主属性对键码的部分依赖
 V
2NF
 |  消除非主属性对键码的传递依赖
 V
3NF
 |  消除主属性对键码的部分和传递依赖
 V
BCNF
 |  消除非平凡的传递依赖
 V
4NF
</code></pre>
<h3>1NF</h3>
<p>关系R的每个属性都不可分割</p>
<h3>2NF</h3>
<p>关系R符合第一范式，且每个非主属性都完全函数依赖于键码，即可称之为<code>2NF</code>。也就是说，非主属性，不得有对键码的部分依赖。</p>
<p>比如有关系<code>$R(SNo,SName,SDept,MName,CName,Grade)$</code>，记录学生学号、姓名、专业、课程名称、授课老师、成绩，键码为<code>$SNo,CName$</code>。存在函数依赖<code>$SNo,CName \rightarrow SName,SDept,MName$</code>。</p>
<p>显然这里是一个部分依赖，因为可以找函数依赖：<code>$SNo \rightarrow SName,SDept$</code> 。故关系R不符合<code>完全依赖</code>的要求。把R拆分成关系：</p>
<pre><code class="language-math">%% KaTex
S_1=(SNo,SName,SDept,MName)

S_2=(SNo,CName,Grade)
</code></pre>
<p>则分解后的<code>$S_1$</code>的依赖关系为：</p>
<pre><code class="language-math">%% KaTex
SNo \rightarrow SName, SDept,MName

SDept \rightarrow  MName
</code></pre>
<p>而分解后的<code>$S_2$</code>的依赖关系为：</p>
<pre><code class="language-math">%% KaTex
SNo,CName \rightarrow Grade
</code></pre>
<p>故分解后的两个关系均符合<code>2NF</code></p>
<h3>3NF</h3>
<p>关系R符合第一范式，且每个非主属性都都不传递依赖于键码，则称之为<code>3NF</code>。也是说，非主属性不得有对键码的间接依赖。</p>
<p>属于3NF的关系模式必然属于第二模式，因为部分依赖蕴含着传递依赖：</p>
<p>设关系R有非主属性A和主属性K，且<code>$K \rightarrow A$</code>是部分依赖，则A必然依赖于K的某个真子集<code>$K'$</code>，即<code>$\exists K' \subset K$</code>，使得<code>$K' \rightarrow A$</code>。
又因为<code>$\exists K' \subset K$</code>，故有平凡依赖<code>$K \rightarrow K'$</code>，且<code>$K' \nrightarrow K $</code> 。
综上，有：<code>$K \rightarrow K' \rightarrow A$</code>。</p>
<p>上面分解出的关系<code>$S_1=(SNo,SName,SDept,MName)$</code>存在传递性的函数依赖<code>$SNo \rightarrow SDept \rightarrow  MName$</code>，故不属于<code>3NF</code>，可以继续分解为<code>$S_{11}(SNo,SName,SDept)$</code> 和 <code>$S_{12}(SDept,MName)$</code>。</p>
<h2>模式分解</h2>
<h3>原则</h3>
<p>模式分解主要涉及两个原则</p>
<h4>无损连接</h4>
<p>对关系R进行分解时，R的元组分别在相应属性集进行投影产生新的关系。如果对新的关系进行自然连接得到的元组的集合与原关系完全一致，则称为“<code>无损链接(lossless join)</code>”。</p>
<p>无损连接反映了模式分解的等价性原则。</p>
<p>实现无损连接的充要条件是：<code>$(R_1 \cap R_2) \rightarrow (R_1 - R_2)$</code> 或者<code>$(R_1 \cap R_2) \rightarrow (R_2 - R_1)$</code> 。
其中，<code>$R_1 \cap R_2$</code>代表二者的公共属性，二者的差集代表非公共属性部分。这个充要条件实际是在表达：公共属性能函数决定非公共属性部分。</p>
<h4>保持依赖</h4>
<p>对关系R进行分解时，R的函数依赖集也将按相应的模式分解。如果分解后的总的函数依赖集与原函数依赖集保持一致，则称之为“<code>保持依赖(preserve dependency)</code>”。</p>
<p>保持连接反映了模式分解的依赖等价原则，保证了分解后模式与原有的模式在数据语义上一致。</p>
<h3>分解的方法</h3>
<h4>方法一、部分依赖归子集，完全依赖随键码</h4>
<p>升级为2NF：</p>
<p>从部分依赖中归纳出键码的一个真子集，然后真子集和所有的非主属性合成一个新的模式。</p>
<p>对键码完全依赖的所有非主属性和键码组合成一个新的模式。</p>
<h4>方法二、基本依赖为基础，中间属性做桥梁</h4>
<p>升级为3NF：</p>
<p>以传递依赖链的两个基本依赖为基础形成两个新的模式。</p>
<h4>方法三、找违例自成一体，舍左右全集归一；若发现仍有违例，再回首如法炮制。</h4>
<p>违背BC范式的函数称为BC范式的违例。</p>
<h2>多值依赖</h2>
<p>假设模式<code>$R(A,B,C)$</code>，其中A、B、C为属性(集)。如果在A上取特定值，而在B的取值的集合上与C上取值的集合无关，则称多值依赖<code>$A \rightarrow \rightarrow B$</code>在R中成立。也可称A 多值决定B，或者称B多值依赖A。</p>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="/posts/Boulevard/Compiler/自制编程语言/crowbar源码阅读笔记(5).html">
                    crowbar源码阅读笔记(5):表达式求值
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-08-20
                </p>
              </div>
              <div class="content article-body">
                <p>这是《自制编程语言》一书中的脚本语言<code>crowbar</code>的源码阅读笔记(5):表达式求值。表达式求值的实现代码主要存放于文件<code>eval.c</code>中。</p>
<h2>表达式求值算法的总体框架</h2>
<p>根据表达式的类型的不同，执行不同的求值算法，然后返回一个<code>CRB_Value</code>类型。</p>
<pre><code class="language-c">static CRB_Value eval_expression(CRB_Interpreter *inter, LocalEnvironment *env, Expression *expr)
{
    CRB_Value   v;
    switch (expr-&gt;type) {
    case BOOLEAN_EXPRESSION:
        v = eval_boolean_expression(expr-&gt;u.boolean_value);
        break;
    case INT_EXPRESSION:
        v = eval_int_expression(expr-&gt;u.int_value);
        break;
    case DOUBLE_EXPRESSION:
        v = eval_double_expression(expr-&gt;u.double_value);
        break;
    case STRING_EXPRESSION:
        v = eval_string_expression(inter, expr-&gt;u.string_value);
        break;
    case IDENTIFIER_EXPRESSION:
        v = eval_identifier_expression(inter, env, expr);
        break;
    case ASSIGN_EXPRESSION:
        v = eval_assign_expression(inter, env, expr-&gt;u.assign_expression.variable, expr-&gt;u.assign_expression.operand);
        break;
    case ADD_EXPRESSION:        /* FALLTHRU */
    case SUB_EXPRESSION:        /* FALLTHRU */
    case MUL_EXPRESSION:        /* FALLTHRU */
    case DIV_EXPRESSION:        /* FALLTHRU */
    case MOD_EXPRESSION:        /* FALLTHRU */
    case EQ_EXPRESSION: /* FALLTHRU */
    case NE_EXPRESSION: /* FALLTHRU */
    case GT_EXPRESSION: /* FALLTHRU */
    case GE_EXPRESSION: /* FALLTHRU */
    case LT_EXPRESSION: /* FALLTHRU */
    case LE_EXPRESSION:
        v = crb_eval_binary_expression(inter, env, expr-&gt;type, expr-&gt;u.binary_expression.left, expr-&gt;u.binary_expression.right);
        break;
    case LOGICAL_AND_EXPRESSION:/* FALLTHRU */
    case LOGICAL_OR_EXPRESSION:
        v = eval_logical_and_or_expression(inter, env, expr-&gt;type, expr-&gt;u.binary_expression.left, expr-&gt;u.binary_expression.right);
        break;
    case MINUS_EXPRESSION:
        v = crb_eval_minus_expression(inter, env, expr-&gt;u.minus_expression);
        break;
    case FUNCTION_CALL_EXPRESSION:
        v = eval_function_call_expression(inter, env, expr);
        break;
    case NULL_EXPRESSION:
        v = eval_null_expression();
        break;
    case EXPRESSION_TYPE_COUNT_PLUS_1:  /* FALLTHRU */
    default:
        DBG_panic((&quot;bad case. type..%d\n&quot;, expr-&gt;type));
    }
    return v;
}
</code></pre>
<p>以整型表达式为例，创建一个<code>CRB_Value</code>变量，然后设置其<code>type</code>，填充<code>u</code>成员的<code>int_value</code>字段为指定值：</p>
<!-- more -->
<pre><code class="language-c">static CRB_Value eval_int_expression(int int_value)
{
    CRB_Value   v;

    v.type = CRB_INT_VALUE;
    v.u.int_value = int_value;

    return v;
}
</code></pre>
<p>布尔型表达式求值也是类似的，创建一个<code>CRB_Value</code>变量，然后设置其<code>type</code>，填充<code>u</code>成员的<code>boolean_value</code>字段为指定<code>CRB_Boolean</code>值：</p>
<pre><code class="language-c">static CRB_Value eval_boolean_expression(CRB_Boolean boolean_value)
{
    CRB_Value   v;
    v.type = CRB_BOOLEAN_VALUE;
    v.u.boolean_value = boolean_value;
    return v;
}
</code></pre>
<p>类似的还有浮点型表达式求值、字符串型表达式求值。</p>
<h2>标识符表达式求值</h2>
<pre><code class="language-c">static CRB_Value eval_identifier_expression(CRB_Interpreter *inter, LocalEnvironment *env, Expression *expr)
{
    CRB_Value   v;
    Variable    *vp;

    vp = crb_search_local_variable(env, expr-&gt;u.identifier);
    if (vp != NULL) {
        v = vp-&gt;value;
    } else {
        vp = search_global_variable_from_env(inter, env, expr-&gt;u.identifier);
        if (vp != NULL) {
            v = vp-&gt;value;
        } else {
            crb_runtime_error(expr-&gt;line_number, VARIABLE_NOT_FOUND_ERR,
                              STRING_MESSAGE_ARGUMENT,
                              &quot;name&quot;, expr-&gt;u.identifier,
                              MESSAGE_ARGUMENT_END);
        }
    }
    refer_if_string(&amp;v);

    return v;
}
</code></pre>
<h2>赋值表达式求值</h2>
<p>赋值表达式求值非常简单：</p>
<ul>
<li>先求出等号右部的表达式的值</li>
<li>尝试搜寻指定标识符对应的变量，找不到就在指定环境中创建一个变量。</li>
<li>然后将等号左边的变量值修改为计算出来的值。</li>
</ul>
<pre><code class="language-c">static CRB_Value eval_assign_expression(CRB_Interpreter *inter, LocalEnvironment *env, char *identifier, Expression *expression)
{
    CRB_Value   v;
    Variable    *left;

    v = eval_expression(inter, env, expression);

    left = crb_search_local_variable(env, identifier);
    if (left == NULL) {
        left = search_global_variable_from_env(inter, env, identifier);
    }
    if (left != NULL) {
        release_if_string(&amp;left-&gt;value);
        left-&gt;value = v;
        refer_if_string(&amp;v);
    } else {
        if (env != NULL) {
            crb_add_local_variable(env, identifier, &amp;v);
        } else {
            CRB_add_global_variable(inter, identifier, &amp;v);
        }
        refer_if_string(&amp;v);
    }

    return v;
}
</code></pre>
<h2><code>BinaryExpression</code> 求值</h2>
<p>根据参与运算的<code>left</code>和<code>right</code>类型，又可以分为布尔型、整型、浮点型、字符串型等</p>
<h3>布尔型 <code>BinaryExpression</code></h3>
<p>它的求值方法非常简单，即根据左右表达式是否相等来返回结果：</p>
<pre><code class="language-c">static CRB_Boolean eval_binary_boolean(CRB_Interpreter *inter, ExpressionType operator, CRB_Boolean left, CRB_Boolean right, int line_number)
{
    CRB_Boolean result;

    if (operator == EQ_EXPRESSION) {
        result = left == right;
    } else if (operator == NE_EXPRESSION) {
        result = left != right;
    } else {
        char *op_str = crb_get_operator_string(operator);
        crb_runtime_error(line_number, NOT_BOOLEAN_OPERATOR_ERR, STRING_MESSAGE_ARGUMENT, &quot;operator&quot;, op_str, MESSAGE_ARGUMENT_END);
    }

    return result;
}
</code></pre>
<h3>逻辑<code>BinaryExpression</code>表达式求值</h3>
<p>逻辑表达式总体来说采用的是递归法求解：</p>
<ul>
<li>先递归求解出<code>left_value</code>，根据运算符的不同，判断是否触发短路，是则不再进一步求解</li>
<li>否则，再递归求解出<code>right_value</code></li>
<li>然后根据<code>left_value</code>和<code>right_value</code>求解出最终的值。</li>
</ul>
<pre><code class="language-c">static CRB_Value eval_logical_and_or_expression(CRB_Interpreter *inter, LocalEnvironment *env, ExpressionType operator, Expression *left, Expression *right)
{
    CRB_Value   left_val;
    CRB_Value   right_val;
    CRB_Value   result;
    result.type = CRB_BOOLEAN_VALUE;

    /* left_value 求解 */
    left_val = eval_expression(inter, env, left);

    if (left_val.type != CRB_BOOLEAN_VALUE) { crb_runtime_error(left-&gt;line_number, NOT_BOOLEAN_TYPE_ERR, MESSAGE_ARGUMENT_END); }

    /* 测试是否触发短路逻辑 */
    if (operator == LOGICAL_AND_EXPRESSION) {
        if (!left_val.u.boolean_value) { result.u.boolean_value = CRB_FALSE; return result; }
    } 
    else if (operator == LOGICAL_OR_EXPRESSION) {
        if (left_val.u.boolean_value) { result.u.boolean_value = CRB_TRUE; return result; }
    }
    else {
        DBG_panic((&quot;bad operator..%d\n&quot;, operator));
    }

    /* right_value 求解 */
    right_val = eval_expression(inter, env, right);
    if (right_val.type != CRB_BOOLEAN_VALUE) {
        crb_runtime_error(right-&gt;line_number, NOT_BOOLEAN_TYPE_ERR, MESSAGE_ARGUMENT_END); 
    }

    result.u.boolean_value = right_val.u.boolean_value;
    return result;
}
</code></pre>
<h3>整型 <code>BinaryExpression</code> 求值</h3>
<p>整型表达式的左右表达式均为整型。其求值结果可能是整型，也可能是布尔型。比如：</p>
<ul>
<li><code>3+4</code>这个表达式的结果为整型</li>
<li><code>3&gt;4</code>这个表达式的结果为布尔假值。</li>
</ul>
<p>求值的时候，需要针对每种情况区别对待：</p>
<ul>
<li>当运算符为 <strong>数学运算符</strong>，比如<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>，求值结果整型</li>
<li>当运算符为 <strong>比较运算符</strong>，比如<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>==</code>、<code>!=</code>，求值结果为布尔值。</li>
</ul>
<pre><code class="language-c">static void eval_binary_int(CRB_Interpreter *inter, ExpressionType operator, int left, int right, CRB_Value *result, int line_number) 
{
    if (dkc_is_math_operator(operator)) { result-&gt;type = CRB_INT_VALUE; } 
    else if (dkc_is_compare_operator(operator)) { result-&gt;type = CRB_BOOLEAN_VALUE; } 
    else { DBG_panic((&quot;operator..%d\n&quot;, operator)); }

    switch (operator) {
    case BOOLEAN_EXPRESSION:    /* FALLTHRU */
    case INT_EXPRESSION:        /* FALLTHRU */
    case DOUBLE_EXPRESSION:     /* FALLTHRU */
    case STRING_EXPRESSION:     /* FALLTHRU */
    case IDENTIFIER_EXPRESSION: /* FALLTHRU */
    case ASSIGN_EXPRESSION:
        DBG_panic((&quot;bad case...%d&quot;, operator));
        break;
    case ADD_EXPRESSION:
        result-&gt;u.int_value = left + right;
        break;
    case SUB_EXPRESSION:
        result-&gt;u.int_value = left - right;
        break;
    case MUL_EXPRESSION:
        result-&gt;u.int_value = left * right;
        break;
    case DIV_EXPRESSION:
        result-&gt;u.int_value = left / right;
        break;
    case MOD_EXPRESSION:
        result-&gt;u.int_value = left % right;
        break;
    case LOGICAL_AND_EXPRESSION:        /* FALLTHRU */
    case LOGICAL_OR_EXPRESSION:
        DBG_panic((&quot;bad case...%d&quot;, operator));
        break;
    case EQ_EXPRESSION:
        result-&gt;u.boolean_value = left == right;
        break;
    case NE_EXPRESSION:
        result-&gt;u.boolean_value = left != right;
        break;
    case GT_EXPRESSION:
        result-&gt;u.boolean_value = left &gt; right;
        break;
    case GE_EXPRESSION:
        result-&gt;u.boolean_value = left &gt;= right;
        break;
    case LT_EXPRESSION:
        result-&gt;u.boolean_value = left &lt; right;
        break;
    case LE_EXPRESSION:
        result-&gt;u.boolean_value = left &lt;= right;
        break;
    case MINUS_EXPRESSION:              /* FALLTHRU */
    case FUNCTION_CALL_EXPRESSION:      /* FALLTHRU */
    case NULL_EXPRESSION:               /* FALLTHRU */
    case EXPRESSION_TYPE_COUNT_PLUS_1:  /* FALLTHRU */
    default:
        DBG_panic((&quot;bad case...%d&quot;, operator));
    }
}
</code></pre>
<h3>浮点型 <code>BinaryExpression</code> 求值</h3>
<p>浮点型 <code>BinaryExpression</code> 与整型 <code>BinaryExpression</code> 求值过程类似，根据运算符的类型，要按浮点型和布尔型区别对待。</p>
<pre><code class="language-c">static void eval_binary_double(CRB_Interpreter *inter, ExpressionType operator, double left, double right, CRB_Value *result, int line_number) 
{
    if (dkc_is_math_operator(operator)) { result-&gt;type = CRB_DOUBLE_VALUE; } 
    else if (dkc_is_compare_operator(operator)) { result-&gt;type = CRB_BOOLEAN_VALUE; }
    else { DBG_panic((&quot;operator..%d\n&quot;, operator)); }

    switch (operator) {
    case BOOLEAN_EXPRESSION:    /* FALLTHRU */
    case INT_EXPRESSION:        /* FALLTHRU */
    case DOUBLE_EXPRESSION:     /* FALLTHRU */
    case STRING_EXPRESSION:     /* FALLTHRU */
    case IDENTIFIER_EXPRESSION: /* FALLTHRU */
    case ASSIGN_EXPRESSION:
        DBG_panic((&quot;bad case...%d&quot;, operator));
        break;
    case ADD_EXPRESSION:
        result-&gt;u.double_value = left + right;
        break;
    case SUB_EXPRESSION:
        result-&gt;u.double_value = left - right;
        break;
    case MUL_EXPRESSION:
        result-&gt;u.double_value = left * right;
        break;
    case DIV_EXPRESSION:
        result-&gt;u.double_value = left / right;
        break;
    case MOD_EXPRESSION:
        result-&gt;u.double_value = fmod(left, right);
        break;
    case LOGICAL_AND_EXPRESSION:        /* FALLTHRU */
    case LOGICAL_OR_EXPRESSION:
        DBG_panic((&quot;bad case...%d&quot;, operator));
        break;
    case EQ_EXPRESSION:
        result-&gt;u.int_value = left == right;
        break;
    case NE_EXPRESSION:
        result-&gt;u.int_value = left != right;
        break;
    case GT_EXPRESSION:
        result-&gt;u.int_value = left &gt; right;
        break;
    case GE_EXPRESSION:
        result-&gt;u.int_value = left &gt;= right;
        break;
    case LT_EXPRESSION:
        result-&gt;u.int_value = left &lt; right;
        break;
    case LE_EXPRESSION:
        result-&gt;u.int_value = left &lt;= right;
        break;
    case MINUS_EXPRESSION:              /* FALLTHRU */
    case FUNCTION_CALL_EXPRESSION:      /* FALLTHRU */
    case NULL_EXPRESSION:               /* FALLTHRU */
    case EXPRESSION_TYPE_COUNT_PLUS_1:  /* FALLTHRU */
    default:
        DBG_panic((&quot;bad default...%d&quot;, operator));
    }
}
</code></pre>
<h3>通用<code>BinaryExpression</code>的求值策略</h3>
<p>通用的<code>BinaryExpression</code>策略是采用递归法求解的：</p>
<ul>
<li>先递归求解<code>left</code>表达式的值<code>left_value</code></li>
<li>再递归求解<code>right</code>表达式的值<code>right_value</code></li>
<li>然后根据<code>left_value</code>和<code>right_value</code>的具体类型，分情况求解出最终的值。</li>
</ul>
<pre><code class="language-c">CRB_Value crb_eval_binary_expression(CRB_Interpreter *inter, LocalEnvironment *env, ExpressionType operator, Expression *left, Expression *right)
{
    CRB_Value   left_val;
    CRB_Value   right_val;
    CRB_Value   result;

    left_val = eval_expression(inter, env, left);
    right_val = eval_expression(inter, env, right);

    /* 整型 BinaryExpression 求解 */
    if (left_val.type == CRB_INT_VALUE &amp;&amp; right_val.type == CRB_INT_VALUE) {
        eval_binary_int(inter, operator, left_val.u.int_value, right_val.u.int_value, &amp;result, left-&gt;line_number);
    } 
    /* 浮点型 BinaryExpression */
    else if (left_val.type == CRB_DOUBLE_VALUE &amp;&amp; right_val.type == CRB_DOUBLE_VALUE) {
        eval_binary_double(inter, operator, left_val.u.double_value, right_val.u.double_value, &amp;result, left-&gt;line_number);
    }
    /* 浮点型 BinaryExpression */
    else if (left_val.type == CRB_INT_VALUE &amp;&amp; right_val.type == CRB_DOUBLE_VALUE) {
        left_val.u.double_value = left_val.u.int_value;
        eval_binary_double(inter, operator, left_val.u.double_value, right_val.u.double_value, &amp;result, left-&gt;line_number);
    }
    /* 浮点型 BinaryExpression */
    else if (left_val.type == CRB_DOUBLE_VALUE &amp;&amp; right_val.type == CRB_INT_VALUE) {
        right_val.u.double_value = right_val.u.int_value;
        eval_binary_double(inter, operator, left_val.u.double_value, right_val.u.double_value, &amp;result, left-&gt;line_number);
    }
    /* 布尔型 BinaryExpression */
    else if (left_val.type == CRB_BOOLEAN_VALUE &amp;&amp; right_val.type == CRB_BOOLEAN_VALUE) {
        result.type = CRB_BOOLEAN_VALUE;
        result.u.boolean_value = eval_binary_boolean(inter, operator, left_val.u.boolean_value, right_val.u.boolean_value, left-&gt;line_number);
    } 
    /* 字符串拼接 */
    else if (left_val.type == CRB_STRING_VALUE &amp;&amp; operator == ADD_EXPRESSION) {
        char    buf[LINE_BUF_SIZE];
        CRB_String *right_str;

        if (right_val.type == CRB_INT_VALUE) {
            sprintf(buf, &quot;%d&quot;, right_val.u.int_value);
            right_str = crb_create_crowbar_string(inter, MEM_strdup(buf));
        } else if (right_val.type == CRB_DOUBLE_VALUE) {
            sprintf(buf, &quot;%f&quot;, right_val.u.double_value);
            right_str = crb_create_crowbar_string(inter, MEM_strdup(buf));
        } else if (right_val.type == CRB_BOOLEAN_VALUE) {
            if (right_val.u.boolean_value) {
                right_str = crb_create_crowbar_string(inter, MEM_strdup(&quot;true&quot;));
            } else {
                right_str = crb_create_crowbar_string(inter, MEM_strdup(&quot;false&quot;));
            }
        } else if (right_val.type == CRB_STRING_VALUE) {
            right_str = right_val.u.string_value;
        } else if (right_val.type == CRB_NATIVE_POINTER_VALUE) {
            sprintf(buf, &quot;(%s:%p)&quot;, right_val.u.native_pointer.info-&gt;name, right_val.u.native_pointer.pointer);
            right_str = crb_create_crowbar_string(inter, MEM_strdup(buf));
        } else if (right_val.type == CRB_NULL_VALUE) {
            right_str = crb_create_crowbar_string(inter, MEM_strdup(&quot;null&quot;));
        } 
        result.type = CRB_STRING_VALUE;
        result.u.string_value = chain_string(inter, left_val.u.string_value, right_str);
    }
    /* 字符串比较大小 */
    else if (left_val.type == CRB_STRING_VALUE &amp;&amp; right_val.type == CRB_STRING_VALUE) {
        result.type = CRB_BOOLEAN_VALUE;
        result.u.boolean_value = eval_compare_string(operator, &amp;left_val, &amp;right_val, left-&gt;line_number);
    }
    /* 空值 */
    else if (left_val.type == CRB_NULL_VALUE || right_val.type == CRB_NULL_VALUE) {
        result.type = CRB_BOOLEAN_VALUE;
        result.u.boolean_value = eval_binary_null(inter, operator, &amp;left_val, &amp;right_val, left-&gt;line_number);
    } 
    /* 报错 */
    else {
        char *op_str = crb_get_operator_string(operator);
        crb_runtime_error(left-&gt;line_number, BAD_OPERAND_TYPE_ERR, STRING_MESSAGE_ARGUMENT, &quot;operator&quot;, op_str, MESSAGE_ARGUMENT_END);
    }

    return result;
}
</code></pre>
<h2>函数调用表达式求值</h2>
<p>函数调用表达式根据函数类型分为两种， <strong>原生函数调用</strong> 和 <strong>crowbar函数调用</strong> ，根据函数类型的不同，再选择性地调用<code>call_native_function()</code>或<code>call_crowbar_function()</code>:</p>
<pre><code class="language-c">static CRB_Value eval_function_call_expression(CRB_Interpreter *inter, LocalEnvironment *env, Expression *expr)
{
    CRB_Value           value;
    FunctionDefinition  *func;
    
    char *identifier = expr-&gt;u.function_call_expression.identifier;

    func = crb_search_function(identifier);
    if (func == NULL) {
        crb_runtime_error(expr-&gt;line_number, FUNCTION_NOT_FOUND_ERR, STRING_MESSAGE_ARGUMENT, &quot;name&quot;, identifier, MESSAGE_ARGUMENT_END);
    }
    switch (func-&gt;type) {
        case CROWBAR_FUNCTION_DEFINITION:
            value = call_crowbar_function(inter, env, expr, func);
            break;
        case NATIVE_FUNCTION_DEFINITION:
            value = call_native_function(inter, env, expr, func-&gt;u.native_f.proc);
            break;
        default:
            DBG_panic((&quot;bad case..%d\n&quot;, func-&gt;type));
    }

    return value;
}
</code></pre>
<p>原生函数调用的求值过程非常简单，因为原生函数实际上<code>C</code>语言编写的封装类型，通过指针，就可以直接调用：</p>
<pre><code class="language-c">static CRB_Value call_native_function(CRB_Interpreter *inter, LocalEnvironment *env, Expression *expr, CRB_NativeFunctionProc *proc)
{
    CRB_Value   value;
    int         arg_count;
    ArgumentList        *arg_p;
    CRB_Value   *args;
    int         i;

    /* 原生函数的参数个数 */
    for (arg_count = 0, arg_p = expr-&gt;u.function_call_expression.argument;
         arg_p; arg_p = arg_p-&gt;next) {
        arg_count++;
    }

    /* 原生函数的参数数组 */
    args = MEM_malloc(sizeof(CRB_Value) * arg_count);
    for (arg_p = expr-&gt;u.function_call_expression.argument, i = 0; arg_p; arg_p = arg_p-&gt;next, i++)
    {
        args[i] = eval_expression(inter, env, arg_p-&gt;expression);
    }

    /* 通过函数指针调用原生函数 */
    value = proc(inter, arg_count, args);

    /* 释放参数数组的内存 */
    for (i = 0; i &lt; arg_count; i++) {
        release_if_string(&amp;args[i]);
    }
    MEM_free(args);

    return value;
}
</code></pre>
<p>而利用<code>crowbar</code>脚本语言编写的脚本，则相对复杂一点；</p>
<ul>
<li>要为函数创建一个局部环境，然后把相关参数注册到该环境中，</li>
<li>然后再执行函数体中的语句列表</li>
<li>最后释放局部环境并返回最终结果</li>
</ul>
<pre><code class="language-c">static CRB_Value call_crowbar_function(CRB_Interpreter *inter, LocalEnvironment *env, Expression *expr, FunctionDefinition *func)
{
    CRB_Value   value;
    StatementResult     result;
    ArgumentList        *arg_p;
    ParameterList       *param_p;
    LocalEnvironment    *local_env;

    /* 创建一个局部环境，把相关参数添加到该局部环境中 */
    local_env = alloc_local_environment();
    for(arg_p = expr-&gt;u.function_call_expression.argument, param_p = func-&gt;u.crowbar_f.parameter; 
        arg_p;
        arg_p = arg_p-&gt;next, param_p = param_p-&gt;next) 
    {
        CRB_Value arg_val;

        if (param_p == NULL) {
            crb_runtime_error(expr-&gt;line_number, ARGUMENT_TOO_MANY_ERR, MESSAGE_ARGUMENT_END);
        }
        arg_val = eval_expression(inter, env, arg_p-&gt;expression);
        crb_add_local_variable(local_env, param_p-&gt;name, &amp;arg_val);
    }
    if (param_p) {
        crb_runtime_error(expr-&gt;line_number, ARGUMENT_TOO_FEW_ERR, MESSAGE_ARGUMENT_END);
    }

    /* 执行函数体 */
    result = crb_execute_statement_list(inter, local_env, func-&gt;u.crowbar_f.block -&gt;statement_list);

    if (result.type == RETURN_STATEMENT_RESULT) { value = result.u.return_value; } 
    else { value.type = CRB_NULL_VALUE; }

    dispose_local_environment(inter, local_env);

    return value;
}
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="/posts/Boulevard/Compiler/自制编程语言/crowbar源码阅读笔记(4).html">
                    crowbar源码阅读笔记(4):语句构建
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-08-20
                </p>
              </div>
              <div class="content article-body">
                <p>这是《自制编程语言》一书中的脚本语言<code>crowbar</code>的源码阅读笔记(4):语句构建</p>
<h2>语句、语句表、与语句块的结构表示</h2>
<p>如<a href="/2017/08/18/Boulevard/Compiler/%E8%87%AA%E5%88%B6%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/crowbar%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%281%29">《crowbar源码阅读笔记(1):基本的数据结构》</a>中所述，<strong>语句</strong> 、<strong>语句表</strong> 、<strong>语句块</strong> 可以抽象为：</p>
<pre><code class="language-c">struct Statement_tag {
    StatementType       type;
    int                 line_number;
    union {
        Expression      *expression_s;
        GlobalStatement global_s;
        IfStatement     if_s;
        WhileStatement  while_s;
        ForStatement    for_s;
        ReturnStatement return_s;
    } u;
};

typedef struct StatementList_tag {
    Statement   *statement;
    struct StatementList_tag    *next;
} StatementList;

typedef struct {
    StatementList       *statement_list;
} Block;
</code></pre>
<!-- more -->
<h2>语句、语句链表、与语句块的构建机理</h2>
<p>和创建表达式类似，创建语句的时候，也需要申请在内存中开辟一段空间：</p>
<pre><code class="language-c">static Statement * alloc_statement(StatementType type)
{
    Statement *st;
    st = crb_malloc(sizeof(Statement));
    st-&gt;type = type;
    st-&gt;line_number = crb_get_current_interpreter()-&gt;current_line_number;
    return st;
}
</code></pre>
<p>开辟内存之后，再在其中填充<code>Statement</code>结构成员(类型、行号)；最后针对要创建的具体语句类型，填充<code>u</code>成员的特定字段。</p>
<p>语句表是用链表实现的，每个节点都包含一个<code>statement</code>成员指向相应语句和一个<code>next</code>成员指向下一个节点。故创建一个语句表的实现即为申请分配一个<code>StatementList</code>结构体大小的内存空间，然后将其<code>statement</code>成员初始化为指定的语句指针即可：</p>
<pre><code class="language-c">StatementList * crb_create_statement_list(Statement *statement)
{
    StatementList *sl;
    /* 申请开辟一段内存 */
    sl = crb_malloc(sizeof(StatementList));
    
    /* 设置语句链表的第一个节点为指定的语句 */
    sl-&gt;statement = statement;
    /* 把下一个节点初始化为NULL */
    sl-&gt;next = NULL;

    return sl;
}
</code></pre>
<p>仅仅能创建语句链表还不够方便，我们还需要随时可以给某个链表添加语句的功能，与新增变量会放到相关环境中第一个节点不同，新增的语句会作为最后一个节点追加到指定语句链表上：</p>
<pre><code class="language-c">StatementList * crb_chain_statement_list(StatementList *list, Statement *statement)
{
    StatementList *pos;

    if (list == NULL)
        return crb_create_statement_list(statement);

    /* 跳到链表的最后一个节点 */
    for (pos = list; pos-&gt;next; pos = pos-&gt;next)
        ;
    /* 追加新的语句 */
    pos-&gt;next = crb_create_statement_list(statement);

    return list;
}
</code></pre>
<p>构建语句块的过程也要先申请开辟内存，然后填充<code>Block</code>结构——把<code>statement_list</code>成员指向相关的语句表即可：</p>
<pre><code class="language-c">Block * crb_create_block(StatementList *statement_list)
{
    Block *block;

    block = crb_malloc(sizeof(Block));
    block-&gt;statement_list = statement_list;

    return block;
}
</code></pre>
<h2>与关键字相关的语句创建</h2>
<h3>分支判断语句创建</h3>
<p><code>crowbar</code>语言所支持的<code>if</code>语句的语法格式类似于：</p>
<pre><code class="language-ruby"># condition
if(condition)
# then block
{
}
# elsif list
elsif(){
    # ...
}
# else block
else{
    # ...
}
</code></pre>
<p>所以创建<code>if</code>语句的实现思路为先申请开辟一段内存存放<code>Statement</code>结构体，然后填充<code>u</code>成员<code>if_s</code>的相关字段:</p>
<pre><code class="language-c">Statement * crb_create_if_statement(Expression *condition, Block *then_block, Elsif *elsif_list, Block *else_block)
{
    Statement *st;
    st = alloc_statement(IF_STATEMENT);

    st-&gt;u.if_s.condition = condition;
    st-&gt;u.if_s.then_block = then_block;
    st-&gt;u.if_s.elsif_list = elsif_list;
    st-&gt;u.if_s.else_block = else_block;

    return st;
}
</code></pre>
<h3>循环语句创建：</h3>
<p><code>crowbar</code>语言支持<code>while</code>语句，其语法类似于：</p>
<pre><code class="language-ruby">while(condition)
{
    # block 
}
</code></pre>
<p>创建<code>while</code>语句的实现为先申请开辟一段内存存放<code>Statement</code>结构体，然后填充<code>u</code>成员<code>while_s</code>的相关字段：</p>
<pre><code class="language-c">Statement * crb_create_while_statement(Expression *condition, Block *block)
{
    Statement *st;
    st = alloc_statement(WHILE_STATEMENT);

    st-&gt;u.while_s.condition = condition;
    st-&gt;u.while_s.block = block;

    return st;
}
</code></pre>
<p>创建<code>for</code>循环语句与之类似：</p>
<pre><code>Statement * crb_create_for_statement(Expression *init, Expression *cond, Expression *post, Block *block)
{
    Statement *st;
    st = alloc_statement(FOR_STATEMENT);

    st-&gt;u.for_s.init = init;
    st-&gt;u.for_s.condition = cond;
    st-&gt;u.for_s.post = post;
    st-&gt;u.for_s.block = block;

    return st;
}
</code></pre>
<p>与循环相关的还有<code>break</code>和<code>continue</code>语句。由于不涉及其他信息，其实现非常简单，并不填充<code>Statement</code>的<code>u</code>字段：</p>
<pre><code class="language-c">Statement *crb_create_break_statement(void)
{
    return alloc_statement(BREAK_STATEMENT);
}

Statement *crb_create_continue_statement(void)
{
    return alloc_statement(CONTINUE_STATEMENT);
}
</code></pre>
<h3><code>return</code>语句</h3>
<p>创建<code>return</code>语句：</p>
<pre><code class="language-c">Statement * crb_create_return_statement(Expression *expression)
{
    Statement *st;
    st = alloc_statement(RETURN_STATEMENT);

    st-&gt;u.return_s.return_value = expression;

    return st;
}
</code></pre>
<h2>其他语句</h2>
<p>这类结构较为简单。</p>
<h3>表达式语句的创建</h3>
<pre><code class="language-c">Statement * crb_create_expression_statement(Expression *expression)
{
    Statement *st;
    st = alloc_statement(EXPRESSION_STATEMENT);

    st-&gt;u.expression_s = expression;

    return st;
}
</code></pre>
<h3>全局语句的创建</h3>
<pre><code class="language-c">Statement * crb_create_global_statement(IdentifierList *identifier_list)
{
    Statement *st;

    st = alloc_statement(GLOBAL_STATEMENT);
    st-&gt;u.global_s.identifier_list = identifier_list;

    return st;
}
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="/posts/Boulevard/Compiler/自制编程语言/crowbar源码阅读笔记(6).html">
                    crowbar源码阅读笔记(6):语句执行
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-08-20
                </p>
              </div>
              <div class="content article-body">
                <p>这是《自制编程语言》一书中的脚本语言<code>crowbar</code>的源码阅读笔记(6):语句执行。语句执行的实现代码主要存放于文件<code>execute.c</code>中。</p>
<h2>语句执行总体框架</h2>
<h3>单语句执行</h3>
<p>运行单个语句，则和表达式求值的思路一样，要区分具体的语句类型，然后执行不同的策略，最后返回语句执行结果(<code>StatementResult</code>类型对象)：</p>
<pre><code class="language-c">static StatementResult execute_statement(CRB_Interpreter *inter, LocalEnvironment *env, Statement *statement)
{
    StatementResult result;

    result.type = NORMAL_STATEMENT_RESULT;

    switch (statement-&gt;type) {
    case EXPRESSION_STATEMENT:
        result = execute_expression_statement(inter, env, statement);
        break;
    case GLOBAL_STATEMENT:
        result = execute_global_statement(inter, env, statement);
        break;
    case IF_STATEMENT:
        result = execute_if_statement(inter, env, statement);
        break;
    case WHILE_STATEMENT:
        result = execute_while_statement(inter, env, statement);
        break;
    case FOR_STATEMENT:
        result = execute_for_statement(inter, env, statement);
        break;
    case RETURN_STATEMENT:
        result = execute_return_statement(inter, env, statement);
        break;
    case BREAK_STATEMENT:
        result = execute_break_statement(inter, env, statement);
        break;
    case CONTINUE_STATEMENT:
        result = execute_continue_statement(inter, env, statement);
        break;
    case STATEMENT_TYPE_COUNT_PLUS_1:   /* FALLTHRU */
    default:
        DBG_panic((&quot;bad case...%d&quot;, statement-&gt;type));
    }

    return result;
}
</code></pre>
<!-- more -->
<p>不同语句有不同的执行结果，语句执行结果抽象为一个结构体</p>
<pre><code class="language-c">typedef struct {
    StatementResultType type;
    union {
        CRB_Value       return_value;
    } u;
} StatementResult;
</code></pre>
<p>语句的执行结果有不同类型，可以分为:</p>
<ul>
<li><code>NORMAL_STATEMENT_RESULT</code>：常规语句执行</li>
<li><code>RETURN_STATEMENT_RESULT</code>: 返回语句执行</li>
<li><code>BREAK_STATEMENT_RESULT</code> : <code>break</code>语句执行</li>
<li><code>CONTINUE_STATEMENT_RESULT</code>: <code>continue</code>语句执行</li>
<li><code>STATEMENT_RESULT_TYPE_COUNT_PLUS_1</code>:</li>
</ul>
<p>其中，<code>RETURN_STATEMENT_RESULT</code>、<code>BREAK_STATEMENT_RESULT</code>标识了将要中断循环；而<code>CONTINUE_STATEMENT_RESULT</code>则表示要循环体语句的执行<code>crb_execute_statement_list()</code>将要被中断。</p>
<p>语句执行后的结果值用联合<code>u</code>表示，目前只有个表示返回值的<code>return_value</code>字段，这是一个<code>CRB_Value</code>型结构，可以统一表达各种类型的返回值。</p>
<h3>语句链表的执行</h3>
<p>语句链表的执行，是依次执行语句并检查执行结果：</p>
<pre><code class="language-c">StatementResult crb_execute_statement_list(CRB_Interpreter *inter, LocalEnvironment *env, StatementList *list)
{
    StatementList *pos;
    StatementResult result;

    result.type = NORMAL_STATEMENT_RESULT;
    for (pos = list; pos; pos = pos-&gt;next) {
        result = execute_statement(inter, env, pos-&gt;statement);
        if (result.type != NORMAL_STATEMENT_RESULT)
            goto FUNC_END;
    }

  FUNC_END:
    return result;
}
</code></pre>
<h2>表达式语句</h2>
<p>表达式类型的语句执行非常简单，就是对相应的表达式进行求值：</p>
<pre><code class="language-c">static StatementResult execute_expression_statement(CRB_Interpreter *inter, LocalEnvironment *env, Statement *statement)
{
    StatementResult result;
    CRB_Value v;

    result.type = NORMAL_STATEMENT_RESULT;

    v = crb_eval_expression(inter, env, statement-&gt;u.expression_s);
    if (v.type == CRB_STRING_VALUE) {
        crb_release_string(v.u.string_value);
    }

    return result;
}
</code></pre>
<p>表达式语句不设置语句返回值，只是填充<code>type</code>为<code>NORMAL_STATEMENT_RESULT</code>。比如：</p>
<pre><code class="language-js">v1=3+4*2;
</code></pre>
<p>这是一个 <strong>赋值表达式</strong> 构成的语句。赋值表达式求值会计算等号右边的值，然后赋给<code>v1</code>标识符对应的变量。最后当这个语句执行完毕后返回一个执行结果。
注意，该语句结果并不包含表达式的值，只告诉解释器，该语句执行完毕后是一个<code>NORMAL_STATEMENT_RESULT</code>。</p>
<h2>与关键字相关的语句</h2>
<h3><code>return</code> 语句执行</h3>
<p><code>return</code>语句的执行本身比较简单，最后也是返回一个语句执行结果，该结果的<code>type</code>字段为<code>RETURN_STATEMENT_RESULT</code>，而具体的执行值在<code>u.return_value</code>字段中填充：</p>
<ul>
<li>如果后面跟着一个表达式，则对表达式进行求值，然后填充至结果的<code>u.return_value</code>字段。</li>
<li>否则，设置<code>u.return_value.type</code>为<code>CRB_NULL_VALUE</code>。</li>
</ul>
<pre><code class="language-c">static StatementResult execute_return_statement(CRB_Interpreter *inter, LocalEnvironment *env, Statement *statement)
{
    StatementResult result;
    result.type = RETURN_STATEMENT_RESULT;

    if (statement-&gt;u.return_s.return_value) {
        result.u.return_value = crb_eval_expression(inter, env, statement-&gt;u.return_s.return_value);
    } else {
        result.u.return_value.type = CRB_NULL_VALUE;
    }

    return result;
}
</code></pre>
<h3><code>for</code> 循环语句执行</h3>
<p>一个完整的<code>for</code>语句可以拆分4个部分，即<code>init</code>、<code>condition</code>、 <code>post</code>、<code>block</code> ：</p>
<pre><code class="language-c">for(init;condition;post)
    block
</code></pre>
<p>具体执行过程是：</p>
<ol>
<li>先对<code>init</code>部分的表达式进行求值，</li>
<li>然后检测是否达到终止条件，</li>
<li>如果未达到，则执行<code>for</code>语句块。</li>
<li>如果执行结果满足<code>return</code>、<code>break</code>这类跳出条件的，则终止循环。</li>
<li>如果需要继续，则执行<code>post</code>相关表达式</li>
<li>最后开始下一次循环。</li>
</ol>
<pre><code class="language-c">static StatementResult execute_for_statement(CRB_Interpreter *inter, LocalEnvironment *env, Statement *statement)
{
    StatementResult result;
    CRB_Value   cond;

    result.type = NORMAL_STATEMENT_RESULT;

    /* 对for循环的init表达式求值 */
    if (statement-&gt;u.for_s.init) {
        crb_eval_expression(inter, env, statement-&gt;u.for_s.init);
    }
    for (;;) {
        /* 检测是否满足for循环的condition */
        if (statement-&gt;u.for_s.condition) {
            cond = crb_eval_expression(inter, env, statement-&gt;u.for_s.condition);
            if (cond.type != CRB_BOOLEAN_VALUE) {
                crb_runtime_error(statement-&gt;u.for_s.condition-&gt;line_number, NOT_BOOLEAN_TYPE_ERR, MESSAGE_ARGUMENT_END);
            }
            DBG_assert(cond.type == CRB_BOOLEAN_VALUE, (&quot;cond.type..%d&quot;, cond.type));
            if (!cond.u.boolean_value)
                break;
        }
        /* 执行for循环的循环体block */
        result = crb_execute_statement_list(inter, env, statement-&gt;u.for_s.block -&gt;statement_list);

        /* 检测是否需要返回 */
        if (result.type == RETURN_STATEMENT_RESULT) {
            break;
        }
        /* 检测是否需要中断循环 */
        else if (result.type == BREAK_STATEMENT_RESULT) {
            result.type = NORMAL_STATEMENT_RESULT;
            break;
        }

        /* 对for循环的post表达式求值 */
        if (statement-&gt;u.for_s.post) {
            crb_eval_expression(inter, env, statement-&gt;u.for_s.post);
        }
    }

    return result;
}
</code></pre>
<h2>其他语句</h2>
<p>其他语句与上述语句类似，不再赘述。</p>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <div class="container">
      <div class="container has-text-centered">
        <a href="/posts/page14.html">
          Previous
        </a>
        16 of 32
        <a href="/posts/page16.html">
          Next
        </a>
      </div>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
      
 // 处理形如 <code>$E=mc^2$</code> 形式的公式
  var inlineMathNodes=document.querySelectorAll('code');
  var re=/^\$(.*)\$$/;
  for(var j=0;j<inlineMathNodes.length;j++){
    var result=re.exec(inlineMathNodes.item(j).innerText);
    if(result!==null){
      katex.render(result[1], inlineMathNodes.item(j));
    }
  }
  function removeNode(node){
    if(node.remove){
      node.remove();
    }else{
      return first.parentNode.removeChild(node);
    }
  };

  // 查找所有 pre code.language-math 节点 以备筛出数据公式
  var nodes=document.querySelectorAll("pre code.language-math");
  for(var i=0;i<nodes.length;i++){
    var node=nodes.item(i);
    // 魔术标记所在行 
    try{
      var lines = node.innerText.split('\n');
      if((!!lines) && lines.length > 0)
      {
        var first = lines[0];
        if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
          var views = "";
          // 逐行渲染
          for(var k=1; k <lines.length; k++){
              var f=lines[k];
              views += katex.renderToString(f);
          }
          // 消除父级嵌套 
          try{
            node.innerHTML=views;
          }catch(e){
            // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
            console.log('IE9 sucks',e);
            $(tr).html(node.innerHTML);
          }
        }
      }
    }
    catch(err){
      console.log(err)
    }
  }
    
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>