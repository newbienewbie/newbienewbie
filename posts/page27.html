<!DOCTYPE html><html>
  <head>
    <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie/"/>
    <script>
      document.addEventListener('DOMContentLoaded', () => {

	// Get all "navbar-burger" elements
	const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);
  
	// Check if there are any navbar burgers
	if ($navbarBurgers.length > 0) {
  
	  // Add a click event on each of them
	  $navbarBurgers.forEach( el => {
		el.addEventListener('click', () => {
  
		  // Get the target from the "data-target" attribute
		  const target = el.dataset.target;
		  const $target = document.getElementById(target);
  
		  // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
		  el.classList.toggle('is-active');
		  $target.classList.toggle('is-active');
  
		});
	  });
	}
  });
    </script>
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/fsharp.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item is-active" href="">
            Home
          </a>
          <a class="navbar-item" href="tags.html">
            Tags
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/Python/Python函数装饰器原理分析.html">
                    Python函数装饰器原理分析
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Python
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#Python">
                    <span class="tag is-info">
                      Python
                    </span>
                  </a>
                  <a href="tags.html#装饰器">
                    <span class="tag is-info">
                      装饰器
                    </span>
                  </a>
                  <a href="tags.html#原理分析">
                    <span class="tag is-info">
                      原理分析
                    </span>
                  </a>
                  <a href="tags.html#AOP">
                    <span class="tag is-info">
                      AOP
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2015-04-10
                </p>
              </div>
              <div class="content article-body">
                <p>函数装饰其实类比为游戏里装备强化的概念。比如将一个具有附加火性伤害的宝石，镶嵌到了一个主武器上，那么武器就能在原有功能的基础之上附带有火伤效果。具体到Python函数装饰就是，一个装饰器函数dec，装饰到了一个函数foo上，就能让foo具有dec功效，可以形象得说成是dec装饰到了foo上。</p>
<h2>基本原理</h2>
<h3>从扩展功能说起</h3>
<p>先抛开游戏程序的概念不谈，假如我们有一个函数foo()</p>
<pre><code class="language-Python">def foo():
     print(&quot;calling foo():\thave fun with Brz&quot;)
</code></pre>
<p>出于某种原因，有一天我希望在函数原有功能之上追加一点工作量——在函数执行之前和之后实现一些和 foo 函数完全可以分离的工作，我们当然不想直接改动已经写好的 foo ,所以自然而然想去定义一个新函数，在这个函数内部调用 foo 函数：</p>
<pre><code class="language-Python">def foo_appended(func):
     print(&quot;before calling:\tmiss Brz&quot;)
     func()
     print(&quot;after calling:\tsay good bye&quot;)

foo_appended(foo)
</code></pre>
<p>输出为：</p>
<pre><code>before calling:    miss Brz
calling foo():    have fun with Brz
after calling:    say good bye
</code></pre>
<p>这种做法，对于一些小程序当然没有问题，但是对于稍微大的项目或者涉及到接口的时候情况就明显不同了：假如用户（可以是其他程序员，也可以是自己）使用了 foo() ，就得把之前所有的 foo() 全部改成 foo_appended(foo) ; 随着要附加的事情（权限检查、其他检查、日志记录、触发某个接口等）越来越多，最后的函数名可能是 foo_f1_f2_f3_f4_f5_appended 这种，这很显然是个很蠢的做法。
更关键的，这样一点都不 <a href="http://www.itminus.com/tags/AOP/">AOP</a> ！一个有追求的人绝不会容忍这种代码！</p>
<h3>装饰器实现</h3>
<p>理论基础是<code>Python一切皆对象，包括函数</code>。所以可以对函数进行普通对象一样的操作：接收作为参数、传递为返回值、赋值（引用新对象）。
为了方便起见，我们不妨把原函数称之为&quot;目标函数&quot;,在不改动目标函数内部实现的情况下，想在目标函数原有工作前后追加工作量(甚至完全替换掉目标函数的工作)，这需要一个偷梁换柱的方法来实现：</p>
<ul>
<li>定义一个装饰器函数，此函数会接受函数对象作为输入参数，以确保能执行其功能</li>
<li>在装饰器函数内定义一个和目标函数参数列表一致的包装函数，同时添加欲追加的工作量(甚至彻底替换掉目标函数)</li>
<li>装饰器函数返回值设置为包装函数</li>
<li>把目标函数对象传递给装饰器函数去执行，返回值(包装函数)赋值到目标函数名上。</li>
<li>用户以目标函数之名调用包装函数。</li>
</ul>
<pre><code class="language-Python">def foo(): #目标函数
     print(&quot;while calling :\thave fun with Brz&quot;)

def foo_appended(func): #定义一个新函数（装饰函数），装饰函数接受一个函数对象作为参数
     def wrap(): #包装函数
         print(&quot;before calling :\tmiss Brz&quot;) 
         func() #执行目标函数
         print(&quot;after calling :\tsay good bye to Brz&quot;)
     return wrap #返回包装函数

foo = foo_appended(foo) # foo不再指向原始的目标函数，而是指向包装函数

#用户调用其熟悉的foo()
foo()
</code></pre>
<p>输出结果为：</p>
<pre><code class="language-Python">before calling :    miss Brz
while calling :    have fun with Brz
after calling :    say good bye to Brz
</code></pre>
<p>这就是函数装饰的基本原理与实现。</p>
<h3>核心思想</h3>
<p>Python装饰器能扩展原函数，核心在于动态生成了一个包装函数，该包装函数负责扩展目标函数(甚至完全替换掉目标函数的所有工作)。最后把该包装函数当目标函数一样使用。</p>
<p>对诸如<code>PHP</code>、<code>JavaScript</code>这类动态语言，甚至对于<code>C</code>/<code>C++</code>，由于函数指针的存在，可以很容易写出类似的装饰器。
那么，对于<code>Java</code>,如何实现？装饰器模式、代理模式便是解决方案。思路是类似的，当然也是生成一个包装对象（代理），通过包装对象（代理）来扩展原始对象！</p>
<h2>语法糖</h2>
<p>为了把装饰函数和被装饰函数的脉络在代码形式上表现的更清晰、简介，我们可以使用函数装饰符<code>@</code>这个语法糖</p>
<pre><code class="language-Python">def dec_foo(func):
     def wrap(p):
        #do something
         pass #func and sth
     return wrap

@dec_foo
def foo(p):
    #do something
     pass
</code></pre>
<p>阅读别人的代码，更多的是看到</p>
<pre><code class="language-Python">@dec
def foo(para):
     pass 
</code></pre>
<p>的形式，从这个形式，我们可以得出结论，</p>
<p><code>dec接收一个func参数，内部会一个参数列表和原foo函数的参数列表保持兼容的包装函数。原foo经过装饰后（重新赋值后），就有了装饰器函数的功能。</code></p>
<p>总结来说，装饰器函数只做三件事：</p>
<ol>
<li>接收一个函数作为参数，</li>
<li>然后嵌套一个包装函数（包装函数的参数列表与目标函数参数列表兼容），</li>
<li>再返回嵌套函数对象。</li>
</ol>
<p>可以把第2步、第3步合并为一步，但是根本要旨是要返回一个函数对象（对目标函数进行包装，不妨称之为包装函数）。</p>
<p>这个包装函数会做三件事</p>
<ol>
<li>接受参数：能兼容目标函数参数列表</li>
<li>执行目标函数</li>
<li>执行附加功能</li>
</ol>
<h2>装饰器的应用</h2>
<p>装饰器的应用非常多，比如：</p>
<ul>
<li><code>Python</code>本身内置了和面向对象相关的装饰器：类属性<code>@property</code>、类静态方法<code>@staticmethod</code>、类方法<code>@classmethod</code>装饰器。</li>
<li>在<code>Django</code>中随处可见诸如<code>@require_login</code>检查登陆之类的功能。</li>
</ul>
<p>不管咋说，它始终都是用来做<code>功能解耦、代码分离</code>的。在 Java Spring 中，我们也经常需要做类似的事情，比如为某些组件添加权限检查、日机功能，一个好的思路就是采用 <a href="http://www.itminus.com/tags/AOP/">AOP</a> ,就是为相应组件建立切面(<code>Aspect</code>)，然后针对相应的连接点(<code>JointPoint</code>)进行增强(<code>Advice</code>)。</p>
<p>回到本文开头提到的游戏装备强化的概念上来，假如现在我们想为某款游戏开发一个辅助工具——装备模拟器，要模拟宝石强化后附伤效果。</p>
<p>首先定义一个伤害数据类型:</p>
<pre><code class="language-Python">
class Damage:
    '''
    damage data structure
    '''

    def __init__(self):
        self._damage={ 'fire':0, 'ice':0, 'poison':0, 'wind':0 }

    def add(self,key,value):
        self._damage[key]=self._damage[key]+value
    
    def minus(self,key,value):
        self._damage[key]=self._damage[key]-value
        if(self._damage[key]&lt;0):
            self._damage[key]=0

    def __getattr__(self,key):
        return self._damage[key]

</code></pre>
<p>现有一个白板武器伤害计算公式(根据武器等级计算)，返回<code>Damage</code>对象。其中某个实现可能是长这样：</p>
<pre><code class="language-Python">def weapon_damage(weapon_level):
    '''
    calculate the damage according to weapon_level
    '''

    damage=Damage()
    damage.add('fire',weapon_level*2.1)
    damage.add('poison',weapon_level*1.7)
    return damage 
</code></pre>
<p>许多游戏都有武器强化系统，经过某种宝石镶嵌，会为之添加附伤效果。为了扩展 <code>weapon_damage</code> 的功能，使得可以计算经过宝石镶嵌后的武器伤害，我们需要为之编写装饰器：</p>
<pre><code class="language-Python">def perled_damage(weapon_damage,perl_level): 
    '''
    decorator:return a new weapon_damage function
    '''
    def wrap_weapon_damage(weapon_level):
        damage=weapon_damage(weapon_level)
        damage.add('fire',perl_level*0.5)
        damage.add('ice',perl_level*1.0)
        return damage 
    return wrap_weapon_damage
</code></pre>
<p>然后把这个装饰函数装饰到原有的武器伤害函数<code>weapon_damage</code>上，即可得到扩展后的伤害计算函数:</p>
<pre><code class="language-Python">
weapon_damage=perled_damage(weapon_damage,10)

damage=weapon_damage(2)
print damage.__dict__
</code></pre>
<p>输出：</p>
<pre><code>{'_damage': {'fire': 9.2, 'wind': 0, 'poison': 3.4, 'ice': 10.0}}
</code></pre>
<p>当然，为了灵活起见，我们完全可以把装饰、调用在一个语句里完成：</p>
<pre><code class="language-Python">damage=perled_damage(weapon_damage,10)(2)
print damage.__dict__
</code></pre>
<p>这样即可得到一个通用的方法，变量只有<code>weapon_level</code>、<code>weapon_damage</code>！也即是拿到这两个数据就能计算出相应的伤害！</p>
<h2>其他语言</h2>
<p>为了理解真正理解装饰器的核心原理，可以写下其它语言的实现：</p>
<h3>PHP版</h3>
<pre><code class="language-PHP">
//执行某功能的函数
$have_fun_with_brz=function (){
    echo &quot;have fun with brz\r\n&quot;;
};

//装饰器
$dec=function ($func) {
    $wrap=function ()use ($func) {
        echo &quot;before calling\r\n&quot;;
        $func();
        echo &quot;after calling\r\n &quot;;
    };
    return $wrap;
};

//装饰
$have_fun_with_brz=$dec($have_fun_with_brz);

//调用经过装饰的目标函数
$have_fun_with_brz();
</code></pre>
<p>输出为：</p>
<pre><code>before calling
have fun with brz
after calling
</code></pre>
<h3>JavaScript版</h3>
<pre><code class="language-JavaScript">
// 某功能
function haveFunWithBrz(){
  console.log(&quot;have fun with brz\r\n&quot;);
}

// 装饰器
var dec=function (func) {
    return function (){
         console.log(&quot;before calling\r\n&quot;);
        func();
         console.log(&quot;after calling\r\n &quot;);
    };
};

// 装饰
haveFunWithBrz=dec(haveFunWithBrz);

// 调用
haveFunWithBrz();
</code></pre>
<p>输出为:</p>
<pre><code>before calling
have fun with brz
after calling
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/Python/Python迭代器、生成器、生成器表达式.html">
                    Python 迭代器、生成器、生成器表达式
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Python
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#Python">
                    <span class="tag is-info">
                      Python
                    </span>
                  </a>
                  <a href="tags.html#原理分析">
                    <span class="tag is-info">
                      原理分析
                    </span>
                  </a>
                  <a href="tags.html#生成器">
                    <span class="tag is-info">
                      生成器
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2015-04-10
                </p>
              </div>
              <div class="content article-body">
                <h1>从iter()和next()两个内置函数说起</h1>
<p>迭代过程的本质是循环，为了回归本质，考虑一个最简单的C语言for循环</p>
<pre><code class="language-C">for(int i=0;i&lt;10；i++){
    printf(“%d\n”,i);
}
</code></pre>
<p>这个循环过程是通过循环变量控制的：</p>
<ul>
<li>首先i=0，执行循环语句；</li>
<li>然后i=1，执行循环语句；</li>
<li>…</li>
<li>然后i=9，执行循环语句；</li>
<li>然后i=10，终止循环。</li>
</ul>
<p>可以发现，在这个循环过程中，循环过程控制变量i有个初值，然后每一次循环之后这个循环控制变量都要变化到另一个值以控制下一次循环。
循环过程控制变量的概念可以类比到迭代器上，迭代器就是迭代过程控制器。和循环控制过程一样，要实现迭代控制，迭代器必须也有个初值，然后在每一个迭代过程都要能按一定规律变化到另一个值。因此，一个对象要成为迭代器，必须拥有两个能力：</p>
<ul>
<li>能给定自己的初始状态</li>
<li>能把迭代器对象从当前状态变化到后续状态</li>
</ul>
<p>Python3.x提供了2个内置函数来实现这一控制。</p>
<ul>
<li>iter()：利用一个可迭代对象生成迭代器，即iter(iterable)==&gt; iterator ，此内置函数会调用iterable.<strong>iter</strong>()方法。</li>
<li>next()：把一个迭代器从当前状态变化到后续状态，即next(iterator[, default])==&gt;the next item from the iterator. 可以调用iterator.<strong>next</strong>()方法 。（注意，原Python2.7里iterator .next()的调用方式在3.x里已经被移除）</li>
</ul>
<p>这里有两个关键的概念是iterable和iterator。</p>
<h1>iterable和iterator</h1>
<p>此部分翻译自官网文档，并加入一些自己的理解</p>
<blockquote>
<p>iterable：可迭代对象。一种能够一次返回其一个member的object（”An object capable of returning its members one at a time”）。这句话读起来很拗口，不准确的说，iterable代表了序列、集合和其他类似集合的对象，他们是可以迭代的，他们是一系列item的整体。 iterables例子包括所有的sequence types（比如list，str, and tuple）和一些如dict、file以及一些你定义了__iter__()或__getitem__()方法的Class的非序列类型 。iterable能被用于for循环和其他需要一个sequence的场景。可以用iter(iterable)返回一个iterator。当使用iterables，通常没必要自己亲自调用iter()或者处理iterator 对象。for语句会帮我们自动创建未命名的临时变量来容纳loop持续期间的iterator。</p>
</blockquote>
<blockquote>
<p>iterator：迭代器。一种代表了一系列数据的对象（An object representing a stream of data）. 在这一系列数据的对象中，会重复调用iterator's的__next__()方法，并返回成功了的items。当没有合适数据的时候会引发StopIteration 异常 。所有迭代器都要求实现一个能返回自身iterator对象的__iter__() 方法 ，所以每一个iterator都是一个iterable，并且能被用在很多能接受iterables地方。值得注意的是，每次将container object传递给iter()，或者在for-loop里调用，都会产生一个崭新的iterator。</p>
</blockquote>
<p>不准确的说，对于Python</p>
<ul>
<li>如果一个对象，拥有__iter__()方法（可以给定自己初始状态），则其为iterable。</li>
<li>如果一个对象，拥有__iter__()和__next__()方法（可以给定自己的初始状态+可以从一个状态变化到另一个后续状态），则其为迭代器。</li>
</ul>
<p><code>注意：不要以为Python的序列类型（如list,tuple,str）是迭代器，实际上它们只是可迭代对象</code>。如果你直接对调用next(list)就会发现系统提示你list object is not an iterator。对于一个list对象a_list，可以通过iter(a_list)生成一个迭代对象，也可以通过生成器表达式或者生产器函数得到一个迭代器。参见生成器</p>
<p>那么为什么要区分一个可迭代对象和迭代器对象呢？其理由和Java中的iterable、iterator一样。
简单的说，</p>
<ul>
<li>iterable更多的是代表了一个包含若干items的整体，这类整体是可以进行迭代(遍历)的；</li>
<li>而iterator则更多表达了一个拥有当前状态的iterable对象，这个iterator对象会经过next()对其自身的状态进行变更。
比如，一个列表对象(iterable)是包含若干items的sequence，但是列表对象(iterable)并不应该标记当前状态是哪一个item——这个工作应该交给一个与iterable相关的迭代器对象（iterator）来处理（通过iter(iterable)得到）。</li>
</ul>
<h1>Python for...in...的本质</h1>
<p>Python的for...in...循环语法和bash shell的for...in...语法有一定程度的类似。一个简单的Python for语句如下：</p>
<pre><code class="language-Python">a_list = ['a', 'b', 'mpilgrim', 'z', 'example']
for i in a_list:
    print(i)
</code></pre>
<p>其过程可以理解为迭代之初，Python自动调用了iter(a_list)生成一个iterator对象，不妨暂时称之为iterInstance（实际上这是个未命名的变量），过程可以描述为：iterInstance=iter(a_list),然后在循环过程中一路next(iterInstance)，直至抛出StopIteration。
这两个内置函数iter()、 next()是和迭代器内部的__iter__()和__next__()两个方法是对应的。</p>
<p>这一点和PHP的<code>foreach($iter as $k=&gt;$v)</code> 不同，PHP中，foreach操作的是iterator，而Python中for in 操作的则是iterable。</p>
<h1>自定义的Python iterator类</h1>
<p>根据Python官网PEP-0234，一个Class想要变成一个迭代器，应该实现两个方法：
一是__next__()方法（原文是next()方法，但是在最新的Python3.x此方法被移除了，统一表示为__next__()方法，还增加了个和iter()对应的内置函数next()），<strong>next</strong>()方法要么返回本次迭代过程的the next value ,要么引发一个StopIteration表示本次迭代终止。
二是实现一个__iter__() 方法，会返回自身这个迭代器。
以下代码引自《深入 Python 3》第七章：</p>
<pre><code class="language-Python">class Fib:
    def __init__(self, max):
        self.max = max

    def __iter__(self):
        self.a = 0
        self.b = 1
        return self

    def __next__(self):
        fib = self.a
        if fib &gt; self.max:
            raise StopIteration
        self.a, self.b = self.b, self.a + self.b
        return fib
for n in Fib(1000):
    print(n,)
</code></pre>
<p>for循环过程为:</p>
<ul>
<li>Fib(1000)调用__init__()生成一个fib对象（即一个Instance of Fib）,对应的fib.max=1000，</li>
<li>然后调用iter(fib)通过fib.<strong>iter</strong>()得到了一个fibIterator，也即为上述for循环里的n，不过为了清楚表示这是个Fib类的迭代器，不妨暂时称之为fibIterator，于是对应的fibIterator.a=0，fibIterator.b=1。</li>
<li>fibIterator循环体执行（此处即为由print打印）后，后台调用next(fibIterator),通过fibIterator.<strong>next</strong>()得到下一个fibIterator。</li>
</ul>
<h1>生成器（Genenrator）与生成器表达式</h1>
<p>使用iterable或者iterator对象，有时候会遇到的问题是，一次性产生一系列元素会有些不划算。比方说，有一个很大的a_list对象，我们需要对其每一个元素都以f(x)的映射关系生成中间变量temp_list对象，后面再对，一个思路是列表解析：</p>
<pre><code class="language-Python">temp_list=[f(i) for i in a_list ]
</code></pre>
<p>但是这样比较耗费内存，生成器可以解决这一问题。</p>
<p>仅从字面意义上说，生成器Generator就是指能生成多个对象的对象。生成器是迭代器的一个派生类。在函数内部，通过使用yield使函数挂起（suspend），并生成（yield）了相应对象，当下一次运行的该函数的时候，该函数会从原来挂起的地方继续运行。</p>
<p>我们可以通过在函数内部使用一系列yield来使函数对象表现出迭代器的性质。yield提供了非常便利的迭代方式。
我们也可以用生成器表达式来生成迭代器。
例如：</p>
<pre><code class="language-Python"> for i in a_list:
        yield f(i)
</code></pre>
<p>或者：</p>
<pre><code class="language-Python">（f(i) for i in a_list）
</code></pre>
<p>都可以从a_list映射出一个新的迭代器</p>
<p>注意！<code>生成器表达式的值是迭代器（iterator）！生成器表达式的值具有一次性使用的特点！</code>换言之，如果这个生成器表达式的值已经在之前遍历结束，再次遍历的时候迭代器并不会自动重新开始！如果需要多次使用，务必重新产生一个生成器！</p>
<pre><code class="language-Python">&gt;&gt;&gt; a_dict={'a':1,'b':2,'c':3,'d':4,'e':5}
&gt;&gt;&gt; x_gen=((a,b) for a,b in a_dict.items())
&gt;&gt;&gt; for item in x_gen:
...      print(item)
... 
('b', 2)
('c', 3)
('a', 1)
('d', 4)
('e', 5)
&gt;&gt;&gt; for item in x_gen:    #这里x_gen在上一步已经遍历结束了！继续遍历的什么结果都没有！
...       print(item)
... 
&gt;&gt;&gt; 
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/PHP/PHPCMS/PHPCMS分析1-基础架构分析.html">
                    PHPCMS分析1-基础架构分析
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        PHP
                      </a>
                    </li>
                    <li>
                      <a href="">
                        PHPCMS
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#PHPCMS">
                    <span class="tag is-info">
                      PHPCMS
                    </span>
                  </a>
                  <a href="tags.html#源码分析">
                    <span class="tag is-info">
                      源码分析
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2015-04-10
                </p>
              </div>
              <div class="content article-body">
                <p>PHPCMS整体设计思路，还是遵循基本的MVC模式。</p>
<h2>路由功能与控制器的分离</h2>
<p>PHPCMS访问index.php文件时，会加载phpcms/base.php文件，
该base.php文件定义了一堆常量、和一个pc_base类。此pc_base类提供一系列静态方法，这些静态方法的功能大多都是用于加载与index.php同级目录下的phpcms/下的各个相关文件(load_config除外)，如：</p>
<pre><code class="language-PHP">//加载系统类 位于phpcms/libs/classes/下
pc_base::load_sys_class(&quot;类名&quot;,&quot;模块名&quot;,$initialize);
//加载系统函数 位于phpcms/libs/functions/下 
pc_base::load_sys_func('函数名');

//加载模块下的类 位于phpcms/modules/模块/classes/下
pc_base::load_app_class(&quot;类名&quot;,&quot;模块名&quot;,$initialize);
//加载模块下的函数 位于phpcms/modules/模块/functions/下 
pc_base::load_app_func();

//加载数据模型 位于phpcms/model/下 
$db=pc_base::load_model(&quot;文件名_无后缀&quot;);

//加载配置 位于caches/下
$v=pc_base::load_config($filename,$key);
</code></pre>
<p>在index.php加载完base.php后，又执行了pc_base::creat_app()函数。此函数定义为：</p>
<pre><code class="language-PHP">public static function creat_app() {
    return self::load_sys_class('application');
}

</code></pre>
<p>此方法只是简单加载系统类application。
从功能上说，application类起到了一个路由功能，其构造函数__construct()会调用init()方法，根据传入的相关URL参数去调用对应的module下相关controller的特定action方法。</p>
<p>module、controller、action对应参数m、c、和a。如果不提供action参数，则会默认调用控制器的init()方法。</p>
<p>例如url为<code>index.php?m=product&amp;c=index&amp;a=lists</code>会调用product模块下的index类中的lists方法。</p>
<h2>数据模型加载</h2>
<p>在控制器中利用语句</p>
<pre><code class="language-PHP">$md=pc_base::load_model('your_model');
</code></pre>
<p>可以加载相关模型类，系统的模型类在libs/classes/model.class.php中定义，各模块下模型定义在model/文件下，并继承自系统的model类。</p>
<h2>视图层模板加载</h2>
<p>对于控制器模板，基本思路还是利用</p>
<pre><code class="language-PHP">include $your_template_file_name;
</code></pre>
<p>但是PHPCMS根据前后台的不同，在自身文件结构目录上自定义两个求得路径的函数</p>
<ul>
<li>template($module,$file) 获取指定module前台模板</li>
<li>admin_tpl($file,$module) 获取指定module下的后台模板（默认是获取当前module的后台模板）</li>
</ul>
<p>如后台模板经常会在顶部调用：</p>
<pre><code class="language-PHP">include $this-&gt;admin_tpl('header', 'admin');
</code></pre>
<p>以此来加载admin/templates/header.tpl.php文件</p>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/PHP/Symfony/Symfony架构分析.html">
                    Symfony架构分析
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        PHP
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Symfony
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#Symfony">
                    <span class="tag is-info">
                      Symfony
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2015-04-10
                </p>
              </div>
              <div class="content article-body">
                <p>接触到的第一个PHP 框架就是CodeIgniter。轻巧，入门简单,概念清晰。</p>
<p>然而我快发现，我很难复用CodeIgniter的代码--代码耦合度太高了，所以我开始试着写了一个自己的MVC框架 <a href="https://github.com/newbienewbie/Bamboo">Bamboo</a>。我想包装自己的类和模块，这样我就可以搭积木一样搭建各种网站了。当然，我只写了个基本框架，下面的重头戏是把所有的模块都自己实现。比如，Logger，Security，Upload，etc.我开始意识到这是个浩大的工程，然后计划搁浅了。</p>
<p>直到有一天,我在Laravel里看到了它使用了Symfony组件的时候，我才发现，原来我在视图造一个很大的轮子。Symfony是可复用的,是组件化的。</p>
<h2>Request-Response模型</h2>
<p>从本质上来说，HTTP协议实际上描述了一个Request-Response模型。与之相关的PHP代码实际上都在做着<code>解释请求、生成响应</code>的工作，Symfony则更进一步的将Request和Response对象化了。</p>
<p>Request-Response模型是整个Symfony的基础模型，可以毫不夸张的说，整个Symfony都构筑在这个基础模型之上(参见Front Controller部分)。</p>
<h3>Request对象</h3>
<p>Request类很简单，封装了原生PHP的各大超全局输入变量:</p>
<pre><code class="language-PHP">use Symfony\Component\HttpFoundation\Request


$request = Request::createFromGlobals();

$request-&gt;getPathInfo();    //the URI being requested (e.g. /about) minus any query parameters
$request-&gt;query-&gt;get('foo');    //$_GET 
$request-&gt;request-&gt;get('bar', 'default value if bar does not exist');    /$_POST
$request-&gt;server-&gt;get('HTTP_HOST');    //$_SERVER
$request-&gt;files-&gt;get('foo');     //retrieves an instance of UploadedFile identified by foo
$request-&gt;cookies-&gt;get('PHPSESSID');   //$_COOKIE 
$request-&gt;headers-&gt;get('host');
$request-&gt;headers-&gt;get('content_type');
$request-&gt;getMethod();    //GET, POST, PUT, DELETE, HEAD
$request-&gt;getLanguages(); // an array of languages the client accepts
</code></pre>
<h3>Response对象</h3>
<p>Response类也非常简单，用来代替原生PHP的echo(),header():</p>
<pre><code class="language-PHP">Symfony\Component\HttpFoundation\Response

$response = new Response();

$response-&gt;setContent('&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');
$response-&gt;setStatusCode(Response::HTTP_OK);
$response-&gt;headers-&gt;set('Content-Type', 'text/html');
// prints the HTTP headers followed by the content

$response-&gt;send();
</code></pre>
<h2>Front Controller</h2>
<p><img src="#" alt="Symfony分层架构图" /></p>
<p>说来惭愧，第一次看到Front Controller的概念还是在PHPWind的9.x的源代码里看到的，当时还天真的以为它是PHPWind9.x的开发人员想出来的名词。后来看Symfony也有这个概念，这才发现原来自己是多么的孤陋寡闻。当然，我们一直都在使用这个东西，只是不知道那就叫FrontController.</p>
<p>一般情况下，代码会以各个独立的模块分层存在。为了根据请求的不同调用合适的功能代码，一些如CodeIgniter的框架(包括我自己写的Bamboo)都有一个统一入口文件(index.php)负责这项工作。
在Symfony等一些框架(其他如PHPWind9.x以后的版本)中，单独抽象出了Front Controller的概念。和CodeIgniter中的index.php一样，Front Controller是一个统一入口，一切发到我们Application的请求都会由其处理，然后根据接收到的Request不同，按照配置的Route规则加载对应的Controller的Action。
处理请求之后，生成响应对象并send()到客户端。</p>
<p>根据环境的不同，Symfony自带有两个Front Controller：</p>
<ul>
<li><code>web/app.php</code>    #生产环境</li>
<li><code>web/app_dev.php</code>  #开发环境</li>
</ul>
<p>之所以没有测试环境对应的前端控制器，是因为测试环境可以通常只在单元测试时使用。</p>
<p>当然console工具也提供了能在任意环境下运行的Front Controller。</p>
<p>Symfony中的Front Controller非常简单，遵循的逻辑可以概括为&quot;<code>处理请求，发送响应</code>&quot;,这也是整个Symfony框架对Request-Response模型的实现：</p>
<pre><code class="language-PHP">// web/app.php

require_once __DIR__.'/../app/bootstrap.php';
require_once __DIR__.'/../app/AppKernel.php';
use Symfony\Component\HttpFoundation\Request;

//初始化一个prod环境、非debug模式运行的AppKernel
$kernel = new AppKernel('prod', false);

$kernel-&gt;handle(Request::createFromGlobals())    //处理请求
        -&gt;send();    //发送响应
</code></pre>
<p>至此，针对Request-Response模型的处理流程已经总体规划完毕了。</p>
<p>对于一个Symfony项目<code>myproj</code>,为了方便起见，假设整个文件夹都位于<code>/var/www/</code>下,当我们在浏览器中访问：</p>
<p><code>localhost/myproj/web/some_route</code></p>
<p>实际上是在调用Front Controller来执行与some_route对应的代码。事实上，上面这个URL在默认情况下等效于：</p>
<p><code>localhost/myproj/web/app.php/some_route</code></p>
<p>当然，在开发模式下，可以访问：</p>
<p><code>localhost/myproj/web/app_dev.php/some_route</code></p>
<p>激活debug工具并能自动重建缓存。</p>
<p>正是由于Front Controller已经实现了Request-Response这样的基本流程，在Symfony中为一个基本组件（Bundle）添加页面只需要要遵循两步：</p>
<ol>
<li>创建Controller    #定义如何根据Response生成Response对象</li>
<li>配置Route    #配置URL和Controller的映射关系</li>
</ol>
<p>当然，为了避免组织混乱、保持结构清晰，实际中，Route、Controller等等都是以Bundle来设计的。</p>
<h2>Bundle</h2>
<p>Bundle从PHP的角度而言，可以视作一个命名空间。一旦一个PHP命名空间添加了Bundle Class，就成为Bundle。这个Bundle Class的命名必须遵循以下规则：</p>
<ul>
<li>只使用字母和下划线</li>
<li>使用CamelCased命名风格</li>
<li>使用descriptive和short的名字</li>
<li>以vender名为prefix</li>
<li>以&quot;Bundle&quot;为suffix</li>
</ul>
<p>Bundle Class的getClass()方法返回这个类名。</p>
<p>Bundle是Symfony的基本组件。Bundle存放了与某个特性相关的一切文件(比如PHP类、配置、甚至是css文件和JavaScript文件)的目录。
事实上，Symfony的Bundle和PHPCMS里的module作用相当，类似于模块、插件。但是相较于PHPCMS之类其他的框架，Symfony的Bundle具有更好的抽象和实现。</p>
<p>一个Bundle，通常位于src/VenderOfBundle/BundleName之下,其中的目录结构多为：</p>
<pre><code>Vender/
    YourBundle/
        VenderYourBundle.php
        Controller/               #控制器
            Spec1Controller.php
            Spec2Controller.php
        DependencyInjection/      #DI
        Resources/
            config/
            views/
        Tests/                    #测试
</code></pre>
<p>想要添加一个Bundle，应该先创建以上目录，然后修改app/Kernel.php文件，为registerBundles()方法添加一个该Bundle的实例：</p>
<pre><code class="language-PHP">// app/AppKernel.php

public function registerBundles(){

    $bundles=array(
        //...
        new Vender\YourBundle\VenderYourBundle();
    );

    //...

    return $bundles;
}
</code></pre>
<p>以上两步可以归纳为：</p>
<ol>
<li>创建Bundle</li>
<li>注册Bundle</li>
</ol>
<p>当然，添加Bundle的这些步骤可以用一个命令代替：</p>
<pre><code class="language-bash">    php app/console generate:bundle --namespace=Vender/YourBundle --format=yml
</code></pre>
<h2>Route</h2>
<p>Route是指从Request（如URL路径,HTTP Method)到控制器(具体到Action)的映射。所以， 一条路由规则有两个要素组成：</p>
<ol>
<li>URL Path</li>
<li>与URL Path匹配的Controller</li>
</ol>
<p>我们还可以为这条路由规则起一个独一无二的名字，这样我们就能用于生成URL了。</p>
<p>路由层的作用就是把输入进来的URL转换为要执行的Controller。</p>
<p>Symfony会从一个单独的路由配置文件中加载所有的路由规则。这个路由配置文件通常是</p>
<p><code>app/config/routing.yml</code></p>
<p>,当然，Symfony支持高度定制，我们可以把默认的路由文件配置成其他任意其他文件(包括XML和PHP文件)。如：</p>
<pre><code class="language-YAML"># app/config/config.yml
framework
    # ....
    router: { resource: &quot;%kernel.root_dir%/config/routing.yml&quot;}
</code></pre>
<p>当然，从URL到控制器动作，参数匹配是必不可少的。Symfony的路由系统支持:</p>
<ul>
<li>URL匹配         #通过@Route()设置
<ul>
<li>必选参赛    #通过占位符来设置</li>
<li>可选参数    #通过占位符和设置defaults来设置</li>
<li>正则匹配    #通过requirements设置</li>
</ul>
</li>
<li>HTTP Method匹配 #通过@Method()</li>
</ul>
<pre><code class="language-PHP">/**
 *@Route(&quot;/blog/{page}&quot;,defaults={&quot;page&quot;: 1},requirements={
 *    &quot;page&quot;: &quot;\d+&quot;
 *})
 *@Method(&quot;GET&quot;)
 */
public function indexAction($page){
    //...
}
</code></pre>
<p>当然，威力更巨大的是condition属性，支持无限可能的定制。</p>
<pre><code class="language-YAML">contact:
    path: /contact
    defaults: { _controller: AcmeDemoBundle:Main:contact}
    condition: &quot;context.getMethod() in ['GET','HEAD'] and request.headers.get('User-Agent') matches '/firefox/i' &quot;
</code></pre>
<p>这个配置会被转换为以下的PHP代码：</p>
<pre><code class="language-PHP">if(rtrim($pathinfo,&quot;/contact&quot;)===''&amp;&amp;
    (
        in_array($context-&gt;getMethod(),array(0=&gt;'GET',1=&gt;'HEAD')) &amp;&amp;
        preg_match('/firefox/i',$request-&gt;headers-&gt;get(&quot;User-Agent&quot;))
    )
    
){
    //....
}
</code></pre>
<h3>一个Bundle中的Route</h3>
<p>要让合适的Controller和Action发生调用，必须建立url与之的映射。</p>
<pre><code class="language-PHP">#src/Vender/YourBundle/Resources/config/routing.yml

specController:
    path: /specController/{limit}
    defaults: { _controller: VenderYourBundle:specController:yourAction}

</code></pre>
<h3>app级Route</h3>
<p>尽管所有的路由配置规则是从一个单独的文件中读取的，大家在实际中还是会通过<code>resource</code>导入其他路由规则。比如，使用Annotation格式的路由配置应设置:</p>
<pre><code class="language-YAML">app: 
    resource: &quot;@AppBundle/Controller&quot;
    type: annotation  #使用Annotation reader来读取resource变量
</code></pre>
<p>如果我们手工添加了一个Bundle，我们可以把它自身包含的Route规则导入app level的配置中，即应该在app/config/routing.yml中添加配置：</p>
<pre><code class="language-YAML"># app/config/routing.yml

vender_yourbundlename
    resource: &quot;@VenderYourBundle/Resources/config/routing.yml&quot;
    prefix: /
    
</code></pre>
<p>当然，如果是用<code>php app/console generate:bundle</code>命令生成的bundle，那么这一步已经由Symfony替我们做好了。</p>
<h3>双向映射</h3>
<p>Route提供了bidirectional System:</p>
<ol>
<li>match($URL)      #返回匹配到的控制器及参数构成的数组</li>
<li>generate($RouteName,$paramsArray)       #生成URL</li>
</ol>
<h2>Controller</h2>
<p>我们知道，每一个Route规则都有一个<code>_controller</code>对象，我们当然可以用</p>
<p><code>完全限定名的ClassName::ActionName</code></p>
<p>的形式来引用一个Controller，比如：</p>
<p><code>AppBundle\Controller\BlogController::ShowAction </code>。</p>
<p>但实际上这样的表达是有冗余信息的，最起码还要指出BlogController位于的命名空间Controller是没必要的，所以Symfony还支持对Controller的逻辑命名, 一条指定Controller的Action的逻辑命名通常遵循这样的约定：</p>
<p><code>BundleName:ControllerName:ActionName</code></p>
<p>通常这样的逻辑名称会被映射为</p>
<p><code>path/to/BundleName/Controller/ControllerName.php</code>文件中的<code>ActionName</code>方法</p>
<p>比如：</p>
<p><code>AcmeDemoBundle:Random:Index</code></p>
<p>这个控制器通常会会映射为：</p>
<p><code>Acme\DemoBundle\Controller\RandomController</code>类中的<code>indexAction</code>方法。</p>
<p>另外值得注意的是，Symfony中Controller的Action 与CodeIgniter之类的框架并完全一样:</p>
<ol>
<li>CodeIgniter中的控制器直接输出响应，而Symfony中则是必须返回Response对象;</li>
<li>Symfony支持从Route和Request定制Action方法的参数。而且对于Action方法声明，参数顺序并不重要。</li>
</ol>
<pre><code class="language-PHP">
use Symfony\Component\HttpFoundation\Request;

/**
 * @Route(&quot;/hello/{firstName}/{lastName}&quot;,name=&quot;hello&quot;)
 */
public function indexAction($lastName,$firstName,Request $request){

    //$firstName和$lastName等参赛顺序并不重要
    //可以直接使用$request
    $page=$request-&gt;query-&gt;get(&quot;page&quot;,1);
}
</code></pre>
<p>此外，Symfony\Bundle\FrameworkBundle\Controller\Controller提供了一系列helper方法。</p>
<ul>
<li>Redirecting
<ul>
<li>generateUrl($route)</li>
<li>redirect($absUrl)</li>
<li>redirectToRoute($route)   # new RedirectResponse($this-&gt;generateUrl($route))</li>
</ul>
</li>
<li>Rendering Templates
<ul>
<li>render($pathOrLogicalTemplateName,$array)    #render a template and return a Response object</li>
</ul>
</li>
<li>Accessing other Services
<ul>
<li>get('templating')</li>
<li>get('router')</li>
<li>get('mailer')</li>
</ul>
</li>
<li>Exception</li>
<li>FlashMessage
<ul>
<li>addFlash()</li>
</ul>
</li>
<li>Forwarding</li>
</ul>
<h2>Symfony目录结构</h2>
<p>Symfony的基本架构便如上文所述，十分清晰。与架构相对应，Symfony的目录结构也是非常清晰的。默认的结构组织形式为：</p>
<pre><code>app/    #application config ,cache,
src/    #project源码
vender/ #第三方依赖,由composer独占管理权
web/    #包含了公共访问文件,比如Front Controller和静态文件
</code></pre>
<p><code>web/</code>目录类似于网站的根目录，一切的公开访问都是从这里开始的，其下的Front Controller文件如<code>app.php</code>和<code>app_dev.php</code>是整个网站的入口管理文件。其他一些静态资源也会以一定的结构组织在这个目录下。</p>
<p><code>app/</code>目录是Application级的一些文件存放地。如<code>app/console</code>、<code>app/config</code>，<code>app/cache</code></p>
<p><code>src/</code>目录是针对网站各个功能的源码存放地，其中文件一般以各个Vender提供的Bundle分别组织。</p>
<p>尽管拥有如此清晰的文件结构，Symfony也支持任意定制目录结构。</p>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/PHP/Symfony/Symfony-Translation.html">
                    Symfony Translation
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        PHP
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Symfony
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#Symfony">
                    <span class="tag is-info">
                      Symfony
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2015-04-10
                </p>
              </div>
              <div class="content article-body">
                <p>翻译的过程可以理解为从消息<code>message</code>到译文<code>translation</code>的过程。Symfony/Translation这个组件的工作流程大致可以分为三步：</p>
<ol start="0">
<li>创建翻译器</li>
<li>为翻译器添加资源: <code>source</code>到<code>target</code>的消息映射关系</li>
<li>根据<code>domain</code>、<code>locale</code>及对应的<code>message</code>给出译文<code>translation</code>。</li>
</ol>
<h2>创建翻译器</h2>
<p>翻译器的创建非常简单，仅需提供一个默认的<code>locale</code>值：</p>
<pre><code class="language-PHP">use Symfony\Component\Translation\Translator;

$translator=new Translator('fr_FR');    #默认locale='fr_FR'
</code></pre>
<p>所谓<code>locale</code>，大致可以当成一个指代用户语言和国家/地区的字符串。推荐用
<code>ISO639-1LanguageCode_ISO3166-1Alpha-2CountryCode&gt;</code>
这样的格式来表示。比如：<code>fr_FR</code>。</p>
<h2>翻译资源的加载</h2>
<h3>Translation Resources</h3>
<p>Translation Resources定义了一组从源(<code>source</code>)到目标<code>target</code>的消息映射关系。这种映射关系可以用不同的形式来表达，比如XML：</p>
<pre><code class="language-XML">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;xliff version=&quot;1.2&quot; xmlns=&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt;
    &lt;file source-language=&quot;en&quot; datatype=&quot;plaintext&quot; original=&quot;file.ext&quot;&gt;
        &lt;body&gt;
            &lt;trans-unit id=&quot;1&quot;&gt;
                &lt;source&gt;Symfony is great&lt;/source&gt;
                &lt;target&gt;J'aime Symfony&lt;/target&gt;
            &lt;/trans-unit&gt;
            &lt;trans-unit id=&quot;2&quot;&gt;
                &lt;source&gt;symfony.great&lt;/source&gt;
                &lt;target&gt;J'aime Symfony&lt;/target&gt;
            &lt;/trans-unit&gt;
        &lt;/body&gt;
    &lt;/file&gt;
&lt;/xliff&gt;
</code></pre>
<p>又如YAML：</p>
<pre><code class="language-YAML">Symfony is great: J'aime Symfony
symfony.great:    J'aime Symfony
</code></pre>
<p>再如PHP的Array：</p>
<pre><code class="language-PHP">return array(
    'Symfony is great' =&gt; 'J\'aime Symfony',
    'symfony.great'    =&gt; 'J\'aime Symfony',
);
</code></pre>
<p>当然，还支持JSON等其他形式——只要他们表达了这种映射关系，即可以被当做一个Translation Resources。</p>
<h4>消息占位符</h4>
<p>上面例子中的<code>%...%</code>这种表达（如<code>%name%</code>）是一种消息占位符。这种占位符机制可以动态映射一些message到translation。</p>
<h4>复数形式</h4>
<p>借助占位符和管道符可以很好的表达复数形式。</p>
<pre><code>'There is one apple|There are %count% apples'
</code></pre>
<p>有时候我们需要借助于区间获取更多的控制：</p>
<p>'{0} There are no apples|{1} There is one apple|]1,19] There are %count% apples|[20,Inf[ There are many apples'</p>
<p>区间表达遵循<code>ISO 311-11</code>的记法规则,可以是两端(可以借助于-Inf和+Inf表达正负无穷)之间的数字，还可以是有限个数字的集合如:</p>
<pre><code>{1,2,3}
</code></pre>
<h3>资源加载的过程：</h3>
<ol>
<li>设置资源加载器</li>
<li>利用资源加载器加载资源</li>
</ol>
<p>Symfony支持不同的资源加载方法，:</p>
<ul>
<li>ArrayLoader</li>
<li>CsvFileLoader</li>
<li>IcuDatFileLoader</li>
<li>PhpFileLoader</li>
<li>XliffFileLoader</li>
<li>JsonFileLoader</li>
<li>YamlFileLoader</li>
<li>...</li>
</ul>
<p>所有的加载器都实现了LoaderInterface接口，其load()方法返回一个catalog以用作将来的翻译。</p>
<p>我们还可以设置定义自己的资源类型，比如采用</p>
<pre><code>(source)(target)
</code></pre>
<p>这种形式，只要我们为之定义加载器：</p>
<pre><code class="language-PHP">use Symfony\Component\Translation\MessageCatalogue;
use Symfony\Component\Translation\Loader\LoaderInterface;

class MyFormatLoader implements LoaderInterface
{
    public function load($resource, $locale, $domain = 'messages')
    {
        $messages = array();
        $lines = file($resource);

        foreach ($lines as $line) {
            if (preg_match('/\(([^\)]+)\)\(([^\)]+)\)/', $line, $matches)) {
                $messages[$matches[1]] = $matches[2];
            }
        }

        $catalogue = new MessageCatalogue($locale);
        $catalogue-&gt;add($messages, $domain);

        return $catalogue;
    }

}
</code></pre>
<p>加载Translation Resources的示例代码为:</p>
<pre><code class="language-PHP">$translator-&gt;addLoader('xlf',new XliffFileLoader());
$translator-&gt;addResource('xlf','message.fr.xlf','fr_FR');    # 默认domain为'messages'
$translator-&gt;addResource('xlf','message.fr.xlf','fr_FR','admin');
$translator-&gt;addResource('xlf','navigation.fr.xlf','fr_FR','navigation');

</code></pre>
<h2>翻译过程</h2>
<p>翻译实际上是分成两步完成的：</p>
<ol>
<li>从translation resources中加载翻译好的message一览表(catalog)</li>
<li>从catalog中定位message并返回对应的翻译。如果定位不到，则返回原始message。</li>
</ol>
<p>可以通过调用<code>ITranslator</code>接口提供两个关键的方法<code>trans()</code>或者<code>transChoice()</code>来执行这个过程。</p>
<pre><code class="language-PHP">public function trans($id, array $parameters = array(), $domain = null, $locale = null);
public function transChoice($id, $number, array $parameters = array(), $domain = null, $locale = null);
</code></pre>
<p>如果不提供locale，trans()方法在默认情况下会使用fallback的locale，</p>
<pre><code class="language-PHP">$translator-&gt;trans('hello, %name%',array('name'=&gt;'Chicago'),'admin','fr_FR');

$translator-&gt;transChoice(
    '{0} There are no apples|{1} There is one apple|]1,Inf[ There are %count% apples',
    10,
    array('%count%' =&gt; 10),
    'messages',
    'fr_FR'
);

</code></pre>
<h2>例子</h2>
<p>来自官方文档的<a href="http://symfony.com/doc/current/components/translation/usage.html">一个例子</a>：</p>
<pre><code class="language-PHP">use Symfony\Component\Translation\Translator;
use Symfony\Component\Translation\Loader\ArrayLoader;

$translator = new Translator('fr_FR');
$translator-&gt;addLoader('array', new ArrayLoader());
$translator-&gt;addResource('array', array(
    'Symfony is great!' =&gt; 'J\'aime Symfony!',
), 'fr_FR');

var_dump($translator-&gt;trans('Symfony is great!'))
</code></pre>
<h2>在Symfony框架中使用翻译组件</h2>
<p>Symfony框架集成了翻译功能，</p>
<p>翻译资源的位置在以下位置寻找（按照以下优先级）：</p>
<ul>
<li><code>app/Resources/translations</code></li>
<li><code>app/Resources/&lt;bundle name&gt;/translations</code></li>
<li><code>Path/to/SomeBundle/Resources/translations/</code></li>
</ul>
<p>翻译资源文件的命名必须遵循这样的规则：</p>
<p><code>domain.locale.loader</code></p>
<p>domain是可选项；Symfony自带的loader包括xlf、php、yml等。例如：<code>FOSUserBundle.zh_CN.yml</code>、<code>validators.en.yml</code>等。</p>
<p>设想用户的<code>locale</code>是<code>fr_FR</code>，当要翻译“Symfony is great” 时，会按照以下顺序寻找：</p>
<ol>
<li>尝试寻找<code>fr_FR</code>对应的翻译资源,例如messages.fr_FR.xlf;</li>
<li>如果第一步没找到，则会寻找<code>fr</code>对应的翻译资源,例如messages.fr.xlf;</li>
<li>如果还没找到，则使用<code>fallbacks</code>对应的资源。</li>
</ol>
<h2>在Symfony框架集成的Twig模板中使用翻译组件</h2>
<p>绝大部分时候，我们都是在在Symfony框架的Twig中使用翻译组件。</p>
<p>Twig提供了tags和filters支持翻译功能：</p>
<p>tags：</p>
<pre><code class="language-Twig">{% trans with {'%name%': 'Fabien'} f
    rom &quot;app&quot; %}Hello %name%
{% endtrans %}
{% trans with {'%name%': 'Fabien'} from &quot;app&quot; into &quot;fr&quot; %}
    Hello %name%
{% endtrans %}
{% transchoice count with {'%name%': 'Fabien'} from &quot;app&quot; %}
    {0} %name%, there are no apples|{1} %name%, there is one apple|]1,Inf[ %name%, there are %count% apples
{% endtranschoice %}
</code></pre>
<p>filters:</p>
<pre><code class="language-Twig">{{ message|trans }}
{{ message|transchoice(5) }}
{{ message|trans({'%name%': 'Fabien'}, &quot;app&quot;) }}
{{ message|transchoice(5, {'%name%': 'Fabien'}, 'app') }}
</code></pre>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <div class="container">
      <div class="container has-text-centered">
        <a href="posts/page26.html">
          Previous
        </a>
        28 of 32
        <a href="posts/page28.html">
          Next
        </a>
      </div>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
       // 处理形如 <code>$E=mc^2$</code> 形式的公式
 var inlineMathNodes=document.querySelectorAll('code');
 var re=/^\$(.*)\$$/;
 for(var j=0;j<inlineMathNodes.length;j++){
   var result=re.exec(inlineMathNodes.item(j).innerText);
   if(result!==null){
	 katex.render(result[1], inlineMathNodes.item(j));
   }
 }
 function removeNode(node){
   if(node.remove){
	 node.remove();
   }else{
	 return first.parentNode.removeChild(node);
   }
 };

 // 查找所有 pre code.language-math 节点 以备筛出数据公式
 var nodes=document.querySelectorAll("pre code.language-math");
 for(var i=0;i<nodes.length;i++){
   var node=nodes.item(i);
   // 魔术标记所在行 
   try{
	 var lines = node.innerText.split('\n');
	 if((!!lines) && lines.length > 0)
	 {
	   var first = lines[0];
	   if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
		 var views = "";
		 // 逐行渲染
		 for(var k=1; k <lines.length; k++){
			 var f=lines[k];
			 views += katex.renderToString(f);
		 }
		 // 消除父级嵌套 
		 try{
		   node.innerHTML=views;
		 }catch(e){
		   // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
		   console.log('IE9 sucks',e);
		   $(tr).html(node.innerHTML);
		 }
	   }
	 }
   }
   catch(err){
	 console.log(err)
   }
 }
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>