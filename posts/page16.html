<!DOCTYPE html><html>
  <head>
    <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie/"/>
    <script>
      document.addEventListener('DOMContentLoaded', () => {

	// Get all "navbar-burger" elements
	const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);
  
	// Check if there are any navbar burgers
	if ($navbarBurgers.length > 0) {
  
	  // Add a click event on each of them
	  $navbarBurgers.forEach( el => {
		el.addEventListener('click', () => {
  
		  // Get the target from the "data-target" attribute
		  const target = el.dataset.target;
		  const $target = document.getElementById(target);
  
		  // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
		  el.classList.toggle('is-active');
		  $target.classList.toggle('is-active');
  
		});
	  });
	}
  });
    </script>
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item is-active" href="">
            Home
          </a>
          <a class="navbar-item" href="tags.html">
            Tags
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/Compiler/自制编程语言/crowbar源码阅读笔记(5).html">
                    crowbar源码阅读笔记(5):表达式求值
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        大道
                      </a>
                    </li>
                    <li>
                      <a href="">
                        编译原理
                      </a>
                    </li>
                    <li>
                      <a href="">
                        自制编程语言
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#编译原理">
                    <span class="tag is-info">
                      编译原理
                    </span>
                  </a>
                  <a href="tags.html#自制编程语言">
                    <span class="tag is-info">
                      自制编程语言
                    </span>
                  </a>
                  <a href="tags.html#crowbar">
                    <span class="tag is-info">
                      crowbar
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-08-20
                </p>
              </div>
              <div class="content article-body">
                <p>这是《自制编程语言》一书中的脚本语言<code>crowbar</code>的源码阅读笔记(5):表达式求值。表达式求值的实现代码主要存放于文件<code>eval.c</code>中。</p>
<h2>表达式求值算法的总体框架</h2>
<p>根据表达式的类型的不同，执行不同的求值算法，然后返回一个<code>CRB_Value</code>类型。</p>
<pre><code class="language-c">static CRB_Value eval_expression(CRB_Interpreter *inter, LocalEnvironment *env, Expression *expr)
{
    CRB_Value   v;
    switch (expr-&gt;type) {
    case BOOLEAN_EXPRESSION:
        v = eval_boolean_expression(expr-&gt;u.boolean_value);
        break;
    case INT_EXPRESSION:
        v = eval_int_expression(expr-&gt;u.int_value);
        break;
    case DOUBLE_EXPRESSION:
        v = eval_double_expression(expr-&gt;u.double_value);
        break;
    case STRING_EXPRESSION:
        v = eval_string_expression(inter, expr-&gt;u.string_value);
        break;
    case IDENTIFIER_EXPRESSION:
        v = eval_identifier_expression(inter, env, expr);
        break;
    case ASSIGN_EXPRESSION:
        v = eval_assign_expression(inter, env, expr-&gt;u.assign_expression.variable, expr-&gt;u.assign_expression.operand);
        break;
    case ADD_EXPRESSION:        /* FALLTHRU */
    case SUB_EXPRESSION:        /* FALLTHRU */
    case MUL_EXPRESSION:        /* FALLTHRU */
    case DIV_EXPRESSION:        /* FALLTHRU */
    case MOD_EXPRESSION:        /* FALLTHRU */
    case EQ_EXPRESSION: /* FALLTHRU */
    case NE_EXPRESSION: /* FALLTHRU */
    case GT_EXPRESSION: /* FALLTHRU */
    case GE_EXPRESSION: /* FALLTHRU */
    case LT_EXPRESSION: /* FALLTHRU */
    case LE_EXPRESSION:
        v = crb_eval_binary_expression(inter, env, expr-&gt;type, expr-&gt;u.binary_expression.left, expr-&gt;u.binary_expression.right);
        break;
    case LOGICAL_AND_EXPRESSION:/* FALLTHRU */
    case LOGICAL_OR_EXPRESSION:
        v = eval_logical_and_or_expression(inter, env, expr-&gt;type, expr-&gt;u.binary_expression.left, expr-&gt;u.binary_expression.right);
        break;
    case MINUS_EXPRESSION:
        v = crb_eval_minus_expression(inter, env, expr-&gt;u.minus_expression);
        break;
    case FUNCTION_CALL_EXPRESSION:
        v = eval_function_call_expression(inter, env, expr);
        break;
    case NULL_EXPRESSION:
        v = eval_null_expression();
        break;
    case EXPRESSION_TYPE_COUNT_PLUS_1:  /* FALLTHRU */
    default:
        DBG_panic((&quot;bad case. type..%d\n&quot;, expr-&gt;type));
    }
    return v;
}
</code></pre>
<p>以整型表达式为例，创建一个<code>CRB_Value</code>变量，然后设置其<code>type</code>，填充<code>u</code>成员的<code>int_value</code>字段为指定值：</p>
<!-- more -->
<pre><code class="language-c">static CRB_Value eval_int_expression(int int_value)
{
    CRB_Value   v;

    v.type = CRB_INT_VALUE;
    v.u.int_value = int_value;

    return v;
}
</code></pre>
<p>布尔型表达式求值也是类似的，创建一个<code>CRB_Value</code>变量，然后设置其<code>type</code>，填充<code>u</code>成员的<code>boolean_value</code>字段为指定<code>CRB_Boolean</code>值：</p>
<pre><code class="language-c">static CRB_Value eval_boolean_expression(CRB_Boolean boolean_value)
{
    CRB_Value   v;
    v.type = CRB_BOOLEAN_VALUE;
    v.u.boolean_value = boolean_value;
    return v;
}
</code></pre>
<p>类似的还有浮点型表达式求值、字符串型表达式求值。</p>
<h2>标识符表达式求值</h2>
<pre><code class="language-c">static CRB_Value eval_identifier_expression(CRB_Interpreter *inter, LocalEnvironment *env, Expression *expr)
{
    CRB_Value   v;
    Variable    *vp;

    vp = crb_search_local_variable(env, expr-&gt;u.identifier);
    if (vp != NULL) {
        v = vp-&gt;value;
    } else {
        vp = search_global_variable_from_env(inter, env, expr-&gt;u.identifier);
        if (vp != NULL) {
            v = vp-&gt;value;
        } else {
            crb_runtime_error(expr-&gt;line_number, VARIABLE_NOT_FOUND_ERR,
                              STRING_MESSAGE_ARGUMENT,
                              &quot;name&quot;, expr-&gt;u.identifier,
                              MESSAGE_ARGUMENT_END);
        }
    }
    refer_if_string(&amp;v);

    return v;
}
</code></pre>
<h2>赋值表达式求值</h2>
<p>赋值表达式求值非常简单：</p>
<ul>
<li>先求出等号右部的表达式的值</li>
<li>尝试搜寻指定标识符对应的变量，找不到就在指定环境中创建一个变量。</li>
<li>然后将等号左边的变量值修改为计算出来的值。</li>
</ul>
<pre><code class="language-c">static CRB_Value eval_assign_expression(CRB_Interpreter *inter, LocalEnvironment *env, char *identifier, Expression *expression)
{
    CRB_Value   v;
    Variable    *left;

    v = eval_expression(inter, env, expression);

    left = crb_search_local_variable(env, identifier);
    if (left == NULL) {
        left = search_global_variable_from_env(inter, env, identifier);
    }
    if (left != NULL) {
        release_if_string(&amp;left-&gt;value);
        left-&gt;value = v;
        refer_if_string(&amp;v);
    } else {
        if (env != NULL) {
            crb_add_local_variable(env, identifier, &amp;v);
        } else {
            CRB_add_global_variable(inter, identifier, &amp;v);
        }
        refer_if_string(&amp;v);
    }

    return v;
}
</code></pre>
<h2><code>BinaryExpression</code> 求值</h2>
<p>根据参与运算的<code>left</code>和<code>right</code>类型，又可以分为布尔型、整型、浮点型、字符串型等</p>
<h3>布尔型 <code>BinaryExpression</code></h3>
<p>它的求值方法非常简单，即根据左右表达式是否相等来返回结果：</p>
<pre><code class="language-c">static CRB_Boolean eval_binary_boolean(CRB_Interpreter *inter, ExpressionType operator, CRB_Boolean left, CRB_Boolean right, int line_number)
{
    CRB_Boolean result;

    if (operator == EQ_EXPRESSION) {
        result = left == right;
    } else if (operator == NE_EXPRESSION) {
        result = left != right;
    } else {
        char *op_str = crb_get_operator_string(operator);
        crb_runtime_error(line_number, NOT_BOOLEAN_OPERATOR_ERR, STRING_MESSAGE_ARGUMENT, &quot;operator&quot;, op_str, MESSAGE_ARGUMENT_END);
    }

    return result;
}
</code></pre>
<h3>逻辑<code>BinaryExpression</code>表达式求值</h3>
<p>逻辑表达式总体来说采用的是递归法求解：</p>
<ul>
<li>先递归求解出<code>left_value</code>，根据运算符的不同，判断是否触发短路，是则不再进一步求解</li>
<li>否则，再递归求解出<code>right_value</code></li>
<li>然后根据<code>left_value</code>和<code>right_value</code>求解出最终的值。</li>
</ul>
<pre><code class="language-c">static CRB_Value eval_logical_and_or_expression(CRB_Interpreter *inter, LocalEnvironment *env, ExpressionType operator, Expression *left, Expression *right)
{
    CRB_Value   left_val;
    CRB_Value   right_val;
    CRB_Value   result;
    result.type = CRB_BOOLEAN_VALUE;

    /* left_value 求解 */
    left_val = eval_expression(inter, env, left);

    if (left_val.type != CRB_BOOLEAN_VALUE) { crb_runtime_error(left-&gt;line_number, NOT_BOOLEAN_TYPE_ERR, MESSAGE_ARGUMENT_END); }

    /* 测试是否触发短路逻辑 */
    if (operator == LOGICAL_AND_EXPRESSION) {
        if (!left_val.u.boolean_value) { result.u.boolean_value = CRB_FALSE; return result; }
    } 
    else if (operator == LOGICAL_OR_EXPRESSION) {
        if (left_val.u.boolean_value) { result.u.boolean_value = CRB_TRUE; return result; }
    }
    else {
        DBG_panic((&quot;bad operator..%d\n&quot;, operator));
    }

    /* right_value 求解 */
    right_val = eval_expression(inter, env, right);
    if (right_val.type != CRB_BOOLEAN_VALUE) {
        crb_runtime_error(right-&gt;line_number, NOT_BOOLEAN_TYPE_ERR, MESSAGE_ARGUMENT_END); 
    }

    result.u.boolean_value = right_val.u.boolean_value;
    return result;
}
</code></pre>
<h3>整型 <code>BinaryExpression</code> 求值</h3>
<p>整型表达式的左右表达式均为整型。其求值结果可能是整型，也可能是布尔型。比如：</p>
<ul>
<li><code>3+4</code>这个表达式的结果为整型</li>
<li><code>3&gt;4</code>这个表达式的结果为布尔假值。</li>
</ul>
<p>求值的时候，需要针对每种情况区别对待：</p>
<ul>
<li>当运算符为 <strong>数学运算符</strong>，比如<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>，求值结果整型</li>
<li>当运算符为 <strong>比较运算符</strong>，比如<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>==</code>、<code>!=</code>，求值结果为布尔值。</li>
</ul>
<pre><code class="language-c">static void eval_binary_int(CRB_Interpreter *inter, ExpressionType operator, int left, int right, CRB_Value *result, int line_number) 
{
    if (dkc_is_math_operator(operator)) { result-&gt;type = CRB_INT_VALUE; } 
    else if (dkc_is_compare_operator(operator)) { result-&gt;type = CRB_BOOLEAN_VALUE; } 
    else { DBG_panic((&quot;operator..%d\n&quot;, operator)); }

    switch (operator) {
    case BOOLEAN_EXPRESSION:    /* FALLTHRU */
    case INT_EXPRESSION:        /* FALLTHRU */
    case DOUBLE_EXPRESSION:     /* FALLTHRU */
    case STRING_EXPRESSION:     /* FALLTHRU */
    case IDENTIFIER_EXPRESSION: /* FALLTHRU */
    case ASSIGN_EXPRESSION:
        DBG_panic((&quot;bad case...%d&quot;, operator));
        break;
    case ADD_EXPRESSION:
        result-&gt;u.int_value = left + right;
        break;
    case SUB_EXPRESSION:
        result-&gt;u.int_value = left - right;
        break;
    case MUL_EXPRESSION:
        result-&gt;u.int_value = left * right;
        break;
    case DIV_EXPRESSION:
        result-&gt;u.int_value = left / right;
        break;
    case MOD_EXPRESSION:
        result-&gt;u.int_value = left % right;
        break;
    case LOGICAL_AND_EXPRESSION:        /* FALLTHRU */
    case LOGICAL_OR_EXPRESSION:
        DBG_panic((&quot;bad case...%d&quot;, operator));
        break;
    case EQ_EXPRESSION:
        result-&gt;u.boolean_value = left == right;
        break;
    case NE_EXPRESSION:
        result-&gt;u.boolean_value = left != right;
        break;
    case GT_EXPRESSION:
        result-&gt;u.boolean_value = left &gt; right;
        break;
    case GE_EXPRESSION:
        result-&gt;u.boolean_value = left &gt;= right;
        break;
    case LT_EXPRESSION:
        result-&gt;u.boolean_value = left &lt; right;
        break;
    case LE_EXPRESSION:
        result-&gt;u.boolean_value = left &lt;= right;
        break;
    case MINUS_EXPRESSION:              /* FALLTHRU */
    case FUNCTION_CALL_EXPRESSION:      /* FALLTHRU */
    case NULL_EXPRESSION:               /* FALLTHRU */
    case EXPRESSION_TYPE_COUNT_PLUS_1:  /* FALLTHRU */
    default:
        DBG_panic((&quot;bad case...%d&quot;, operator));
    }
}
</code></pre>
<h3>浮点型 <code>BinaryExpression</code> 求值</h3>
<p>浮点型 <code>BinaryExpression</code> 与整型 <code>BinaryExpression</code> 求值过程类似，根据运算符的类型，要按浮点型和布尔型区别对待。</p>
<pre><code class="language-c">static void eval_binary_double(CRB_Interpreter *inter, ExpressionType operator, double left, double right, CRB_Value *result, int line_number) 
{
    if (dkc_is_math_operator(operator)) { result-&gt;type = CRB_DOUBLE_VALUE; } 
    else if (dkc_is_compare_operator(operator)) { result-&gt;type = CRB_BOOLEAN_VALUE; }
    else { DBG_panic((&quot;operator..%d\n&quot;, operator)); }

    switch (operator) {
    case BOOLEAN_EXPRESSION:    /* FALLTHRU */
    case INT_EXPRESSION:        /* FALLTHRU */
    case DOUBLE_EXPRESSION:     /* FALLTHRU */
    case STRING_EXPRESSION:     /* FALLTHRU */
    case IDENTIFIER_EXPRESSION: /* FALLTHRU */
    case ASSIGN_EXPRESSION:
        DBG_panic((&quot;bad case...%d&quot;, operator));
        break;
    case ADD_EXPRESSION:
        result-&gt;u.double_value = left + right;
        break;
    case SUB_EXPRESSION:
        result-&gt;u.double_value = left - right;
        break;
    case MUL_EXPRESSION:
        result-&gt;u.double_value = left * right;
        break;
    case DIV_EXPRESSION:
        result-&gt;u.double_value = left / right;
        break;
    case MOD_EXPRESSION:
        result-&gt;u.double_value = fmod(left, right);
        break;
    case LOGICAL_AND_EXPRESSION:        /* FALLTHRU */
    case LOGICAL_OR_EXPRESSION:
        DBG_panic((&quot;bad case...%d&quot;, operator));
        break;
    case EQ_EXPRESSION:
        result-&gt;u.int_value = left == right;
        break;
    case NE_EXPRESSION:
        result-&gt;u.int_value = left != right;
        break;
    case GT_EXPRESSION:
        result-&gt;u.int_value = left &gt; right;
        break;
    case GE_EXPRESSION:
        result-&gt;u.int_value = left &gt;= right;
        break;
    case LT_EXPRESSION:
        result-&gt;u.int_value = left &lt; right;
        break;
    case LE_EXPRESSION:
        result-&gt;u.int_value = left &lt;= right;
        break;
    case MINUS_EXPRESSION:              /* FALLTHRU */
    case FUNCTION_CALL_EXPRESSION:      /* FALLTHRU */
    case NULL_EXPRESSION:               /* FALLTHRU */
    case EXPRESSION_TYPE_COUNT_PLUS_1:  /* FALLTHRU */
    default:
        DBG_panic((&quot;bad default...%d&quot;, operator));
    }
}
</code></pre>
<h3>通用<code>BinaryExpression</code>的求值策略</h3>
<p>通用的<code>BinaryExpression</code>策略是采用递归法求解的：</p>
<ul>
<li>先递归求解<code>left</code>表达式的值<code>left_value</code></li>
<li>再递归求解<code>right</code>表达式的值<code>right_value</code></li>
<li>然后根据<code>left_value</code>和<code>right_value</code>的具体类型，分情况求解出最终的值。</li>
</ul>
<pre><code class="language-c">CRB_Value crb_eval_binary_expression(CRB_Interpreter *inter, LocalEnvironment *env, ExpressionType operator, Expression *left, Expression *right)
{
    CRB_Value   left_val;
    CRB_Value   right_val;
    CRB_Value   result;

    left_val = eval_expression(inter, env, left);
    right_val = eval_expression(inter, env, right);

    /* 整型 BinaryExpression 求解 */
    if (left_val.type == CRB_INT_VALUE &amp;&amp; right_val.type == CRB_INT_VALUE) {
        eval_binary_int(inter, operator, left_val.u.int_value, right_val.u.int_value, &amp;result, left-&gt;line_number);
    } 
    /* 浮点型 BinaryExpression */
    else if (left_val.type == CRB_DOUBLE_VALUE &amp;&amp; right_val.type == CRB_DOUBLE_VALUE) {
        eval_binary_double(inter, operator, left_val.u.double_value, right_val.u.double_value, &amp;result, left-&gt;line_number);
    }
    /* 浮点型 BinaryExpression */
    else if (left_val.type == CRB_INT_VALUE &amp;&amp; right_val.type == CRB_DOUBLE_VALUE) {
        left_val.u.double_value = left_val.u.int_value;
        eval_binary_double(inter, operator, left_val.u.double_value, right_val.u.double_value, &amp;result, left-&gt;line_number);
    }
    /* 浮点型 BinaryExpression */
    else if (left_val.type == CRB_DOUBLE_VALUE &amp;&amp; right_val.type == CRB_INT_VALUE) {
        right_val.u.double_value = right_val.u.int_value;
        eval_binary_double(inter, operator, left_val.u.double_value, right_val.u.double_value, &amp;result, left-&gt;line_number);
    }
    /* 布尔型 BinaryExpression */
    else if (left_val.type == CRB_BOOLEAN_VALUE &amp;&amp; right_val.type == CRB_BOOLEAN_VALUE) {
        result.type = CRB_BOOLEAN_VALUE;
        result.u.boolean_value = eval_binary_boolean(inter, operator, left_val.u.boolean_value, right_val.u.boolean_value, left-&gt;line_number);
    } 
    /* 字符串拼接 */
    else if (left_val.type == CRB_STRING_VALUE &amp;&amp; operator == ADD_EXPRESSION) {
        char    buf[LINE_BUF_SIZE];
        CRB_String *right_str;

        if (right_val.type == CRB_INT_VALUE) {
            sprintf(buf, &quot;%d&quot;, right_val.u.int_value);
            right_str = crb_create_crowbar_string(inter, MEM_strdup(buf));
        } else if (right_val.type == CRB_DOUBLE_VALUE) {
            sprintf(buf, &quot;%f&quot;, right_val.u.double_value);
            right_str = crb_create_crowbar_string(inter, MEM_strdup(buf));
        } else if (right_val.type == CRB_BOOLEAN_VALUE) {
            if (right_val.u.boolean_value) {
                right_str = crb_create_crowbar_string(inter, MEM_strdup(&quot;true&quot;));
            } else {
                right_str = crb_create_crowbar_string(inter, MEM_strdup(&quot;false&quot;));
            }
        } else if (right_val.type == CRB_STRING_VALUE) {
            right_str = right_val.u.string_value;
        } else if (right_val.type == CRB_NATIVE_POINTER_VALUE) {
            sprintf(buf, &quot;(%s:%p)&quot;, right_val.u.native_pointer.info-&gt;name, right_val.u.native_pointer.pointer);
            right_str = crb_create_crowbar_string(inter, MEM_strdup(buf));
        } else if (right_val.type == CRB_NULL_VALUE) {
            right_str = crb_create_crowbar_string(inter, MEM_strdup(&quot;null&quot;));
        } 
        result.type = CRB_STRING_VALUE;
        result.u.string_value = chain_string(inter, left_val.u.string_value, right_str);
    }
    /* 字符串比较大小 */
    else if (left_val.type == CRB_STRING_VALUE &amp;&amp; right_val.type == CRB_STRING_VALUE) {
        result.type = CRB_BOOLEAN_VALUE;
        result.u.boolean_value = eval_compare_string(operator, &amp;left_val, &amp;right_val, left-&gt;line_number);
    }
    /* 空值 */
    else if (left_val.type == CRB_NULL_VALUE || right_val.type == CRB_NULL_VALUE) {
        result.type = CRB_BOOLEAN_VALUE;
        result.u.boolean_value = eval_binary_null(inter, operator, &amp;left_val, &amp;right_val, left-&gt;line_number);
    } 
    /* 报错 */
    else {
        char *op_str = crb_get_operator_string(operator);
        crb_runtime_error(left-&gt;line_number, BAD_OPERAND_TYPE_ERR, STRING_MESSAGE_ARGUMENT, &quot;operator&quot;, op_str, MESSAGE_ARGUMENT_END);
    }

    return result;
}
</code></pre>
<h2>函数调用表达式求值</h2>
<p>函数调用表达式根据函数类型分为两种， <strong>原生函数调用</strong> 和 <strong>crowbar函数调用</strong> ，根据函数类型的不同，再选择性地调用<code>call_native_function()</code>或<code>call_crowbar_function()</code>:</p>
<pre><code class="language-c">static CRB_Value eval_function_call_expression(CRB_Interpreter *inter, LocalEnvironment *env, Expression *expr)
{
    CRB_Value           value;
    FunctionDefinition  *func;
    
    char *identifier = expr-&gt;u.function_call_expression.identifier;

    func = crb_search_function(identifier);
    if (func == NULL) {
        crb_runtime_error(expr-&gt;line_number, FUNCTION_NOT_FOUND_ERR, STRING_MESSAGE_ARGUMENT, &quot;name&quot;, identifier, MESSAGE_ARGUMENT_END);
    }
    switch (func-&gt;type) {
        case CROWBAR_FUNCTION_DEFINITION:
            value = call_crowbar_function(inter, env, expr, func);
            break;
        case NATIVE_FUNCTION_DEFINITION:
            value = call_native_function(inter, env, expr, func-&gt;u.native_f.proc);
            break;
        default:
            DBG_panic((&quot;bad case..%d\n&quot;, func-&gt;type));
    }

    return value;
}
</code></pre>
<p>原生函数调用的求值过程非常简单，因为原生函数实际上<code>C</code>语言编写的封装类型，通过指针，就可以直接调用：</p>
<pre><code class="language-c">static CRB_Value call_native_function(CRB_Interpreter *inter, LocalEnvironment *env, Expression *expr, CRB_NativeFunctionProc *proc)
{
    CRB_Value   value;
    int         arg_count;
    ArgumentList        *arg_p;
    CRB_Value   *args;
    int         i;

    /* 原生函数的参数个数 */
    for (arg_count = 0, arg_p = expr-&gt;u.function_call_expression.argument;
         arg_p; arg_p = arg_p-&gt;next) {
        arg_count++;
    }

    /* 原生函数的参数数组 */
    args = MEM_malloc(sizeof(CRB_Value) * arg_count);
    for (arg_p = expr-&gt;u.function_call_expression.argument, i = 0; arg_p; arg_p = arg_p-&gt;next, i++)
    {
        args[i] = eval_expression(inter, env, arg_p-&gt;expression);
    }

    /* 通过函数指针调用原生函数 */
    value = proc(inter, arg_count, args);

    /* 释放参数数组的内存 */
    for (i = 0; i &lt; arg_count; i++) {
        release_if_string(&amp;args[i]);
    }
    MEM_free(args);

    return value;
}
</code></pre>
<p>而利用<code>crowbar</code>脚本语言编写的脚本，则相对复杂一点；</p>
<ul>
<li>要为函数创建一个局部环境，然后把相关参数注册到该环境中，</li>
<li>然后再执行函数体中的语句列表</li>
<li>最后释放局部环境并返回最终结果</li>
</ul>
<pre><code class="language-c">static CRB_Value call_crowbar_function(CRB_Interpreter *inter, LocalEnvironment *env, Expression *expr, FunctionDefinition *func)
{
    CRB_Value   value;
    StatementResult     result;
    ArgumentList        *arg_p;
    ParameterList       *param_p;
    LocalEnvironment    *local_env;

    /* 创建一个局部环境，把相关参数添加到该局部环境中 */
    local_env = alloc_local_environment();
    for(arg_p = expr-&gt;u.function_call_expression.argument, param_p = func-&gt;u.crowbar_f.parameter; 
        arg_p;
        arg_p = arg_p-&gt;next, param_p = param_p-&gt;next) 
    {
        CRB_Value arg_val;

        if (param_p == NULL) {
            crb_runtime_error(expr-&gt;line_number, ARGUMENT_TOO_MANY_ERR, MESSAGE_ARGUMENT_END);
        }
        arg_val = eval_expression(inter, env, arg_p-&gt;expression);
        crb_add_local_variable(local_env, param_p-&gt;name, &amp;arg_val);
    }
    if (param_p) {
        crb_runtime_error(expr-&gt;line_number, ARGUMENT_TOO_FEW_ERR, MESSAGE_ARGUMENT_END);
    }

    /* 执行函数体 */
    result = crb_execute_statement_list(inter, local_env, func-&gt;u.crowbar_f.block -&gt;statement_list);

    if (result.type == RETURN_STATEMENT_RESULT) { value = result.u.return_value; } 
    else { value.type = CRB_NULL_VALUE; }

    dispose_local_environment(inter, local_env);

    return value;
}
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/Compiler/自制编程语言/crowbar源码阅读笔记(2).html">
                    crowbar源码阅读笔记(2):变量管理
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        大道
                      </a>
                    </li>
                    <li>
                      <a href="">
                        编译原理
                      </a>
                    </li>
                    <li>
                      <a href="">
                        自制编程语言
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#编译原理">
                    <span class="tag is-info">
                      编译原理
                    </span>
                  </a>
                  <a href="tags.html#自制编程语言">
                    <span class="tag is-info">
                      自制编程语言
                    </span>
                  </a>
                  <a href="tags.html#crowbar">
                    <span class="tag is-info">
                      crowbar
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-08-19
                </p>
              </div>
              <div class="content article-body">
                <p>这是《自制编程语言》一书中的脚本语言<code>crowbar</code>的源码阅读笔记(2):变量管理</p>
<h2>变量管理</h2>
<p>在第一篇《crowbar源码阅读笔记(1):基本的数据结构》中提到，变量有两个基本属性：变量名、变量值。变量之间采用链表的形式组织。相应环境(局部、全局)下有各自的一批变量。</p>
<h3>注册变量</h3>
<p>在一个局部环境中注册变量，需要告知该环境对象需要登记的 <strong>标识符</strong> 和 <strong>变量值</strong>，然后<code>crowbar</code>会在内存中创建一个变量对象，填好<code>name</code>和<code>value</code>，然后把它作为环境变量链表的第一个节点 ：</p>
<pre><code class="language-c">void crb_add_local_variable(LocalEnvironment *env, char *identifier, CRB_Value *value)
{
    /* 分配内存，创建新的变量 */
    Variable    *new_variable;
    new_variable = MEM_malloc(sizeof(Variable));
    new_variable-&gt;name = identifier;
    new_variable-&gt;value = *value;

    /* 把原链表第一个节点作为新增变量的下一个节点 */
    new_variable-&gt;next = env-&gt;variable;
    /* 修改环境变量链表：设置新增变量为环境变量链表的第一个节点 */
    env-&gt;variable = new_variable;
}
</code></pre>
<p>注册全局变量也是类似的过程：</p>
<!-- more -->
<pre><code class="language-c">void CRB_add_global_variable(CRB_Interpreter *inter, char *identifier, CRB_Value *value)
{
    Variable    *new_variable;

    new_variable = crb_execute_malloc(inter, sizeof(Variable));

    /* 设置新增变量的name */
    new_variable-&gt;name = crb_execute_malloc(inter, strlen(identifier) + 1);
    strcpy(new_variable-&gt;name, identifier);

    /* 把原链表第一个节点作为新增变量的下一个节点 */
    new_variable-&gt;next = inter-&gt;variable;
    /* 修改环境变量链表：设置新变量为环境变量链表的第一个节点 */
    inter-&gt;variable = new_variable;

    /* 设置新增变量的value */
    new_variable-&gt;value = *value;
}
</code></pre>
<p>从上文可以看出，每次想向相应的环境(局部或者全局)新增变量，<code>crowbar</code>都会把新增的变量放到变量链表的首位。</p>
<h3>变量解析</h3>
<p>上文说到，<code>crowbar</code>以链表的方式组织相应环境中的变量，故变量解析也是直接从头开始遍历<code>Varible</code>链表，检查链表相应节点的变量名是否和相应的标识符一致，其实现非常简单：</p>
<pre><code class="language-c">
/* 在局部环境中搜索标识符 */
Variable * crb_search_local_variable(LocalEnvironment *env, char *identifier) {
    Variable    *pos;
    if (env == NULL) return NULL;
    for (pos = env-&gt;variable; pos; pos = pos-&gt;next) {
        if (!strcmp(pos-&gt;name, identifier))
            break;
    }
    if (pos == NULL) { return NULL; } 
    else { return pos; }
}

/* 在全局环境中搜索标识符 */
Variable * crb_search_global_variable(CRB_Interpreter *inter, char *identifier)
{
    Variable    *pos;

    for (pos = inter-&gt;variable; pos; pos = pos-&gt;next) {
        if (!strcmp(pos-&gt;name, identifier))
            return pos;
    }

    return NULL;
}
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/Compiler/自制编程语言/crowbar源码阅读笔记(1).html">
                    crowbar源码阅读笔记(1):基本的数据结构
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        大道
                      </a>
                    </li>
                    <li>
                      <a href="">
                        编译原理
                      </a>
                    </li>
                    <li>
                      <a href="">
                        自制编程语言
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#编译原理">
                    <span class="tag is-info">
                      编译原理
                    </span>
                  </a>
                  <a href="tags.html#自制编程语言">
                    <span class="tag is-info">
                      自制编程语言
                    </span>
                  </a>
                  <a href="tags.html#crowbar">
                    <span class="tag is-info">
                      crowbar
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-08-18
                </p>
              </div>
              <div class="content article-body">
                <p>这是《自制编程语言》一书中的脚本语言<code>crowbar</code>的源码阅读笔记(1):基本的数据结构。</p>
<p><code>crowbar</code>语言由<code>C</code>语言编写，分为以下三个独立模块:</p>
<ul>
<li><code>CRB</code>：<code>crowbar</code> 主程序</li>
<li><code>MEM</code>: 通用内存管理模块，源码位于<code>memory/</code>目录下</li>
<li><code>DBG</code>: 通用<code>Debug</code>模块，源码位于<code>debug/</code>目录下</li>
</ul>
<h2><code>CRB</code>解释器接口</h2>
<p><code>CRB.h</code>是解释器的接口文件：</p>
<pre><code class="language-c">/* 创建解释器 */
CRB_Interpreter *CRB_create_interpreter(void);

/* 使用解释器编译文件 */
void CRB_compile(CRB_Interpreter *interpreter, FILE *fp);

/* 使用解释器解释 */
void CRB_interpret(CRB_Interpreter *interpreter);

/* 回收解释器 */
void CRB_dispose_interpreter(CRB_Interpreter *interpreter);
</code></pre>
<h2><code>CRB</code>解释器扩展接口</h2>
<p>为了扩展解释器，可以使用解释器的开发接口：<code>CRB_dev.h</code>。这个接口规定了<code>crowbar</code>这门语言的值类型和扩展接口。</p>
<!-- more -->
<h3>值类型</h3>
<p><code>crowbar</code>中可用的类型包括布尔型、整型、浮点型、字符串型、原生指针型、和空引用型：</p>
<pre><code class="language-c">typedef enum {
    CRB_BOOLEAN_VALUE = 1,
    CRB_INT_VALUE,
    CRB_DOUBLE_VALUE,
    CRB_STRING_VALUE,
    CRB_NATIVE_POINTER_VALUE,
    CRB_NULL_VALUE
} CRB_ValueType;
</code></pre>
<p><code>crowbar</code>中变量可以是其中任意一种类型，为了表示变量的值，可以把“值”定义为:</p>
<pre><code class="language-c">typedef struct {
    CRB_ValueType       type;
    union {
        CRB_Boolean     boolean_value;
        int             int_value;
        double          double_value;
        CRB_String      *string_value;
        CRB_NativePointer       native_pointer;
    } u;
} CRB_Value;
</code></pre>
<h3>扩展接口</h3>
<p>要为这门语言开发功能，需要使用扩展接口，<code>CRB</code>提供了以下三个函数：</p>
<pre><code class="language-c">/* 代表能返回 CRB_Value 的函数 */
typedef CRB_Value CRB_NativeFunctionProc(CRB_Interpreter *interpreter, int arg_count, CRB_Value *args);

/* 注册函数到解释器 */
void CRB_add_native_function(CRB_Interpreter *interpreter, char *name, CRB_NativeFunctionProc *proc);
/* 注册全局变量到解释器*/
void CRB_add_global_variable(CRB_Interpreter *inter, char *identifier, CRB_Value *value);
</code></pre>
<h2><code>CRB</code> 解释器</h2>
<p><code>CRB</code>解释器相关定义位于<code>crowbar.h</code>中，规定了一些列语言相关的数据结构：</p>
<ul>
<li>解释器、编译错误、运行时错误、消息参数类型、消息格式、</li>
<li>变量、标识符列表、局部环境、全局变量引用</li>
<li>表达式类型、表达式、赋值表达式、二叉表达式、函数调用表达式、</li>
<li>语句类型、语句、语句列表、块、语句结果类型、语句结果、if语句、while语句、for语句、return语句、全局语句</li>
<li>函数定义、参数列表(链表)</li>
<li>String、String Pool</li>
</ul>
<p>其中最重要的是解释器<code>CRB_Interpreter</code>：</p>
<pre><code class="language-c">struct CRB_Interpreter_tag {
    /* 在解释器生成时生成，解释器废弃时释放 */
    MEM_Storage         interpreter_storage;
    /* 运行时的存储  */
    MEM_Storage         execute_storage;
    /* 全局变量 链表 */
    Variable            *variable;
    /* 函数定义 链表 */
    FunctionDefinition  *function_list;
    /* 语句 链表 */
    StatementList       *statement_list;
    /* 当前行号 */
    int                 current_line_number;
};
</code></pre>
<h2>变量</h2>
<p>其中，<code>Varible</code>实际上指的是全局变量链表：</p>
<pre><code class="language-c">typedef struct Variable_tag {
    char        *name;
    CRB_Value   value;
    struct Variable_tag *next;
} Variable;
</code></pre>
<p>变量都很简单，自身拥有两个属性：</p>
<ul>
<li>变量名：即标识符。</li>
<li>变量值：统一为<code>CRB_Value</code>类型。</li>
</ul>
<p><code>crowbar</code>以链表的形式组织变量，依次取<code>next</code>指针即可遍历。</p>
<p>在此变量基础上，就可以表示出全局变量变量链表和局部环境:</p>
<pre><code class="language-c">typedef struct GlobalVariableRef_tag {
    Variable    *variable;
    struct GlobalVariableRef_tag *next;
} GlobalVariableRef;

typedef struct {
    Variable    *variable;
    GlobalVariableRef   *global_variable;
} LocalEnvironment;
</code></pre>
<p>变量解析即是从相应环境（局部、全局）中寻找标识符的过程，由于<code>crowbar</code>采用了链表的组织方式，其的实现机理也是直接在相应环境中从头开始遍历<code>Varible</code>链表，检查链表相应节点的变量名是否和相应的标识符一致：</p>
<pre><code class="language-c">Variable * crb_search_local_variable(LocalEnvironment *env, char *identifier);
Variable * crb_search_global_variable(CRB_Interpreter *inter, char *identifier);
</code></pre>
<h3>表达式</h3>
<p>表达式的数据结构为：</p>
<pre><code class="language-c">struct Expression_tag {
    ExpressionType type;
    int line_number;
    union {
        CRB_Boolean             boolean_value;
        int                     int_value;
        double                  double_value;
        char                    *string_value;
        char                    *identifier;
        AssignExpression        assign_expression;
        BinaryExpression        binary_expression;
        Expression              *minus_expression;
        FunctionCallExpression  function_call_expression;
    } u;
};
</code></pre>
<p>表达式有多种，比如赋值表达式：</p>
<pre><code class="language-c">typedef struct {
    char        *variable;
    Expression  *operand;
} AssignExpression;
</code></pre>
<p>二叉表达式：</p>
<pre><code class="language-c">typedef struct {
    Expression  *left;
    Expression  *right;
} BinaryExpression;
</code></pre>
<p>函数调用表达式:</p>
<pre><code class="language-c">typedef struct {
    char                *identifier;
    ArgumentList        *argument;
} FunctionCallExpression;
</code></pre>
<h3>语句、语句列表、及块</h3>
<h4>对语句、语句列表及块的抽象表示</h4>
<p>一个语句可能是表达式语句、全局语句、<code>if</code>语句、<code>while</code>语句、<code>for</code>语句、<code>return</code>语句。故可以把语句抽象为：</p>
<pre><code class="language-c">struct Statement_tag {
    StatementType       type;
    int                 line_number;
    union {
        Expression      *expression_s;
        GlobalStatement global_s;
        IfStatement     if_s;
        WhileStatement  while_s;
        ForStatement    for_s;
        ReturnStatement return_s;
    } u;
};
</code></pre>
<p>在此基础上，可以抽象出语句链表：</p>
<pre><code class="language-c">typedef struct StatementList_tag {
    Statement   *statement;
    struct StatementList_tag    *next;
} StatementList;
</code></pre>
<p>而一系列语句列表可以构成块：</p>
<pre><code class="language-c">typedef struct {
    StatementList       *statement_list;
} Block;
</code></pre>
<h4>具体分类的语句的定义</h4>
<p>不同的语句有不同的特征，需要为具体类型的语句定义特定的成员。比如<code>if</code>语句为：</p>
<pre><code class="language-c">typedef struct {
    Expression  *condition;
    Block       *then_block;
    Elsif       *elsif_list;
    Block       *else_block;
} IfStatement;
</code></pre>
<p>而用于循环的<code>while</code>语句：</p>
<pre><code class="language-c">typedef struct {
    Expression  *condition;
    Block       *block;
} WhileStatement;
</code></pre>
<p><code>for</code>语句：</p>
<pre><code class="language-c">typedef struct {
    Expression  *init;
    Expression  *condition;
    Expression  *post;
    Block       *block;
} ForStatement;
</code></pre>
<p><code>return</code>用于返回一个表达式的值：</p>
<pre><code class="language-c">typedef struct {
    Expression *return_value;
} ReturnStatement;
</code></pre>
<h3>函数定义构成的链表</h3>
<p>在定义函数之前，先要抽象出参数链表:</p>
<pre><code class="language-c">typedef struct ArgumentList_tag {
    Expression *expression;
    struct ArgumentList_tag *next;
} ArgumentList;
</code></pre>
<p>函数分为<code>CROWBAR_FUNCTION</code>和<code>NATIVE_FUNCTION</code>两种。对于前者，函数定义由参数链表和<code>block</code>构成。对于后者，实际上由<code>C</code>语言写就，故可以用一个函数指针来表示。</p>
<pre><code class="language-c">typedef struct FunctionDefinition_tag {
    char                       *name;
    FunctionDefinitionType      type;
    union {
        struct {
            ParameterList       *parameter;
            Block               *block;
        } crowbar_f;
        struct {
            CRB_NativeFunctionProc      *proc;
        } native_f;
    } u;
    struct FunctionDefinition_tag       *next;
} FunctionDefinition;
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/Python/Python-清洗-Excel-数据的一点感想.html">
                    Python 清洗 Excel 数据的一点感想
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Python
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#Python">
                    <span class="tag is-info">
                      Python
                    </span>
                  </a>
                  <a href="tags.html#Excel">
                    <span class="tag is-info">
                      Excel
                    </span>
                  </a>
                  <a href="tags.html#清洗数据">
                    <span class="tag is-info">
                      清洗数据
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-08-03
                </p>
              </div>
              <div class="content article-body">
                <p>这两年我是不大碰<code>Python</code>的，原因是我觉得搞网站、写爬虫、干自动化任务，用<code>Node.Js</code>编写速度更快、运行效率更高。但是最近在成都集中办公，作为数据组，主要工作就是要清洗数据，需要大量处理<code>Excel</code>，由于不太喜欢<code>VB</code>那啰嗦的语法，用<code>JScript</code>操作<code>Excel</code>又非常不得劲，于是不得不捡起<code>Python</code>：无他，简单，会得人多，库也就多。这两年<code>Python</code>在数据处理领域占据了绝对优势。</p>
<p>吐槽一句，这么多年来，<code>Python</code>一直以优雅自居。但是缩进语法并非表面上那样优雅，起码面对多行匿名函数的时候，始终优雅不起来。</p>
<h2>工具</h2>
<ul>
<li><code>IPython</code>是个非常有意思的工具，但是貌似不提供<code>VIM</code>的键盘模式，于是照例在<code>VSCode</code>中安装<code>Jupyter</code>插件，从而兼得编辑器和<code>IPython</code>。</li>
<li>使用<code>xlwings</code>操作<code>Excel</code></li>
</ul>
<h2>Python 操作 Excel 的一个例子</h2>
<p>需求：有一个<code>Excel</code>表，其中某个<code>Sheet</code>的结构为：</p>
<ul>
<li>井号</li>
<li>分层单位</li>
<li>层位</li>
<li>...</li>
</ul>
<p>同一个井，不同的分层单位又不通的分层方案。总记录行数约为11万，其中有大量数据的层位数据有误，但是对于同一个分层单位对同一个井的分层方案，有目前以下规律：</p>
<ol>
<li>由于<code>T3h1</code>跟下层是整合关系，故其下伏层必定是应该<code>T3a4</code>或者<code>T3a</code>。</li>
<li>如果<code>T3h1</code>之后是<code>T3a4</code>地层，且再之下的下伏层是<code>T3a</code>组内的，必定只能是<code>T3a3</code>，也就是说不能是<code>T3a1</code>或<code>T3a2</code>。</li>
<li>类似的，<code>T3a3</code>下伏层出现的<code>T3a</code>组的地层，只能是<code>T3a2</code>；<code>T3a2</code>下伏层出现的<code>T3a</code>组的地层，只能是<code>T3a1</code>。</li>
<li>任何一个层位<code>T3a${i}</code>（i=1,2,3）,都可以缺失掉，然后直接跳到其他组的层位.</li>
</ol>
<p>起初我觉得要修改的数据量不大，直接在<code>Excel</code>中手工修改，后来才发现严重低估了这个工作量，大约耗费了我20分钟，我才意识到要修改的记录量可能要到数万，于是采用编程解决。</p>
<p>编程有两种思路：一、通过相关接口直接操作<code>Excel</code>表；二、读取<code>Excel</code>内容到内存或者数据库，然后修改后存回。由于其他字段有许多<code>Excel</code>样式，故直接采用思路一。</p>
<h3>使用<code>Python</code>编写脚本</h3>
<p>尽管层位出现的各类情况很多，但是经过思考就可以发现，只要按照分层单位、深度排序，层位<code>T3a${i}</code>只能出现在<code>T3h1</code>的后四个记录里。所以基本思路是找到层位字段值是<code>T3h1</code>的记录，然后向下搜寻四个，如果是<code>T3a</code>组的层段，则根据情况修改为对应的层位记录即可。</p>
<p>起手式必然是应该打开<code>Excel</code>，读入数据：</p>
<pre><code class="language-Python">import xlwings as xw


book= xw.Book(r&quot;./地质研究_07地层分层信息 合表 201708.03.01-P2.xlsx&quot;)
sht=book.sheets[&quot;合表&quot;]
</code></pre>
<p>顺带封装下获取相应列字段的函数：</p>
<pre><code class="language-Python">def getWell(rowNumber):
    return sht.range(&quot;B&quot;+str(rowNumber)).value

def getLayerDept(rowNumber):
    return sht.range(&quot;E&quot;+str(rowNumber)).value

def getLayer(rowNumber):
    return sht.range(&quot;G&quot;+str(rowNumber)).value


</code></pre>
<p>然后是对修改后续某偏移行的层位的帮助方法：</p>
<pre><code class="language-Python">def modifyNext(well,layer_dept,currentRowNumber,offset=1,layer=&quot;T2a4&quot;):

    # 偏移行的井名
    _well= getWell(currentRowNumber+offset)
    # 偏移行的分层单位
    _layer_dept=getLayerDept(currentRowNumber+offset)
    # 偏移行的层位
    _layer=getLayer(currentRowNumber+offset)

    # 如果偏移行的井名或分层单位和给定的井位及分层单位不匹配，则什么也不做
    if(not well==_well or not layer_dept==_layer_dept):
        return

    if(_layer.startswith(&quot;T2a&quot;)):
        sht.range(&quot;G&quot;+str(currentRowNumber+offset)).value=layer
        sht.range(&quot;G&quot;+str(currentRowNumber+offset)).color=(254,226,239)
</code></pre>
<p>然后就是迭代搜查修改的主程序了：</p>
<pre><code class="language-Python">arr=sht.range(&quot;G1&quot;).expand('down').value
for (idx,value) in enumerate(arr) :
    if(value==&quot;T3h1&quot;):
        currentRowNumber=idx+1
        # 检查下一行
        if(arr[idx+1]==&quot;T2a&quot;):
            pass
        elif( arr[idx+1]==&quot;T2a4&quot; and arr[idx+2]==&quot;T2a3&quot;):
            pass
        else:
            print(&quot;!发现可疑错误：G&quot;,idx,&quot;尝试修正后续4个层位...&quot;)
            xw.Range(&quot;G&quot;+str(currentRowNumber)).color=(0,255,0)
            well=getWell(currentRowNumber)
            layer_dept=getLayerDept(currentRowNumber)
            modifyNext(well,layer_dept,currentRowNumber,1,&quot;T2a4&quot;)
            modifyNext(well,layer_dept,currentRowNumber,2,&quot;T2a3&quot;)
            modifyNext(well,layer_dept,currentRowNumber,3,&quot;T2a2&quot;)
            modifyNext(well,layer_dept,currentRowNumber,4,&quot;T2a1&quot;)

print(&quot;done&quot;)
</code></pre>
<h2>一句话总结</h2>
<p>库多真好。</p>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Instrument/VSCode/使用-VSCode-TDM-GCC-学习CPP.html">
                    笔记：使用 VSCode + TDM-GCC 学习CPP
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        法器
                      </a>
                    </li>
                    <li>
                      <a href="">
                        VSCode
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#VSCode">
                    <span class="tag is-info">
                      VSCode
                    </span>
                  </a>
                  <a href="tags.html#TDM-GCC">
                    <span class="tag is-info">
                      TDM-GCC
                    </span>
                  </a>
                  <a href="tags.html#Cpp">
                    <span class="tag is-info">
                      Cpp
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-08-02
                </p>
              </div>
              <div class="content article-body">
                <p>由于一些原因，打算捡起<code>C/C++</code>来做些习题。虽说个人电脑上装了大慈善家微软的<code>Visual Studio 2017</code>（社区版），但是对于简单的习题而言，VS 这个大杀器还是稍重了些。考虑到最近一年来，我已经用<code>VSCode</code>替换<code>Vim</code>作为主力编辑器，故而我开始在网上搜寻<code>VSCode</code>编写<code>C/C++</code>的相关资料。</p>
<p><a href="https://code.visualstudio.com/docs/languages/cpp">微软官方对使用 VSCode 编写 C/C++ 的文档描述</a>并不给力，显然远远没有更上<code>VSCode</code>的发展速度。然后我在知乎上搜到微软员工 <a href="https://www.zhihu.com/people/be5invis">Belleve</a>写的<a href="https://www.zhihu.com/question/40929777/answer/90015056">使用 VSCode + TDM-GCC</a> 的回答，读后受益匪浅。相比较而言，微软官方的VSCode C/CPP文档简直完全没有帮助——如今其<code>C/C++</code>插件已经提供了代码高亮、调试等功能，设置默认的引擎后，已经无需再单独配置<code>c_cpp_properties.json</code>文件即可使用了。</p>
<p>特此记录备忘。</p>
<h2>基本思路：</h2>
<ol>
<li>使用<code>TDM-GCC</code>提供的<code>gcc</code>、<code>g++</code>、<code>gdb</code>等工具链编译、调试</li>
<li>使用<code>VSCode</code>编辑代码，安装微软官方插件<a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C/C++</a>来提供语言服务（代码格式化、自动补全、符号搜索等)和Debugging</li>
</ol>
<h2>安装与配置</h2>
<h3>安装</h3>
<ul>
<li>安装<code>TDM-GCC</code>，配置<code>PATH</code>方便以后使用</li>
<li>安装<code>VSCode</code>+ 官方<code>C/C++</code>插件，在首选项中配置智能提示引擎为默认:</li>
</ul>
<pre><code class="language-JavaScript">&quot;C_Cpp.intelliSenseEngine&quot;: &quot;Default&quot;
</code></pre>
<h3>项目相关配置</h3>
<p>调试的基本过程：</p>
<ol>
<li>每次调试之前使用<code>g++</code>以<code>-g</code>参数编译源程序</li>
<li><code>VSCode</code>调用<code>gdb</code>对编译好的文件进行调试</li>
</ol>
<p>第1步可以通过配置<code>Task</code>完成，假定我们要编译的源文件为<code>main.cpp</code>。可以在目录中<code>.vscode/</code>下建立<code>tasks.json</code>文件:</p>
<pre><code class="language-JSON">{
    // See https://go.microsoft.com/fwlink/?LinkId=733558
    // for the documentation about the tasks.json format
    &quot;version&quot;: &quot;2.0.0&quot;,
    &quot;tasks&quot;: [
        {
            &quot;taskName&quot;: &quot;g++-g&quot;,
            &quot;command&quot;: &quot;g++&quot;,
            &quot;args&quot;: [
                &quot;-g&quot;,
                &quot;main.cpp&quot;,
                &quot;-o&quot;,
                &quot;debug/main.exe&quot;
            ]
        }
    ]
}
</code></pre>
<p>我们在该<code>JSON</code>文件中配置了一个任务，起名为<code>g++-g</code>，每次执行后都会编译输出为<code>debug/main.exe</code>。</p>
<p>至于使用<code>VSCode</code>发起调试，需要在<code>.vscode/</code>下创建<code>launch.json</code>配置：</p>
<pre><code>{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;(gdb) Launch&quot;,
            &quot;type&quot;: &quot;cppdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;${workspaceRoot}/debug/main.exe&quot;,
            &quot;args&quot;: [],
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;${workspaceRoot}&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: true,
            &quot;preLaunchTask&quot;: &quot;g++-g&quot;,
            &quot;MIMode&quot;: &quot;gdb&quot;,
            &quot;miDebuggerPath&quot;: &quot;gdb.exe&quot;,
            &quot;setupCommands&quot;: [
                {
                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,
                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,
                    &quot;ignoreFailures&quot;: true
                }
            ]
        }
    ]
}
</code></pre>
<p>这里我们配置了一个<code>launch</code>请求:</p>
<ul>
<li><code>type</code>为<code>cppdbg</code>，</li>
<li><code>MIMode</code>为<code>gdb</code>，</li>
<li><code>miDebuggerPath</code>为<code>gdb</code>的路径，</li>
<li>目标程序为我们用<code>Task</code>编译好的<code>debug/main.exe</code>，</li>
</ul>
<p>此外，还需注意<code>preLaunchTash</code>这个属性值我们设置为<code>g++-g</code>，保证了我们按下<code>F5</code>启动<code>Launch</code>后先执行对应的<code>Task</code>完成编译。</p>
<h2>demo</h2>
<p>{% asset_img &quot;demo.gif&quot; &quot;demo&quot; %}</p>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <div class="container">
      <div class="container has-text-centered">
        <a href="posts/page15.html">
          Previous
        </a>
        17 of 32
        <a href="posts/page17.html">
          Next
        </a>
      </div>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
       // 处理形如 <code>$E=mc^2$</code> 形式的公式
 var inlineMathNodes=document.querySelectorAll('code');
 var re=/^\$(.*)\$$/;
 for(var j=0;j<inlineMathNodes.length;j++){
   var result=re.exec(inlineMathNodes.item(j).innerText);
   if(result!==null){
	 katex.render(result[1], inlineMathNodes.item(j));
   }
 }
 function removeNode(node){
   if(node.remove){
	 node.remove();
   }else{
	 return first.parentNode.removeChild(node);
   }
 };

 // 查找所有 pre code.language-math 节点 以备筛出数据公式
 var nodes=document.querySelectorAll("pre code.language-math");
 for(var i=0;i<nodes.length;i++){
   var node=nodes.item(i);
   // 魔术标记所在行 
   try{
	 var lines = node.innerText.split('\n');
	 if((!!lines) && lines.length > 0)
	 {
	   var first = lines[0];
	   if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
		 var views = "";
		 // 逐行渲染
		 for(var k=1; k <lines.length; k++){
			 var f=lines[k];
			 views += katex.renderToString(f);
		 }
		 // 消除父级嵌套 
		 try{
		   node.innerHTML=views;
		 }catch(e){
		   // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
		   console.log('IE9 sucks',e);
		   $(tr).html(node.innerHTML);
		 }
	   }
	 }
   }
   catch(err){
	 console.log(err)
   }
 }
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>