<!DOCTYPE html><html>
  <head>
    <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie/"/>
    <script>
      document.addEventListener('DOMContentLoaded', () => {

	// Get all "navbar-burger" elements
	const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);
  
	// Check if there are any navbar burgers
	if ($navbarBurgers.length > 0) {
  
	  // Add a click event on each of them
	  $navbarBurgers.forEach( el => {
		el.addEventListener('click', () => {
  
		  // Get the target from the "data-target" attribute
		  const target = el.dataset.target;
		  const $target = document.getElementById(target);
  
		  // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
		  el.classList.toggle('is-active');
		  $target.classList.toggle('is-active');
  
		});
	  });
	}
  });
    </script>
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/fsharp.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item is-active" href="">
            Home
          </a>
          <a class="navbar-item" href="tags.html">
            Tags
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/Compiler/自制编程语言/crowbar源码阅读笔记(6).html">
                    crowbar源码阅读笔记(6):语句执行
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        大道
                      </a>
                    </li>
                    <li>
                      <a href="">
                        编译原理
                      </a>
                    </li>
                    <li>
                      <a href="">
                        自制编程语言
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#编译原理">
                    <span class="tag is-info">
                      编译原理
                    </span>
                  </a>
                  <a href="tags.html#自制编程语言">
                    <span class="tag is-info">
                      自制编程语言
                    </span>
                  </a>
                  <a href="tags.html#crowbar">
                    <span class="tag is-info">
                      crowbar
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-08-20
                </p>
              </div>
              <div class="content article-body">
                <p>这是《自制编程语言》一书中的脚本语言<code>crowbar</code>的源码阅读笔记(6):语句执行。语句执行的实现代码主要存放于文件<code>execute.c</code>中。</p>
<h2>语句执行总体框架</h2>
<h3>单语句执行</h3>
<p>运行单个语句，则和表达式求值的思路一样，要区分具体的语句类型，然后执行不同的策略，最后返回语句执行结果(<code>StatementResult</code>类型对象)：</p>
<pre><code class="language-c">static StatementResult execute_statement(CRB_Interpreter *inter, LocalEnvironment *env, Statement *statement)
{
    StatementResult result;

    result.type = NORMAL_STATEMENT_RESULT;

    switch (statement-&gt;type) {
    case EXPRESSION_STATEMENT:
        result = execute_expression_statement(inter, env, statement);
        break;
    case GLOBAL_STATEMENT:
        result = execute_global_statement(inter, env, statement);
        break;
    case IF_STATEMENT:
        result = execute_if_statement(inter, env, statement);
        break;
    case WHILE_STATEMENT:
        result = execute_while_statement(inter, env, statement);
        break;
    case FOR_STATEMENT:
        result = execute_for_statement(inter, env, statement);
        break;
    case RETURN_STATEMENT:
        result = execute_return_statement(inter, env, statement);
        break;
    case BREAK_STATEMENT:
        result = execute_break_statement(inter, env, statement);
        break;
    case CONTINUE_STATEMENT:
        result = execute_continue_statement(inter, env, statement);
        break;
    case STATEMENT_TYPE_COUNT_PLUS_1:   /* FALLTHRU */
    default:
        DBG_panic((&quot;bad case...%d&quot;, statement-&gt;type));
    }

    return result;
}
</code></pre>
<!-- more -->
<p>不同语句有不同的执行结果，语句执行结果抽象为一个结构体</p>
<pre><code class="language-c">typedef struct {
    StatementResultType type;
    union {
        CRB_Value       return_value;
    } u;
} StatementResult;
</code></pre>
<p>语句的执行结果有不同类型，可以分为:</p>
<ul>
<li><code>NORMAL_STATEMENT_RESULT</code>：常规语句执行</li>
<li><code>RETURN_STATEMENT_RESULT</code>: 返回语句执行</li>
<li><code>BREAK_STATEMENT_RESULT</code> : <code>break</code>语句执行</li>
<li><code>CONTINUE_STATEMENT_RESULT</code>: <code>continue</code>语句执行</li>
<li><code>STATEMENT_RESULT_TYPE_COUNT_PLUS_1</code>:</li>
</ul>
<p>其中，<code>RETURN_STATEMENT_RESULT</code>、<code>BREAK_STATEMENT_RESULT</code>标识了将要中断循环；而<code>CONTINUE_STATEMENT_RESULT</code>则表示要循环体语句的执行<code>crb_execute_statement_list()</code>将要被中断。</p>
<p>语句执行后的结果值用联合<code>u</code>表示，目前只有个表示返回值的<code>return_value</code>字段，这是一个<code>CRB_Value</code>型结构，可以统一表达各种类型的返回值。</p>
<h3>语句链表的执行</h3>
<p>语句链表的执行，是依次执行语句并检查执行结果：</p>
<pre><code class="language-c">StatementResult crb_execute_statement_list(CRB_Interpreter *inter, LocalEnvironment *env, StatementList *list)
{
    StatementList *pos;
    StatementResult result;

    result.type = NORMAL_STATEMENT_RESULT;
    for (pos = list; pos; pos = pos-&gt;next) {
        result = execute_statement(inter, env, pos-&gt;statement);
        if (result.type != NORMAL_STATEMENT_RESULT)
            goto FUNC_END;
    }

  FUNC_END:
    return result;
}
</code></pre>
<h2>表达式语句</h2>
<p>表达式类型的语句执行非常简单，就是对相应的表达式进行求值：</p>
<pre><code class="language-c">static StatementResult execute_expression_statement(CRB_Interpreter *inter, LocalEnvironment *env, Statement *statement)
{
    StatementResult result;
    CRB_Value v;

    result.type = NORMAL_STATEMENT_RESULT;

    v = crb_eval_expression(inter, env, statement-&gt;u.expression_s);
    if (v.type == CRB_STRING_VALUE) {
        crb_release_string(v.u.string_value);
    }

    return result;
}
</code></pre>
<p>表达式语句不设置语句返回值，只是填充<code>type</code>为<code>NORMAL_STATEMENT_RESULT</code>。比如：</p>
<pre><code class="language-js">v1=3+4*2;
</code></pre>
<p>这是一个 <strong>赋值表达式</strong> 构成的语句。赋值表达式求值会计算等号右边的值，然后赋给<code>v1</code>标识符对应的变量。最后当这个语句执行完毕后返回一个执行结果。
注意，该语句结果并不包含表达式的值，只告诉解释器，该语句执行完毕后是一个<code>NORMAL_STATEMENT_RESULT</code>。</p>
<h2>与关键字相关的语句</h2>
<h3><code>return</code> 语句执行</h3>
<p><code>return</code>语句的执行本身比较简单，最后也是返回一个语句执行结果，该结果的<code>type</code>字段为<code>RETURN_STATEMENT_RESULT</code>，而具体的执行值在<code>u.return_value</code>字段中填充：</p>
<ul>
<li>如果后面跟着一个表达式，则对表达式进行求值，然后填充至结果的<code>u.return_value</code>字段。</li>
<li>否则，设置<code>u.return_value.type</code>为<code>CRB_NULL_VALUE</code>。</li>
</ul>
<pre><code class="language-c">static StatementResult execute_return_statement(CRB_Interpreter *inter, LocalEnvironment *env, Statement *statement)
{
    StatementResult result;
    result.type = RETURN_STATEMENT_RESULT;

    if (statement-&gt;u.return_s.return_value) {
        result.u.return_value = crb_eval_expression(inter, env, statement-&gt;u.return_s.return_value);
    } else {
        result.u.return_value.type = CRB_NULL_VALUE;
    }

    return result;
}
</code></pre>
<h3><code>for</code> 循环语句执行</h3>
<p>一个完整的<code>for</code>语句可以拆分4个部分，即<code>init</code>、<code>condition</code>、 <code>post</code>、<code>block</code> ：</p>
<pre><code class="language-c">for(init;condition;post)
    block
</code></pre>
<p>具体执行过程是：</p>
<ol>
<li>先对<code>init</code>部分的表达式进行求值，</li>
<li>然后检测是否达到终止条件，</li>
<li>如果未达到，则执行<code>for</code>语句块。</li>
<li>如果执行结果满足<code>return</code>、<code>break</code>这类跳出条件的，则终止循环。</li>
<li>如果需要继续，则执行<code>post</code>相关表达式</li>
<li>最后开始下一次循环。</li>
</ol>
<pre><code class="language-c">static StatementResult execute_for_statement(CRB_Interpreter *inter, LocalEnvironment *env, Statement *statement)
{
    StatementResult result;
    CRB_Value   cond;

    result.type = NORMAL_STATEMENT_RESULT;

    /* 对for循环的init表达式求值 */
    if (statement-&gt;u.for_s.init) {
        crb_eval_expression(inter, env, statement-&gt;u.for_s.init);
    }
    for (;;) {
        /* 检测是否满足for循环的condition */
        if (statement-&gt;u.for_s.condition) {
            cond = crb_eval_expression(inter, env, statement-&gt;u.for_s.condition);
            if (cond.type != CRB_BOOLEAN_VALUE) {
                crb_runtime_error(statement-&gt;u.for_s.condition-&gt;line_number, NOT_BOOLEAN_TYPE_ERR, MESSAGE_ARGUMENT_END);
            }
            DBG_assert(cond.type == CRB_BOOLEAN_VALUE, (&quot;cond.type..%d&quot;, cond.type));
            if (!cond.u.boolean_value)
                break;
        }
        /* 执行for循环的循环体block */
        result = crb_execute_statement_list(inter, env, statement-&gt;u.for_s.block -&gt;statement_list);

        /* 检测是否需要返回 */
        if (result.type == RETURN_STATEMENT_RESULT) {
            break;
        }
        /* 检测是否需要中断循环 */
        else if (result.type == BREAK_STATEMENT_RESULT) {
            result.type = NORMAL_STATEMENT_RESULT;
            break;
        }

        /* 对for循环的post表达式求值 */
        if (statement-&gt;u.for_s.post) {
            crb_eval_expression(inter, env, statement-&gt;u.for_s.post);
        }
    }

    return result;
}
</code></pre>
<h2>其他语句</h2>
<p>其他语句与上述语句类似，不再赘述。</p>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/Compiler/自制编程语言/crowbar源码阅读笔记(5).html">
                    crowbar源码阅读笔记(5):表达式求值
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        大道
                      </a>
                    </li>
                    <li>
                      <a href="">
                        编译原理
                      </a>
                    </li>
                    <li>
                      <a href="">
                        自制编程语言
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#编译原理">
                    <span class="tag is-info">
                      编译原理
                    </span>
                  </a>
                  <a href="tags.html#自制编程语言">
                    <span class="tag is-info">
                      自制编程语言
                    </span>
                  </a>
                  <a href="tags.html#crowbar">
                    <span class="tag is-info">
                      crowbar
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-08-20
                </p>
              </div>
              <div class="content article-body">
                <p>这是《自制编程语言》一书中的脚本语言<code>crowbar</code>的源码阅读笔记(5):表达式求值。表达式求值的实现代码主要存放于文件<code>eval.c</code>中。</p>
<h2>表达式求值算法的总体框架</h2>
<p>根据表达式的类型的不同，执行不同的求值算法，然后返回一个<code>CRB_Value</code>类型。</p>
<pre><code class="language-c">static CRB_Value eval_expression(CRB_Interpreter *inter, LocalEnvironment *env, Expression *expr)
{
    CRB_Value   v;
    switch (expr-&gt;type) {
    case BOOLEAN_EXPRESSION:
        v = eval_boolean_expression(expr-&gt;u.boolean_value);
        break;
    case INT_EXPRESSION:
        v = eval_int_expression(expr-&gt;u.int_value);
        break;
    case DOUBLE_EXPRESSION:
        v = eval_double_expression(expr-&gt;u.double_value);
        break;
    case STRING_EXPRESSION:
        v = eval_string_expression(inter, expr-&gt;u.string_value);
        break;
    case IDENTIFIER_EXPRESSION:
        v = eval_identifier_expression(inter, env, expr);
        break;
    case ASSIGN_EXPRESSION:
        v = eval_assign_expression(inter, env, expr-&gt;u.assign_expression.variable, expr-&gt;u.assign_expression.operand);
        break;
    case ADD_EXPRESSION:        /* FALLTHRU */
    case SUB_EXPRESSION:        /* FALLTHRU */
    case MUL_EXPRESSION:        /* FALLTHRU */
    case DIV_EXPRESSION:        /* FALLTHRU */
    case MOD_EXPRESSION:        /* FALLTHRU */
    case EQ_EXPRESSION: /* FALLTHRU */
    case NE_EXPRESSION: /* FALLTHRU */
    case GT_EXPRESSION: /* FALLTHRU */
    case GE_EXPRESSION: /* FALLTHRU */
    case LT_EXPRESSION: /* FALLTHRU */
    case LE_EXPRESSION:
        v = crb_eval_binary_expression(inter, env, expr-&gt;type, expr-&gt;u.binary_expression.left, expr-&gt;u.binary_expression.right);
        break;
    case LOGICAL_AND_EXPRESSION:/* FALLTHRU */
    case LOGICAL_OR_EXPRESSION:
        v = eval_logical_and_or_expression(inter, env, expr-&gt;type, expr-&gt;u.binary_expression.left, expr-&gt;u.binary_expression.right);
        break;
    case MINUS_EXPRESSION:
        v = crb_eval_minus_expression(inter, env, expr-&gt;u.minus_expression);
        break;
    case FUNCTION_CALL_EXPRESSION:
        v = eval_function_call_expression(inter, env, expr);
        break;
    case NULL_EXPRESSION:
        v = eval_null_expression();
        break;
    case EXPRESSION_TYPE_COUNT_PLUS_1:  /* FALLTHRU */
    default:
        DBG_panic((&quot;bad case. type..%d\n&quot;, expr-&gt;type));
    }
    return v;
}
</code></pre>
<p>以整型表达式为例，创建一个<code>CRB_Value</code>变量，然后设置其<code>type</code>，填充<code>u</code>成员的<code>int_value</code>字段为指定值：</p>
<!-- more -->
<pre><code class="language-c">static CRB_Value eval_int_expression(int int_value)
{
    CRB_Value   v;

    v.type = CRB_INT_VALUE;
    v.u.int_value = int_value;

    return v;
}
</code></pre>
<p>布尔型表达式求值也是类似的，创建一个<code>CRB_Value</code>变量，然后设置其<code>type</code>，填充<code>u</code>成员的<code>boolean_value</code>字段为指定<code>CRB_Boolean</code>值：</p>
<pre><code class="language-c">static CRB_Value eval_boolean_expression(CRB_Boolean boolean_value)
{
    CRB_Value   v;
    v.type = CRB_BOOLEAN_VALUE;
    v.u.boolean_value = boolean_value;
    return v;
}
</code></pre>
<p>类似的还有浮点型表达式求值、字符串型表达式求值。</p>
<h2>标识符表达式求值</h2>
<pre><code class="language-c">static CRB_Value eval_identifier_expression(CRB_Interpreter *inter, LocalEnvironment *env, Expression *expr)
{
    CRB_Value   v;
    Variable    *vp;

    vp = crb_search_local_variable(env, expr-&gt;u.identifier);
    if (vp != NULL) {
        v = vp-&gt;value;
    } else {
        vp = search_global_variable_from_env(inter, env, expr-&gt;u.identifier);
        if (vp != NULL) {
            v = vp-&gt;value;
        } else {
            crb_runtime_error(expr-&gt;line_number, VARIABLE_NOT_FOUND_ERR,
                              STRING_MESSAGE_ARGUMENT,
                              &quot;name&quot;, expr-&gt;u.identifier,
                              MESSAGE_ARGUMENT_END);
        }
    }
    refer_if_string(&amp;v);

    return v;
}
</code></pre>
<h2>赋值表达式求值</h2>
<p>赋值表达式求值非常简单：</p>
<ul>
<li>先求出等号右部的表达式的值</li>
<li>尝试搜寻指定标识符对应的变量，找不到就在指定环境中创建一个变量。</li>
<li>然后将等号左边的变量值修改为计算出来的值。</li>
</ul>
<pre><code class="language-c">static CRB_Value eval_assign_expression(CRB_Interpreter *inter, LocalEnvironment *env, char *identifier, Expression *expression)
{
    CRB_Value   v;
    Variable    *left;

    v = eval_expression(inter, env, expression);

    left = crb_search_local_variable(env, identifier);
    if (left == NULL) {
        left = search_global_variable_from_env(inter, env, identifier);
    }
    if (left != NULL) {
        release_if_string(&amp;left-&gt;value);
        left-&gt;value = v;
        refer_if_string(&amp;v);
    } else {
        if (env != NULL) {
            crb_add_local_variable(env, identifier, &amp;v);
        } else {
            CRB_add_global_variable(inter, identifier, &amp;v);
        }
        refer_if_string(&amp;v);
    }

    return v;
}
</code></pre>
<h2><code>BinaryExpression</code> 求值</h2>
<p>根据参与运算的<code>left</code>和<code>right</code>类型，又可以分为布尔型、整型、浮点型、字符串型等</p>
<h3>布尔型 <code>BinaryExpression</code></h3>
<p>它的求值方法非常简单，即根据左右表达式是否相等来返回结果：</p>
<pre><code class="language-c">static CRB_Boolean eval_binary_boolean(CRB_Interpreter *inter, ExpressionType operator, CRB_Boolean left, CRB_Boolean right, int line_number)
{
    CRB_Boolean result;

    if (operator == EQ_EXPRESSION) {
        result = left == right;
    } else if (operator == NE_EXPRESSION) {
        result = left != right;
    } else {
        char *op_str = crb_get_operator_string(operator);
        crb_runtime_error(line_number, NOT_BOOLEAN_OPERATOR_ERR, STRING_MESSAGE_ARGUMENT, &quot;operator&quot;, op_str, MESSAGE_ARGUMENT_END);
    }

    return result;
}
</code></pre>
<h3>逻辑<code>BinaryExpression</code>表达式求值</h3>
<p>逻辑表达式总体来说采用的是递归法求解：</p>
<ul>
<li>先递归求解出<code>left_value</code>，根据运算符的不同，判断是否触发短路，是则不再进一步求解</li>
<li>否则，再递归求解出<code>right_value</code></li>
<li>然后根据<code>left_value</code>和<code>right_value</code>求解出最终的值。</li>
</ul>
<pre><code class="language-c">static CRB_Value eval_logical_and_or_expression(CRB_Interpreter *inter, LocalEnvironment *env, ExpressionType operator, Expression *left, Expression *right)
{
    CRB_Value   left_val;
    CRB_Value   right_val;
    CRB_Value   result;
    result.type = CRB_BOOLEAN_VALUE;

    /* left_value 求解 */
    left_val = eval_expression(inter, env, left);

    if (left_val.type != CRB_BOOLEAN_VALUE) { crb_runtime_error(left-&gt;line_number, NOT_BOOLEAN_TYPE_ERR, MESSAGE_ARGUMENT_END); }

    /* 测试是否触发短路逻辑 */
    if (operator == LOGICAL_AND_EXPRESSION) {
        if (!left_val.u.boolean_value) { result.u.boolean_value = CRB_FALSE; return result; }
    } 
    else if (operator == LOGICAL_OR_EXPRESSION) {
        if (left_val.u.boolean_value) { result.u.boolean_value = CRB_TRUE; return result; }
    }
    else {
        DBG_panic((&quot;bad operator..%d\n&quot;, operator));
    }

    /* right_value 求解 */
    right_val = eval_expression(inter, env, right);
    if (right_val.type != CRB_BOOLEAN_VALUE) {
        crb_runtime_error(right-&gt;line_number, NOT_BOOLEAN_TYPE_ERR, MESSAGE_ARGUMENT_END); 
    }

    result.u.boolean_value = right_val.u.boolean_value;
    return result;
}
</code></pre>
<h3>整型 <code>BinaryExpression</code> 求值</h3>
<p>整型表达式的左右表达式均为整型。其求值结果可能是整型，也可能是布尔型。比如：</p>
<ul>
<li><code>3+4</code>这个表达式的结果为整型</li>
<li><code>3&gt;4</code>这个表达式的结果为布尔假值。</li>
</ul>
<p>求值的时候，需要针对每种情况区别对待：</p>
<ul>
<li>当运算符为 <strong>数学运算符</strong>，比如<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>，求值结果整型</li>
<li>当运算符为 <strong>比较运算符</strong>，比如<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>==</code>、<code>!=</code>，求值结果为布尔值。</li>
</ul>
<pre><code class="language-c">static void eval_binary_int(CRB_Interpreter *inter, ExpressionType operator, int left, int right, CRB_Value *result, int line_number) 
{
    if (dkc_is_math_operator(operator)) { result-&gt;type = CRB_INT_VALUE; } 
    else if (dkc_is_compare_operator(operator)) { result-&gt;type = CRB_BOOLEAN_VALUE; } 
    else { DBG_panic((&quot;operator..%d\n&quot;, operator)); }

    switch (operator) {
    case BOOLEAN_EXPRESSION:    /* FALLTHRU */
    case INT_EXPRESSION:        /* FALLTHRU */
    case DOUBLE_EXPRESSION:     /* FALLTHRU */
    case STRING_EXPRESSION:     /* FALLTHRU */
    case IDENTIFIER_EXPRESSION: /* FALLTHRU */
    case ASSIGN_EXPRESSION:
        DBG_panic((&quot;bad case...%d&quot;, operator));
        break;
    case ADD_EXPRESSION:
        result-&gt;u.int_value = left + right;
        break;
    case SUB_EXPRESSION:
        result-&gt;u.int_value = left - right;
        break;
    case MUL_EXPRESSION:
        result-&gt;u.int_value = left * right;
        break;
    case DIV_EXPRESSION:
        result-&gt;u.int_value = left / right;
        break;
    case MOD_EXPRESSION:
        result-&gt;u.int_value = left % right;
        break;
    case LOGICAL_AND_EXPRESSION:        /* FALLTHRU */
    case LOGICAL_OR_EXPRESSION:
        DBG_panic((&quot;bad case...%d&quot;, operator));
        break;
    case EQ_EXPRESSION:
        result-&gt;u.boolean_value = left == right;
        break;
    case NE_EXPRESSION:
        result-&gt;u.boolean_value = left != right;
        break;
    case GT_EXPRESSION:
        result-&gt;u.boolean_value = left &gt; right;
        break;
    case GE_EXPRESSION:
        result-&gt;u.boolean_value = left &gt;= right;
        break;
    case LT_EXPRESSION:
        result-&gt;u.boolean_value = left &lt; right;
        break;
    case LE_EXPRESSION:
        result-&gt;u.boolean_value = left &lt;= right;
        break;
    case MINUS_EXPRESSION:              /* FALLTHRU */
    case FUNCTION_CALL_EXPRESSION:      /* FALLTHRU */
    case NULL_EXPRESSION:               /* FALLTHRU */
    case EXPRESSION_TYPE_COUNT_PLUS_1:  /* FALLTHRU */
    default:
        DBG_panic((&quot;bad case...%d&quot;, operator));
    }
}
</code></pre>
<h3>浮点型 <code>BinaryExpression</code> 求值</h3>
<p>浮点型 <code>BinaryExpression</code> 与整型 <code>BinaryExpression</code> 求值过程类似，根据运算符的类型，要按浮点型和布尔型区别对待。</p>
<pre><code class="language-c">static void eval_binary_double(CRB_Interpreter *inter, ExpressionType operator, double left, double right, CRB_Value *result, int line_number) 
{
    if (dkc_is_math_operator(operator)) { result-&gt;type = CRB_DOUBLE_VALUE; } 
    else if (dkc_is_compare_operator(operator)) { result-&gt;type = CRB_BOOLEAN_VALUE; }
    else { DBG_panic((&quot;operator..%d\n&quot;, operator)); }

    switch (operator) {
    case BOOLEAN_EXPRESSION:    /* FALLTHRU */
    case INT_EXPRESSION:        /* FALLTHRU */
    case DOUBLE_EXPRESSION:     /* FALLTHRU */
    case STRING_EXPRESSION:     /* FALLTHRU */
    case IDENTIFIER_EXPRESSION: /* FALLTHRU */
    case ASSIGN_EXPRESSION:
        DBG_panic((&quot;bad case...%d&quot;, operator));
        break;
    case ADD_EXPRESSION:
        result-&gt;u.double_value = left + right;
        break;
    case SUB_EXPRESSION:
        result-&gt;u.double_value = left - right;
        break;
    case MUL_EXPRESSION:
        result-&gt;u.double_value = left * right;
        break;
    case DIV_EXPRESSION:
        result-&gt;u.double_value = left / right;
        break;
    case MOD_EXPRESSION:
        result-&gt;u.double_value = fmod(left, right);
        break;
    case LOGICAL_AND_EXPRESSION:        /* FALLTHRU */
    case LOGICAL_OR_EXPRESSION:
        DBG_panic((&quot;bad case...%d&quot;, operator));
        break;
    case EQ_EXPRESSION:
        result-&gt;u.int_value = left == right;
        break;
    case NE_EXPRESSION:
        result-&gt;u.int_value = left != right;
        break;
    case GT_EXPRESSION:
        result-&gt;u.int_value = left &gt; right;
        break;
    case GE_EXPRESSION:
        result-&gt;u.int_value = left &gt;= right;
        break;
    case LT_EXPRESSION:
        result-&gt;u.int_value = left &lt; right;
        break;
    case LE_EXPRESSION:
        result-&gt;u.int_value = left &lt;= right;
        break;
    case MINUS_EXPRESSION:              /* FALLTHRU */
    case FUNCTION_CALL_EXPRESSION:      /* FALLTHRU */
    case NULL_EXPRESSION:               /* FALLTHRU */
    case EXPRESSION_TYPE_COUNT_PLUS_1:  /* FALLTHRU */
    default:
        DBG_panic((&quot;bad default...%d&quot;, operator));
    }
}
</code></pre>
<h3>通用<code>BinaryExpression</code>的求值策略</h3>
<p>通用的<code>BinaryExpression</code>策略是采用递归法求解的：</p>
<ul>
<li>先递归求解<code>left</code>表达式的值<code>left_value</code></li>
<li>再递归求解<code>right</code>表达式的值<code>right_value</code></li>
<li>然后根据<code>left_value</code>和<code>right_value</code>的具体类型，分情况求解出最终的值。</li>
</ul>
<pre><code class="language-c">CRB_Value crb_eval_binary_expression(CRB_Interpreter *inter, LocalEnvironment *env, ExpressionType operator, Expression *left, Expression *right)
{
    CRB_Value   left_val;
    CRB_Value   right_val;
    CRB_Value   result;

    left_val = eval_expression(inter, env, left);
    right_val = eval_expression(inter, env, right);

    /* 整型 BinaryExpression 求解 */
    if (left_val.type == CRB_INT_VALUE &amp;&amp; right_val.type == CRB_INT_VALUE) {
        eval_binary_int(inter, operator, left_val.u.int_value, right_val.u.int_value, &amp;result, left-&gt;line_number);
    } 
    /* 浮点型 BinaryExpression */
    else if (left_val.type == CRB_DOUBLE_VALUE &amp;&amp; right_val.type == CRB_DOUBLE_VALUE) {
        eval_binary_double(inter, operator, left_val.u.double_value, right_val.u.double_value, &amp;result, left-&gt;line_number);
    }
    /* 浮点型 BinaryExpression */
    else if (left_val.type == CRB_INT_VALUE &amp;&amp; right_val.type == CRB_DOUBLE_VALUE) {
        left_val.u.double_value = left_val.u.int_value;
        eval_binary_double(inter, operator, left_val.u.double_value, right_val.u.double_value, &amp;result, left-&gt;line_number);
    }
    /* 浮点型 BinaryExpression */
    else if (left_val.type == CRB_DOUBLE_VALUE &amp;&amp; right_val.type == CRB_INT_VALUE) {
        right_val.u.double_value = right_val.u.int_value;
        eval_binary_double(inter, operator, left_val.u.double_value, right_val.u.double_value, &amp;result, left-&gt;line_number);
    }
    /* 布尔型 BinaryExpression */
    else if (left_val.type == CRB_BOOLEAN_VALUE &amp;&amp; right_val.type == CRB_BOOLEAN_VALUE) {
        result.type = CRB_BOOLEAN_VALUE;
        result.u.boolean_value = eval_binary_boolean(inter, operator, left_val.u.boolean_value, right_val.u.boolean_value, left-&gt;line_number);
    } 
    /* 字符串拼接 */
    else if (left_val.type == CRB_STRING_VALUE &amp;&amp; operator == ADD_EXPRESSION) {
        char    buf[LINE_BUF_SIZE];
        CRB_String *right_str;

        if (right_val.type == CRB_INT_VALUE) {
            sprintf(buf, &quot;%d&quot;, right_val.u.int_value);
            right_str = crb_create_crowbar_string(inter, MEM_strdup(buf));
        } else if (right_val.type == CRB_DOUBLE_VALUE) {
            sprintf(buf, &quot;%f&quot;, right_val.u.double_value);
            right_str = crb_create_crowbar_string(inter, MEM_strdup(buf));
        } else if (right_val.type == CRB_BOOLEAN_VALUE) {
            if (right_val.u.boolean_value) {
                right_str = crb_create_crowbar_string(inter, MEM_strdup(&quot;true&quot;));
            } else {
                right_str = crb_create_crowbar_string(inter, MEM_strdup(&quot;false&quot;));
            }
        } else if (right_val.type == CRB_STRING_VALUE) {
            right_str = right_val.u.string_value;
        } else if (right_val.type == CRB_NATIVE_POINTER_VALUE) {
            sprintf(buf, &quot;(%s:%p)&quot;, right_val.u.native_pointer.info-&gt;name, right_val.u.native_pointer.pointer);
            right_str = crb_create_crowbar_string(inter, MEM_strdup(buf));
        } else if (right_val.type == CRB_NULL_VALUE) {
            right_str = crb_create_crowbar_string(inter, MEM_strdup(&quot;null&quot;));
        } 
        result.type = CRB_STRING_VALUE;
        result.u.string_value = chain_string(inter, left_val.u.string_value, right_str);
    }
    /* 字符串比较大小 */
    else if (left_val.type == CRB_STRING_VALUE &amp;&amp; right_val.type == CRB_STRING_VALUE) {
        result.type = CRB_BOOLEAN_VALUE;
        result.u.boolean_value = eval_compare_string(operator, &amp;left_val, &amp;right_val, left-&gt;line_number);
    }
    /* 空值 */
    else if (left_val.type == CRB_NULL_VALUE || right_val.type == CRB_NULL_VALUE) {
        result.type = CRB_BOOLEAN_VALUE;
        result.u.boolean_value = eval_binary_null(inter, operator, &amp;left_val, &amp;right_val, left-&gt;line_number);
    } 
    /* 报错 */
    else {
        char *op_str = crb_get_operator_string(operator);
        crb_runtime_error(left-&gt;line_number, BAD_OPERAND_TYPE_ERR, STRING_MESSAGE_ARGUMENT, &quot;operator&quot;, op_str, MESSAGE_ARGUMENT_END);
    }

    return result;
}
</code></pre>
<h2>函数调用表达式求值</h2>
<p>函数调用表达式根据函数类型分为两种， <strong>原生函数调用</strong> 和 <strong>crowbar函数调用</strong> ，根据函数类型的不同，再选择性地调用<code>call_native_function()</code>或<code>call_crowbar_function()</code>:</p>
<pre><code class="language-c">static CRB_Value eval_function_call_expression(CRB_Interpreter *inter, LocalEnvironment *env, Expression *expr)
{
    CRB_Value           value;
    FunctionDefinition  *func;
    
    char *identifier = expr-&gt;u.function_call_expression.identifier;

    func = crb_search_function(identifier);
    if (func == NULL) {
        crb_runtime_error(expr-&gt;line_number, FUNCTION_NOT_FOUND_ERR, STRING_MESSAGE_ARGUMENT, &quot;name&quot;, identifier, MESSAGE_ARGUMENT_END);
    }
    switch (func-&gt;type) {
        case CROWBAR_FUNCTION_DEFINITION:
            value = call_crowbar_function(inter, env, expr, func);
            break;
        case NATIVE_FUNCTION_DEFINITION:
            value = call_native_function(inter, env, expr, func-&gt;u.native_f.proc);
            break;
        default:
            DBG_panic((&quot;bad case..%d\n&quot;, func-&gt;type));
    }

    return value;
}
</code></pre>
<p>原生函数调用的求值过程非常简单，因为原生函数实际上<code>C</code>语言编写的封装类型，通过指针，就可以直接调用：</p>
<pre><code class="language-c">static CRB_Value call_native_function(CRB_Interpreter *inter, LocalEnvironment *env, Expression *expr, CRB_NativeFunctionProc *proc)
{
    CRB_Value   value;
    int         arg_count;
    ArgumentList        *arg_p;
    CRB_Value   *args;
    int         i;

    /* 原生函数的参数个数 */
    for (arg_count = 0, arg_p = expr-&gt;u.function_call_expression.argument;
         arg_p; arg_p = arg_p-&gt;next) {
        arg_count++;
    }

    /* 原生函数的参数数组 */
    args = MEM_malloc(sizeof(CRB_Value) * arg_count);
    for (arg_p = expr-&gt;u.function_call_expression.argument, i = 0; arg_p; arg_p = arg_p-&gt;next, i++)
    {
        args[i] = eval_expression(inter, env, arg_p-&gt;expression);
    }

    /* 通过函数指针调用原生函数 */
    value = proc(inter, arg_count, args);

    /* 释放参数数组的内存 */
    for (i = 0; i &lt; arg_count; i++) {
        release_if_string(&amp;args[i]);
    }
    MEM_free(args);

    return value;
}
</code></pre>
<p>而利用<code>crowbar</code>脚本语言编写的脚本，则相对复杂一点；</p>
<ul>
<li>要为函数创建一个局部环境，然后把相关参数注册到该环境中，</li>
<li>然后再执行函数体中的语句列表</li>
<li>最后释放局部环境并返回最终结果</li>
</ul>
<pre><code class="language-c">static CRB_Value call_crowbar_function(CRB_Interpreter *inter, LocalEnvironment *env, Expression *expr, FunctionDefinition *func)
{
    CRB_Value   value;
    StatementResult     result;
    ArgumentList        *arg_p;
    ParameterList       *param_p;
    LocalEnvironment    *local_env;

    /* 创建一个局部环境，把相关参数添加到该局部环境中 */
    local_env = alloc_local_environment();
    for(arg_p = expr-&gt;u.function_call_expression.argument, param_p = func-&gt;u.crowbar_f.parameter; 
        arg_p;
        arg_p = arg_p-&gt;next, param_p = param_p-&gt;next) 
    {
        CRB_Value arg_val;

        if (param_p == NULL) {
            crb_runtime_error(expr-&gt;line_number, ARGUMENT_TOO_MANY_ERR, MESSAGE_ARGUMENT_END);
        }
        arg_val = eval_expression(inter, env, arg_p-&gt;expression);
        crb_add_local_variable(local_env, param_p-&gt;name, &amp;arg_val);
    }
    if (param_p) {
        crb_runtime_error(expr-&gt;line_number, ARGUMENT_TOO_FEW_ERR, MESSAGE_ARGUMENT_END);
    }

    /* 执行函数体 */
    result = crb_execute_statement_list(inter, local_env, func-&gt;u.crowbar_f.block -&gt;statement_list);

    if (result.type == RETURN_STATEMENT_RESULT) { value = result.u.return_value; } 
    else { value.type = CRB_NULL_VALUE; }

    dispose_local_environment(inter, local_env);

    return value;
}
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/Compiler/自制编程语言/crowbar源码阅读笔记(2).html">
                    crowbar源码阅读笔记(2):变量管理
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        大道
                      </a>
                    </li>
                    <li>
                      <a href="">
                        编译原理
                      </a>
                    </li>
                    <li>
                      <a href="">
                        自制编程语言
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#编译原理">
                    <span class="tag is-info">
                      编译原理
                    </span>
                  </a>
                  <a href="tags.html#自制编程语言">
                    <span class="tag is-info">
                      自制编程语言
                    </span>
                  </a>
                  <a href="tags.html#crowbar">
                    <span class="tag is-info">
                      crowbar
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-08-19
                </p>
              </div>
              <div class="content article-body">
                <p>这是《自制编程语言》一书中的脚本语言<code>crowbar</code>的源码阅读笔记(2):变量管理</p>
<h2>变量管理</h2>
<p>在第一篇《crowbar源码阅读笔记(1):基本的数据结构》中提到，变量有两个基本属性：变量名、变量值。变量之间采用链表的形式组织。相应环境(局部、全局)下有各自的一批变量。</p>
<h3>注册变量</h3>
<p>在一个局部环境中注册变量，需要告知该环境对象需要登记的 <strong>标识符</strong> 和 <strong>变量值</strong>，然后<code>crowbar</code>会在内存中创建一个变量对象，填好<code>name</code>和<code>value</code>，然后把它作为环境变量链表的第一个节点 ：</p>
<pre><code class="language-c">void crb_add_local_variable(LocalEnvironment *env, char *identifier, CRB_Value *value)
{
    /* 分配内存，创建新的变量 */
    Variable    *new_variable;
    new_variable = MEM_malloc(sizeof(Variable));
    new_variable-&gt;name = identifier;
    new_variable-&gt;value = *value;

    /* 把原链表第一个节点作为新增变量的下一个节点 */
    new_variable-&gt;next = env-&gt;variable;
    /* 修改环境变量链表：设置新增变量为环境变量链表的第一个节点 */
    env-&gt;variable = new_variable;
}
</code></pre>
<p>注册全局变量也是类似的过程：</p>
<!-- more -->
<pre><code class="language-c">void CRB_add_global_variable(CRB_Interpreter *inter, char *identifier, CRB_Value *value)
{
    Variable    *new_variable;

    new_variable = crb_execute_malloc(inter, sizeof(Variable));

    /* 设置新增变量的name */
    new_variable-&gt;name = crb_execute_malloc(inter, strlen(identifier) + 1);
    strcpy(new_variable-&gt;name, identifier);

    /* 把原链表第一个节点作为新增变量的下一个节点 */
    new_variable-&gt;next = inter-&gt;variable;
    /* 修改环境变量链表：设置新变量为环境变量链表的第一个节点 */
    inter-&gt;variable = new_variable;

    /* 设置新增变量的value */
    new_variable-&gt;value = *value;
}
</code></pre>
<p>从上文可以看出，每次想向相应的环境(局部或者全局)新增变量，<code>crowbar</code>都会把新增的变量放到变量链表的首位。</p>
<h3>变量解析</h3>
<p>上文说到，<code>crowbar</code>以链表的方式组织相应环境中的变量，故变量解析也是直接从头开始遍历<code>Varible</code>链表，检查链表相应节点的变量名是否和相应的标识符一致，其实现非常简单：</p>
<pre><code class="language-c">
/* 在局部环境中搜索标识符 */
Variable * crb_search_local_variable(LocalEnvironment *env, char *identifier) {
    Variable    *pos;
    if (env == NULL) return NULL;
    for (pos = env-&gt;variable; pos; pos = pos-&gt;next) {
        if (!strcmp(pos-&gt;name, identifier))
            break;
    }
    if (pos == NULL) { return NULL; } 
    else { return pos; }
}

/* 在全局环境中搜索标识符 */
Variable * crb_search_global_variable(CRB_Interpreter *inter, char *identifier)
{
    Variable    *pos;

    for (pos = inter-&gt;variable; pos; pos = pos-&gt;next) {
        if (!strcmp(pos-&gt;name, identifier))
            return pos;
    }

    return NULL;
}
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/Compiler/自制编程语言/crowbar源码阅读笔记(1).html">
                    crowbar源码阅读笔记(1):基本的数据结构
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        大道
                      </a>
                    </li>
                    <li>
                      <a href="">
                        编译原理
                      </a>
                    </li>
                    <li>
                      <a href="">
                        自制编程语言
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#编译原理">
                    <span class="tag is-info">
                      编译原理
                    </span>
                  </a>
                  <a href="tags.html#自制编程语言">
                    <span class="tag is-info">
                      自制编程语言
                    </span>
                  </a>
                  <a href="tags.html#crowbar">
                    <span class="tag is-info">
                      crowbar
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-08-18
                </p>
              </div>
              <div class="content article-body">
                <p>这是《自制编程语言》一书中的脚本语言<code>crowbar</code>的源码阅读笔记(1):基本的数据结构。</p>
<p><code>crowbar</code>语言由<code>C</code>语言编写，分为以下三个独立模块:</p>
<ul>
<li><code>CRB</code>：<code>crowbar</code> 主程序</li>
<li><code>MEM</code>: 通用内存管理模块，源码位于<code>memory/</code>目录下</li>
<li><code>DBG</code>: 通用<code>Debug</code>模块，源码位于<code>debug/</code>目录下</li>
</ul>
<h2><code>CRB</code>解释器接口</h2>
<p><code>CRB.h</code>是解释器的接口文件：</p>
<pre><code class="language-c">/* 创建解释器 */
CRB_Interpreter *CRB_create_interpreter(void);

/* 使用解释器编译文件 */
void CRB_compile(CRB_Interpreter *interpreter, FILE *fp);

/* 使用解释器解释 */
void CRB_interpret(CRB_Interpreter *interpreter);

/* 回收解释器 */
void CRB_dispose_interpreter(CRB_Interpreter *interpreter);
</code></pre>
<h2><code>CRB</code>解释器扩展接口</h2>
<p>为了扩展解释器，可以使用解释器的开发接口：<code>CRB_dev.h</code>。这个接口规定了<code>crowbar</code>这门语言的值类型和扩展接口。</p>
<!-- more -->
<h3>值类型</h3>
<p><code>crowbar</code>中可用的类型包括布尔型、整型、浮点型、字符串型、原生指针型、和空引用型：</p>
<pre><code class="language-c">typedef enum {
    CRB_BOOLEAN_VALUE = 1,
    CRB_INT_VALUE,
    CRB_DOUBLE_VALUE,
    CRB_STRING_VALUE,
    CRB_NATIVE_POINTER_VALUE,
    CRB_NULL_VALUE
} CRB_ValueType;
</code></pre>
<p><code>crowbar</code>中变量可以是其中任意一种类型，为了表示变量的值，可以把“值”定义为:</p>
<pre><code class="language-c">typedef struct {
    CRB_ValueType       type;
    union {
        CRB_Boolean     boolean_value;
        int             int_value;
        double          double_value;
        CRB_String      *string_value;
        CRB_NativePointer       native_pointer;
    } u;
} CRB_Value;
</code></pre>
<h3>扩展接口</h3>
<p>要为这门语言开发功能，需要使用扩展接口，<code>CRB</code>提供了以下三个函数：</p>
<pre><code class="language-c">/* 代表能返回 CRB_Value 的函数 */
typedef CRB_Value CRB_NativeFunctionProc(CRB_Interpreter *interpreter, int arg_count, CRB_Value *args);

/* 注册函数到解释器 */
void CRB_add_native_function(CRB_Interpreter *interpreter, char *name, CRB_NativeFunctionProc *proc);
/* 注册全局变量到解释器*/
void CRB_add_global_variable(CRB_Interpreter *inter, char *identifier, CRB_Value *value);
</code></pre>
<h2><code>CRB</code> 解释器</h2>
<p><code>CRB</code>解释器相关定义位于<code>crowbar.h</code>中，规定了一些列语言相关的数据结构：</p>
<ul>
<li>解释器、编译错误、运行时错误、消息参数类型、消息格式、</li>
<li>变量、标识符列表、局部环境、全局变量引用</li>
<li>表达式类型、表达式、赋值表达式、二叉表达式、函数调用表达式、</li>
<li>语句类型、语句、语句列表、块、语句结果类型、语句结果、if语句、while语句、for语句、return语句、全局语句</li>
<li>函数定义、参数列表(链表)</li>
<li>String、String Pool</li>
</ul>
<p>其中最重要的是解释器<code>CRB_Interpreter</code>：</p>
<pre><code class="language-c">struct CRB_Interpreter_tag {
    /* 在解释器生成时生成，解释器废弃时释放 */
    MEM_Storage         interpreter_storage;
    /* 运行时的存储  */
    MEM_Storage         execute_storage;
    /* 全局变量 链表 */
    Variable            *variable;
    /* 函数定义 链表 */
    FunctionDefinition  *function_list;
    /* 语句 链表 */
    StatementList       *statement_list;
    /* 当前行号 */
    int                 current_line_number;
};
</code></pre>
<h2>变量</h2>
<p>其中，<code>Varible</code>实际上指的是全局变量链表：</p>
<pre><code class="language-c">typedef struct Variable_tag {
    char        *name;
    CRB_Value   value;
    struct Variable_tag *next;
} Variable;
</code></pre>
<p>变量都很简单，自身拥有两个属性：</p>
<ul>
<li>变量名：即标识符。</li>
<li>变量值：统一为<code>CRB_Value</code>类型。</li>
</ul>
<p><code>crowbar</code>以链表的形式组织变量，依次取<code>next</code>指针即可遍历。</p>
<p>在此变量基础上，就可以表示出全局变量变量链表和局部环境:</p>
<pre><code class="language-c">typedef struct GlobalVariableRef_tag {
    Variable    *variable;
    struct GlobalVariableRef_tag *next;
} GlobalVariableRef;

typedef struct {
    Variable    *variable;
    GlobalVariableRef   *global_variable;
} LocalEnvironment;
</code></pre>
<p>变量解析即是从相应环境（局部、全局）中寻找标识符的过程，由于<code>crowbar</code>采用了链表的组织方式，其的实现机理也是直接在相应环境中从头开始遍历<code>Varible</code>链表，检查链表相应节点的变量名是否和相应的标识符一致：</p>
<pre><code class="language-c">Variable * crb_search_local_variable(LocalEnvironment *env, char *identifier);
Variable * crb_search_global_variable(CRB_Interpreter *inter, char *identifier);
</code></pre>
<h3>表达式</h3>
<p>表达式的数据结构为：</p>
<pre><code class="language-c">struct Expression_tag {
    ExpressionType type;
    int line_number;
    union {
        CRB_Boolean             boolean_value;
        int                     int_value;
        double                  double_value;
        char                    *string_value;
        char                    *identifier;
        AssignExpression        assign_expression;
        BinaryExpression        binary_expression;
        Expression              *minus_expression;
        FunctionCallExpression  function_call_expression;
    } u;
};
</code></pre>
<p>表达式有多种，比如赋值表达式：</p>
<pre><code class="language-c">typedef struct {
    char        *variable;
    Expression  *operand;
} AssignExpression;
</code></pre>
<p>二叉表达式：</p>
<pre><code class="language-c">typedef struct {
    Expression  *left;
    Expression  *right;
} BinaryExpression;
</code></pre>
<p>函数调用表达式:</p>
<pre><code class="language-c">typedef struct {
    char                *identifier;
    ArgumentList        *argument;
} FunctionCallExpression;
</code></pre>
<h3>语句、语句列表、及块</h3>
<h4>对语句、语句列表及块的抽象表示</h4>
<p>一个语句可能是表达式语句、全局语句、<code>if</code>语句、<code>while</code>语句、<code>for</code>语句、<code>return</code>语句。故可以把语句抽象为：</p>
<pre><code class="language-c">struct Statement_tag {
    StatementType       type;
    int                 line_number;
    union {
        Expression      *expression_s;
        GlobalStatement global_s;
        IfStatement     if_s;
        WhileStatement  while_s;
        ForStatement    for_s;
        ReturnStatement return_s;
    } u;
};
</code></pre>
<p>在此基础上，可以抽象出语句链表：</p>
<pre><code class="language-c">typedef struct StatementList_tag {
    Statement   *statement;
    struct StatementList_tag    *next;
} StatementList;
</code></pre>
<p>而一系列语句列表可以构成块：</p>
<pre><code class="language-c">typedef struct {
    StatementList       *statement_list;
} Block;
</code></pre>
<h4>具体分类的语句的定义</h4>
<p>不同的语句有不同的特征，需要为具体类型的语句定义特定的成员。比如<code>if</code>语句为：</p>
<pre><code class="language-c">typedef struct {
    Expression  *condition;
    Block       *then_block;
    Elsif       *elsif_list;
    Block       *else_block;
} IfStatement;
</code></pre>
<p>而用于循环的<code>while</code>语句：</p>
<pre><code class="language-c">typedef struct {
    Expression  *condition;
    Block       *block;
} WhileStatement;
</code></pre>
<p><code>for</code>语句：</p>
<pre><code class="language-c">typedef struct {
    Expression  *init;
    Expression  *condition;
    Expression  *post;
    Block       *block;
} ForStatement;
</code></pre>
<p><code>return</code>用于返回一个表达式的值：</p>
<pre><code class="language-c">typedef struct {
    Expression *return_value;
} ReturnStatement;
</code></pre>
<h3>函数定义构成的链表</h3>
<p>在定义函数之前，先要抽象出参数链表:</p>
<pre><code class="language-c">typedef struct ArgumentList_tag {
    Expression *expression;
    struct ArgumentList_tag *next;
} ArgumentList;
</code></pre>
<p>函数分为<code>CROWBAR_FUNCTION</code>和<code>NATIVE_FUNCTION</code>两种。对于前者，函数定义由参数链表和<code>block</code>构成。对于后者，实际上由<code>C</code>语言写就，故可以用一个函数指针来表示。</p>
<pre><code class="language-c">typedef struct FunctionDefinition_tag {
    char                       *name;
    FunctionDefinitionType      type;
    union {
        struct {
            ParameterList       *parameter;
            Block               *block;
        } crowbar_f;
        struct {
            CRB_NativeFunctionProc      *proc;
        } native_f;
    } u;
    struct FunctionDefinition_tag       *next;
} FunctionDefinition;
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/Python/Python-清洗-Excel-数据的一点感想.html">
                    Python 清洗 Excel 数据的一点感想
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Python
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#Python">
                    <span class="tag is-info">
                      Python
                    </span>
                  </a>
                  <a href="tags.html#Excel">
                    <span class="tag is-info">
                      Excel
                    </span>
                  </a>
                  <a href="tags.html#清洗数据">
                    <span class="tag is-info">
                      清洗数据
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-08-03
                </p>
              </div>
              <div class="content article-body">
                <p>这两年我是不大碰<code>Python</code>的，原因是我觉得搞网站、写爬虫、干自动化任务，用<code>Node.Js</code>编写速度更快、运行效率更高。但是最近在成都集中办公，作为数据组，主要工作就是要清洗数据，需要大量处理<code>Excel</code>，由于不太喜欢<code>VB</code>那啰嗦的语法，用<code>JScript</code>操作<code>Excel</code>又非常不得劲，于是不得不捡起<code>Python</code>：无他，简单，会得人多，库也就多。这两年<code>Python</code>在数据处理领域占据了绝对优势。</p>
<p>吐槽一句，这么多年来，<code>Python</code>一直以优雅自居。但是缩进语法并非表面上那样优雅，起码面对多行匿名函数的时候，始终优雅不起来。</p>
<h2>工具</h2>
<ul>
<li><code>IPython</code>是个非常有意思的工具，但是貌似不提供<code>VIM</code>的键盘模式，于是照例在<code>VSCode</code>中安装<code>Jupyter</code>插件，从而兼得编辑器和<code>IPython</code>。</li>
<li>使用<code>xlwings</code>操作<code>Excel</code></li>
</ul>
<h2>Python 操作 Excel 的一个例子</h2>
<p>需求：有一个<code>Excel</code>表，其中某个<code>Sheet</code>的结构为：</p>
<ul>
<li>井号</li>
<li>分层单位</li>
<li>层位</li>
<li>...</li>
</ul>
<p>同一个井，不同的分层单位又不通的分层方案。总记录行数约为11万，其中有大量数据的层位数据有误，但是对于同一个分层单位对同一个井的分层方案，有目前以下规律：</p>
<ol>
<li>由于<code>T3h1</code>跟下层是整合关系，故其下伏层必定是应该<code>T3a4</code>或者<code>T3a</code>。</li>
<li>如果<code>T3h1</code>之后是<code>T3a4</code>地层，且再之下的下伏层是<code>T3a</code>组内的，必定只能是<code>T3a3</code>，也就是说不能是<code>T3a1</code>或<code>T3a2</code>。</li>
<li>类似的，<code>T3a3</code>下伏层出现的<code>T3a</code>组的地层，只能是<code>T3a2</code>；<code>T3a2</code>下伏层出现的<code>T3a</code>组的地层，只能是<code>T3a1</code>。</li>
<li>任何一个层位<code>T3a${i}</code>（i=1,2,3）,都可以缺失掉，然后直接跳到其他组的层位.</li>
</ol>
<p>起初我觉得要修改的数据量不大，直接在<code>Excel</code>中手工修改，后来才发现严重低估了这个工作量，大约耗费了我20分钟，我才意识到要修改的记录量可能要到数万，于是采用编程解决。</p>
<p>编程有两种思路：一、通过相关接口直接操作<code>Excel</code>表；二、读取<code>Excel</code>内容到内存或者数据库，然后修改后存回。由于其他字段有许多<code>Excel</code>样式，故直接采用思路一。</p>
<h3>使用<code>Python</code>编写脚本</h3>
<p>尽管层位出现的各类情况很多，但是经过思考就可以发现，只要按照分层单位、深度排序，层位<code>T3a${i}</code>只能出现在<code>T3h1</code>的后四个记录里。所以基本思路是找到层位字段值是<code>T3h1</code>的记录，然后向下搜寻四个，如果是<code>T3a</code>组的层段，则根据情况修改为对应的层位记录即可。</p>
<p>起手式必然是应该打开<code>Excel</code>，读入数据：</p>
<pre><code class="language-Python">import xlwings as xw


book= xw.Book(r&quot;./地质研究_07地层分层信息 合表 201708.03.01-P2.xlsx&quot;)
sht=book.sheets[&quot;合表&quot;]
</code></pre>
<p>顺带封装下获取相应列字段的函数：</p>
<pre><code class="language-Python">def getWell(rowNumber):
    return sht.range(&quot;B&quot;+str(rowNumber)).value

def getLayerDept(rowNumber):
    return sht.range(&quot;E&quot;+str(rowNumber)).value

def getLayer(rowNumber):
    return sht.range(&quot;G&quot;+str(rowNumber)).value


</code></pre>
<p>然后是对修改后续某偏移行的层位的帮助方法：</p>
<pre><code class="language-Python">def modifyNext(well,layer_dept,currentRowNumber,offset=1,layer=&quot;T2a4&quot;):

    # 偏移行的井名
    _well= getWell(currentRowNumber+offset)
    # 偏移行的分层单位
    _layer_dept=getLayerDept(currentRowNumber+offset)
    # 偏移行的层位
    _layer=getLayer(currentRowNumber+offset)

    # 如果偏移行的井名或分层单位和给定的井位及分层单位不匹配，则什么也不做
    if(not well==_well or not layer_dept==_layer_dept):
        return

    if(_layer.startswith(&quot;T2a&quot;)):
        sht.range(&quot;G&quot;+str(currentRowNumber+offset)).value=layer
        sht.range(&quot;G&quot;+str(currentRowNumber+offset)).color=(254,226,239)
</code></pre>
<p>然后就是迭代搜查修改的主程序了：</p>
<pre><code class="language-Python">arr=sht.range(&quot;G1&quot;).expand('down').value
for (idx,value) in enumerate(arr) :
    if(value==&quot;T3h1&quot;):
        currentRowNumber=idx+1
        # 检查下一行
        if(arr[idx+1]==&quot;T2a&quot;):
            pass
        elif( arr[idx+1]==&quot;T2a4&quot; and arr[idx+2]==&quot;T2a3&quot;):
            pass
        else:
            print(&quot;!发现可疑错误：G&quot;,idx,&quot;尝试修正后续4个层位...&quot;)
            xw.Range(&quot;G&quot;+str(currentRowNumber)).color=(0,255,0)
            well=getWell(currentRowNumber)
            layer_dept=getLayerDept(currentRowNumber)
            modifyNext(well,layer_dept,currentRowNumber,1,&quot;T2a4&quot;)
            modifyNext(well,layer_dept,currentRowNumber,2,&quot;T2a3&quot;)
            modifyNext(well,layer_dept,currentRowNumber,3,&quot;T2a2&quot;)
            modifyNext(well,layer_dept,currentRowNumber,4,&quot;T2a1&quot;)

print(&quot;done&quot;)
</code></pre>
<h2>一句话总结</h2>
<p>库多真好。</p>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <div class="container">
      <div class="container has-text-centered">
        <a href="posts/page15.html">
          Previous
        </a>
        17 of 32
        <a href="posts/page17.html">
          Next
        </a>
      </div>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
       // 处理形如 <code>$E=mc^2$</code> 形式的公式
 var inlineMathNodes=document.querySelectorAll('code');
 var re=/^\$(.*)\$$/;
 for(var j=0;j<inlineMathNodes.length;j++){
   var result=re.exec(inlineMathNodes.item(j).innerText);
   if(result!==null){
	 katex.render(result[1], inlineMathNodes.item(j));
   }
 }
 function removeNode(node){
   if(node.remove){
	 node.remove();
   }else{
	 return first.parentNode.removeChild(node);
   }
 };

 // 查找所有 pre code.language-math 节点 以备筛出数据公式
 var nodes=document.querySelectorAll("pre code.language-math");
 for(var i=0;i<nodes.length;i++){
   var node=nodes.item(i);
   // 魔术标记所在行 
   try{
	 var lines = node.innerText.split('\n');
	 if((!!lines) && lines.length > 0)
	 {
	   var first = lines[0];
	   if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
		 var views = "";
		 // 逐行渲染
		 for(var k=1; k <lines.length; k++){
			 var f=lines[k];
			 views += katex.renderToString(f);
		 }
		 // 消除父级嵌套 
		 try{
		   node.innerHTML=views;
		 }catch(e){
		   // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
		   console.log('IE9 sucks',e);
		   $(tr).html(node.innerHTML);
		 }
	   }
	 }
   }
   catch(err){
	 console.log(err)
   }
 }
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>