<!DOCTYPE html><html>
  <head>

        <script type="text/javascript">
          var wsUri = "ws://localhost:8080/websocket";
      function init()
      {
        websocket = new WebSocket(wsUri);
        websocket.onclose = function(evt) { onClose(evt) };
      }
      function onClose(evt)
      {
        console.log('closing');
        websocket.close();
        document.location.reload();
      }
      window.addEventListener("load", init, false);
      </script>
            <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie/"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item is-active" href="">
            Home
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/Rust/所有权系统/所有权系统2——生命周期.html">
                    Rust所有权系统2——生命周期
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-12-29
                </p>
              </div>
              <div class="content article-body">
                <p>上文说到，<code>Rust</code>会拒绝编译认为有悬空引用的代码。从本质上说，悬空引用是对引用的生命周期(<code>lifetime</code>)管理不当引发的。所谓引用的<code>lifetime</code>，也就是引用的有效作用域，引用的<code>lifetime</code>必须要落在被引用的对象的作用域之内。</p>
<p>为了在编译期就发现悬空引用问题，就需要编译器具备能够对引用的<code>lifetime</code>进行检查能力，<code>Rust</code>编译器中负责此类工作的部分称作借用检查器（<code>borrow checker</code>）。和类型一样，大多数情况下<code>lifetime</code>是可以隐式推导的，我们并不需要手工干预，比如<code>Rust</code>可以自动推导出以下代码存在悬空引用问题：</p>
<pre><code class="language-rust">{
    let r;
    {
        let i=5;
        r=&amp;i;
    }                 // i 的作用域已经结束，r成了悬空引用
    println!(&quot;{}&quot;,r); // 妄图使用r这个引用是错的
}
</code></pre>
<p>然而有时候编译器并不能推导出来相关引用的<code>lifetime</code>，这时候需要显式地以注解的形式告诉编译器。不过需要说明的是，<code>lifetime</code>的注解并不会真的影响引用能活多久，其作用只是给编译器添加一种标注提示而已。<code>lifetime</code>的注解语法看起来稍稍有点古怪：</p>
<!-- more -->
<pre><code>&amp;'&lt;lifetime_name&gt; &lt;ref_type&gt;
</code></pre>
<p>其中，按惯例，<code>&lt;lifetime_name&gt;</code> 部分的命名通常由简短的小写字母组成，例如：</p>
<pre><code class="language-rust">&amp;'a i32;
&amp;'a mut i32;
</code></pre>
<p>除了自定义的<code>lifetime</code>之外，<code>Rust</code>还有一个很特别的静态生存期：<code>'static</code>，也就是整个程序的持续期间。比如，在<code>Rust</code>中，所有的字符串字面量都有<code>'static</code>的<code>lifetime</code>，完整的注解类似于：</p>
<pre><code class="language-rust">let s:&amp;'static str =&quot;hello,world&quot;;
</code></pre>
<h2>函数签名中的<code>lifetime</code>注解</h2>
<p>如同泛型类型参数一样，函数的泛型<code>lifetime</code>参数也需要放在尖括号<code>&lt;&gt;</code>之间。函数返回的引用，其生命周期参数需要和参数之一的生命周期相匹配。如果函数所返回的引用未引自任一参数，那么唯一的可能就是返回值引用了在函数中创建的值，这意味着一旦函数作用域结束，该值所在内存就会被回收，从而导致悬空引用。本质上，<code>lifetime</code>语法是在描述函数参数和返回值的生命周期的关联，一旦它们建立了关联关系，<code>Rust</code>编译器就有了足够的信息来允许内存安全的操作、禁止那些会产生悬空指针或者违法内存安全的事。注意的是，函数的<code>lifetime</code>注解是对函数签名而言的，与函数体并没有关系。</p>
<p>当函数返回一个引用，很可能是一件要当心的事儿。我们把函数参数的<code>lifetime</code>称之为<code>input lifetimes</code>，函数返回值的<code>lifetime</code>称之为<code>output lifetimes</code>。考虑我们有一个函数，随机返回两个参数之一：</p>
<pre><code class="language-rust">fn foo&lt;'a&gt;(p1:&amp;'a str ,p2:&amp;'a str) -&gt; &amp;'a str {
    // ...
    p1 // 假装我们随机返回了参数之一
}
</code></pre>
<p>没什么问题对不对？然而，这个函数签名实际上是在要求：调用函数的时候，务必保证接收函数返回值的变量的<code>lifetime</code>不能落在任一函数参数的<code>lifetime</code>之外：</p>
<pre><code class="language-rust">fn main() {
    let s1=String::from(&quot;hello,world&quot;);
    let result;    // 注意这里用于接收函数返回值的变量生命周期
    {
        let s2=String::from(&quot;shit happens&quot;);
        result=foo(s1.as_str(),s2.as_str());
    };
}
</code></pre>
<p>这里<code>Rust</code>会拒绝编译，因为<code>Rust</code>编译器发现第二个参数会被先于<code>result</code>回收，从而可能导致悬空引用问题：</p>
<pre><code>error[E0597]: `s2` does not live long enough
  --&gt; src\main.rs:12:5
   |
11 |         result=foo(s1.as_str(),s2.as_str());
   |                                -- borrow occurs here
12 |     };
   |     ^ `s2` dropped here while still borrowed
13 | }
   | - borrowed value needs to live until here
</code></pre>
<p>在一些情况下，<code>Rust</code>也能自动推断出函数中引用的<code>lifetime</code>，无需手工标注。考虑以下函数：</p>
<pre><code class="language-rust">fn foo(p1: &amp; str)-&gt; &amp; str{
    p1
}
</code></pre>
<p>这种写法可以通过编译吗？其实是可以的。原因在于，如果没有显式地为引用型的函数参数注解<code>lifetime</code>，则<code>Rust</code>编译器会分别为每个引用型函数参数指定一个各不相同的<code>lifetime</code>。并且，由于<code>output lifetime</code>只可能来自于<code>input lifetimes</code>，恰好这里只有一个引用型的输入参数，所以这里的<code>output lifetime</code>可以自动推导出来，从而函数签名中的所有引用的<code>lifetime</code>都可以隐式推断。类似的，以下代码也是可以省略<code>lifetime</code>注解的：</p>
<pre><code class="language-rust">fn foo(p1: &amp; str, p2:i32)-&gt; &amp; str{
    p1
}
</code></pre>
<h2><code>Struct</code>与<code>lifetime</code>注解</h2>
<p>每一个引用都有其<code>lifetime</code>，除了用在函数签名，<code>struct</code>定义也是常需要手工注解的地方：</p>
<pre><code class="language-rust">struct Foo&lt;'a&gt;{
    f1: &amp;'a str,
}

impl&lt;'a&gt; Foo&lt;'a&gt;{
    fn bar&lt;'b&gt;(&amp;self, s:&amp;'b str) -&gt; &amp;'b str{
        s
    }
}

fn main() {
    let s1=String::from(&quot;hello,world&quot;);
    let s2=String::from(&quot;hello,rust&quot;);
    let foo=Foo{
        f1:s1.as_str()
    };
    let s=foo.bar(s2.as_str());
    println!(&quot;{}&quot;,s);
}
</code></pre>
<p>得益于<code>Rust</code>编译器的自动推导，有时候我们也可以在方法签名中省略对引用的<code>lifetime</code>声明，例如：</p>
<pre><code class="language-rust">struct Foo&lt;'a&gt;{
    f1: &amp;'a str,
}

impl&lt;'a&gt; Foo&lt;'a&gt;{
    fn bar(&amp;self, s:&amp;str) -&gt; &amp; str{
        self.f1
    }
}
</code></pre>
<p>这里方法签名中，<code>&amp;self</code>的引用生命周期由编译器自动为我们指定；至于第二个参数<code>s</code>，编译器会为其指定一个单独的生命周期；由于未显式标注<code>output lifetime</code>注解，<code>Rust</code>编译器会自动把<code>self</code>的<code>lifetime</code>指定给它。这种规则使得书写方法签名更加简洁明了。</p>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Misc/写在2017的年末.html">
                    写在2017的年末
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-12-21
                </p>
              </div>
              <div class="content article-body">
                <p>又到一年年末，我决定写点什么。毕业第七年了，工作岗位换了许多，今年最大的收获是心态沉稳了很多。除了工作之外，今年主要做的两件事如下：</p>
<h2>信息自动化实验室</h2>
<p>这些年的工作让我真正明白了陆游的这首诗的含义：</p>
<blockquote>
<p>古人学问无遗力，
少壮工夫老始成。
纸上得来终觉浅，
绝知此事要躬行。</p>
</blockquote>
<p>知行合一很重要，所以年初曾设想创建单位第一个信息自动化实验室。在获得领导赞成之后，目前进度如下：</p>
<ol>
<li>腾出机房附近的一个办公室作为场地。</li>
<li>把一台淘汰下来的大华视频服务器利用起来，重做<code>CentOS</code>系统，并架设了<code>GitLab</code>服务器。已经把单位网站的三个相关项目、HSE正激励系统、和投票系统的相关代码全部托管到其上。</li>
<li>收集了数个相关升级改造项目淘汰下设备，目前已有核心层交换机1台、接入层交换机数台、PLC各类模块、DTU、RTU和一些工控设备。后期要从每年运维项目中收集光纤、网线、视频摄像头、喊话系统等。</li>
<li>在5月份用<code>Node.js</code>编写了一个简单爬虫，从国外某个用<code>WordPress</code>搭建的免费电子书网站上日夜不停地抓取<code>IT</code>领域的电子书，并部署到单位的一台闲置服务器上。目前已经下载了 105G 的pdf文件。</li>
<li>前期用<code>Node.js</code>搭建了一个内部专用的电子书网站，邀请制，结果服务器硬盘挂了。听闻一位财务上的朋友历年来购买过众多数学领域的pdf电子书，待后期与我抓取到计算机领域的电子书合并整理、重新部署。</li>
</ol>
<p>初步的架子已经有了。可惜时间太少，今年终未完成正式投用。</p>
<h2>软考中级</h2>
<p>在以前，我是无心顾及证书这类东西的，总觉得离实用场景偏远。知乎上的主流观点认为，这个认证于科班出身的程序员没什么实质用处，因为相关知识基本几乎都是本科所学；其次和甲骨文OCA、OCP之类的相比，各方面知识点偏学院派，不贴近生产实际。然而这种认证由于考纲范围涉及非常广泛，我这个半道出家的人要在备考过程中要把科班出生的基础课程从头都过一遍，所以它便有了不一样的意义。于是在今年9月初，我改变了想法，决定报考工信部组织的软件设计师水平考试(软考中级)，用了2个多月的下班时间自行学习。这几日软考中级的软件设计师成绩出来了，我查了下：上午64分，下午67分。虽说最终的合格分数线尚未公布，但是按照往年45分及格(满分75分*60%=45分)的惯例，我过线应是毫无悬念了。 <!-- more --></p>
<p>虽说只花了2个多月备考，但是其中好多知识点都是之前就较为熟悉的了，并未多花时间：</p>
<ol>
<li>面向对象、设计模式上，因为前些年自学Java的时候花过不少力气在这上面，所以几乎没有再花时间在这些方面。最后一题在C++/Java中选择了Java，大约花了不到一分钟就作答完毕了。</li>
<li>在数据库理论方面，由于很久以前读过清华大学出版的《数据库系统概论》，加上三大数据库都有在单位工作中实际操作过，所以备考时只是稍带复习了下关系代数、关系演算方面的知识，也并未多花什么时间。</li>
<li>计算机基础、网络基础、多媒体知识：由于平时工作多有接触，应付软考中级绰绰有余。</li>
<li>专业英语：阅读的底子还算不错，这些年一直不惧英文原版的技术资料。</li>
<li>标准化和法律法规：这部分知识点在软考中级分值似乎也就2分。早些年做物资采购的经验还是有点用的，什么国际标准、美标、国标、地方标准、行标、企标等各类标准，都可以在当年接触过的产品里找到对应的例子。就是法律法规有点古怪，比如考试中有一道选择题问哪个市的名字能作为商标。</li>
</ol>
<p>以下是备考时发现的短板之处——均是缺乏实践、缺乏练习的部分，虽说目前应付软考是没问题的，但是作为自我修养，我还是要引以为耻：</p>
<ol>
<li>在操作系统方面，用的是 Andrew S. Tanenbaum 教授的《现代操作系统》做备考材料。总结起来，我在操作系统方面是走马观花，缺乏实际，得空要做个简易的操作系统玩具。</li>
<li>在编译原理方面，备考用的学习材料是吕映芝老师、张素琴老师的《编译原理》(清华大学出版设)，只读完前4章；后面的知识点还是感觉较为晦涩，同样只是了解个名词和大意，幸而软设几乎只考查了原理，没有让大家写个解析器之类。目前唯一的实践是前器照着《自制编程语言》通读了由作者自制的脚本语言<code>crowbar</code>的实现源码。以后一定要做个我自己的编程语言。</li>
<li>在数据结构和算法上，约一个月的晚上时间都花在这上面，但是在算法上仍总是感觉没有成就感，心里也没什么底气——我似乎对C语言这种没有<code>GC</code>的语言有种恐惧感：每次动态<code>malloc</code>内存，我都会在心里紧张地想会不会有哪个地方忘掉了<code>free</code>。以后有得选的话，还是用<code>Java</code>来练习算法吧。</li>
<li><code>DFD</code>、<code>UML</code>等建模技术：<code>DFD</code>以前我只在设计单位的物资系统的时候用过一次。现在发现真是低估了它，在理解需求上<code>DFD</code>是很好用的建模技术。按照目前许多人的观点看来，<code>UML</code>这块算是和生产脱节的学院派知识点，我平时只用过类图、序列图、和活动图，不得不花了许多时间在这上面熟悉其他建模技术。不管是否有实际用处，权当开阔眼界。</li>
<li>最后，在软件工程方面，由于这些年工作接触了众多的信息系统和其他非软件方面项目，所以大部分知识点都很熟悉。然而仍然缺乏对各类软件开发模型、软件过程模型的实践，比如软件成熟度模型之类的知识点简直是今天记住隔天就忘了。</li>
</ol>
<h2>2018年的几个个人计划</h2>
<p>按住心中的心浮气躁，消除焦虑，日拱一卒，不期速成。</p>
<p>必须要完成的：</p>
<ol>
<li>强化数据结构与算法的相关练习，至少刷一遍《数据结构与问题求解》和《算法导论》。为日后<code>LeetCode</code>刷算法题做准备。</li>
<li>温习各类知识，加强各方面的自我修养，2018年底之前(暂定下半年)通过系统架构设计师水平考试来检验自己的掌握情况。</li>
<li>学习一门系统级编程语言，为日后写一个操作系统玩具做准备：暂定<code>Rust</code>，因为通过编译就几乎意味着内存安全。至少读完《Rust Essentials》。</li>
<li>通读<code>Bootstrap v4</code>的<code>sass</code>源码。加大<code>CSS</code>方面的练习，尤其是响应式的设计。</li>
<li>深入学习<code>WASM</code>技术。无它，<code>Mozillia</code>已经规划用<code>Rust</code>抢占<code>WASM</code>先机，很显然这块<code>Rust</code>的竞争对手只有<code>C/C++</code>。</li>
<li>控制体重在68kg以下。</li>
</ol>
<p>可选：</p>
<ol>
<li>捡起概率论、线性代数和微积分</li>
<li>学习《Practical Data Analysis》</li>
<li>学习交换机相关知识</li>
</ol>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/css/响应式网格系统的实现原理.html">
                    响应式网格系统的实现原理
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-12-03
                </p>
              </div>
              <div class="content article-body">
                <h2>响应式布局的基本原理</h2>
<p>由于CSS的覆盖特性，我们可以先写一般性的通用样式，然后再编写特殊的样式对细节进行调整。为了编写一个响应式页面，可以有两种策略：</p>
<ul>
<li>对于一个 <code>desktop-first view</code>, 应该先设置大屏幕的样式，然后根据媒体查询，依次为更小的屏幕设置样式（即根据 <code>max-width</code> 从大到小的顺序依次设置样式）</li>
<li>对于一个 <code>mobile-first view</code> , 应该先设置小屏幕样式，然后根据根据媒体查询，依次为更大的屏幕设置样式（即根据 <code>min-width</code> 从小大到大的顺序依次设置样式）</li>
</ul>
<p>设有一个<code>header</code>元素，现在采用 <code>mobile-first view</code> 策略。则其<code>CSS</code>规则可以写作: <!-- more --></p>
<pre><code class="language-CSS">header {
    width: 50%;
}
@media (min-width: 576px) {
    header {
        width: 75%;
    }
}
@media (min-width: 768px) {
    header {
        width: 100%;
    }
}
@media (min-width: 992px) {
    header {
        width: 100%;
        color: gray;
    }
}
</code></pre>
<p>直接采用<code>CSS</code>弊端很多，比如这里的最低宽度定义是硬编码。为了简便起见，可以使用<code>SCSS</code>定义一个<code>@mixin</code></p>
<pre><code class="language-SCSS">@mixin forLargerThan($media) {
    @media (min-width: $media/16+em) { 
        @content; 
    }
}
</code></pre>
<p>然后即可进行覆盖式的声明:</p>
<pre><code class="language-SCSS">header {
    width: 50%;
    // ... 其他声明
    @include forLargerThan(576) {
        width: 70%;
        // 其他声明
    }
    @include forLargerThan(768) {
        width: 100%;
        // 其他声明
    }
    @include forLargerThan(992) {
        width: 100%;
        // 其他声明
    }
}
</code></pre>
<p>类似地，我们还可以定义一个用于<code>desktop-first view</code>的<code>@mixin</code>:</p>
<pre><code class="language-SCSS">@mixin forSmallerThan($media) {
    @media (max-width: $media/16+em) { 
        @content; 
    }
}
</code></pre>
<p>然后根据屏幕尺寸上限(<code>max-width</code>)从大到小的顺序，依次设置断点即可。</p>
<h2>响应式网格系统的设计</h2>
<p>网格式并不必然和响应式挂钩，在响应式设计出现之前，就有很多网格式方案出现。为了让网格布局系统支持响应式，我们可以利用上文定义的<code>forLargerThan($media)</code>的<code>@mixin </code>，为不同大小的屏幕预定义一些样式类。这里采用12栅格的网格系统。</p>
<h3>基于 float 的网格布局</h3>
<p>实现网格布局，兼容性最好的实现方式是在同行网格之间采用<code>float</code>布局。其实现思想非常简单：</p>
<pre><code class="language-SCSS">.row{
    &amp;:before,&amp;:after { content: ''; display: table; }
    &amp;:after { clear: both; }
}

.grid {
    &amp;_1, &amp;_2, &amp;_3, &amp;_4, &amp;_5, &amp;_6, &amp;_7, &amp;_8, &amp;_9, &amp;_10, &amp;_11, &amp;_12 {
        float: left;
        margin: 0 10px;
    }
}
</code></pre>
<p>当然，上述代码只是简单定义了浮动的样式实现网格并排排列。为了适配不同尺寸的屏幕，还需要采用媒体查询定义各网格在不同屏幕下的具体宽度：</p>
<pre><code class="language-SCSS">// 先为 desktop 定义默认的样式:
.grid-container {
    width: 980px;
    padding: 0 10px;
    margin: auto;
    @include forSmallerThan(980px) { width: 768px; }
    @include forSmallerThan(768px) { width: 640px; }
    @include forSmallerThan(640px) { width: 480px; }
    @include forSmallerThan(480px) { width: 320px; padding: 0; }

    .grid_12 { 
        width: 940px; 
        @include forSmallerThan(980px) { width: 728px; }
        @include forSmallerThan(768px) { width: 600px; }
        // .... 在更小尺寸的屏幕上的宽度省略
    }

    .grid_11 { 
        // ... 不同屏幕下的宽度定义省略
    }

    // .... 其他网格

    .grid_1 { 
        width: 140px;
        @include forSmallerThan(980px){
            ...
        }
        // ...
    }
}
</code></pre>
<p>基于<code>float</code>布局最大的问题是对不同屏幕的宽度难以自动计算宽度。</p>
<h3>基于<code>flexbox</code>的网格布局</h3>
<p>为了克服<code>float</code>网格布局的缺点，可以采用<code>flexbox</code>布局作为基础实现网格系统。<code>Bootstrap v4</code> 便是采用了这一方案。</p>
<h4>尺寸命名与响应式</h4>
<p><code>Bootstrap</code>将一些屏幕尺寸称呼如下：</p>
<table>
<thead>
<tr>
<th>命名</th>
<th>最小尺寸值</th>
<th>缩写</th>
</tr>
</thead>
<tbody>
<tr>
<td>extra small</td>
<td>&lt;  576px</td>
<td>xs</td>
</tr>
<tr>
<td>small</td>
<td>&gt;= 576px</td>
<td>sm</td>
</tr>
<tr>
<td>medium</td>
<td>&gt;=768px</td>
<td>md</td>
</tr>
<tr>
<td>large</td>
<td>&gt;=992px</td>
<td>lg</td>
</tr>
<tr>
<td>extra large</td>
<td>&gt;=1200px</td>
<td>xl</td>
</tr>
</tbody>
</table>
<p>具体的<code>breakpoints</code>定义为一个<code>map</code>，预定义的<code>$breakpoints</code>为:</p>
<pre><code class="language-SCSS">$grid-breakpoints: (
    xs: 0,
    sm: 576px,
    md: 768px,
    lg: 992px,
    xl: 1200px
) !default;
</code></pre>
<p><code>Bootstrap</code>采用的是<code>mobile-first</code>策略。和<code>$forLargerThan</code>类似，<code>Bootstrap</code>定义了以下<code>@mixin</code>:</p>
<pre><code class="language-SCSS">@mixin media-breakpoint-up($name, $breakpoints: $grid-breakpoints) {

    // 获取与断点名相对应的最小宽度
    $min: breakpoint-min($name, $breakpoints);

    @if $min {
        @media (min-width: $min) {
            @content;
        }
    } @else {
        @content;
    }
}
</code></pre>
<p>这个<code>@mixin</code>允许我们为不同尺寸的屏幕定义媒体查询。更方便的是，这个<code>@mixin</code>允许采用断点名来设置断点。</p>
<h4>分栏定义</h4>
<p>预定义的栅格栏数为12：</p>
<pre><code class="language-SCSS">$grid-columns: 12 !default;
</code></pre>
<p>为了方便，定义的几个关键<code>@mixin</code>来创建容器、行、列：</p>
<pre><code class="language-SCSS">@mixin make-container() {
    width: 100%;
    padding-right: ($grid-gutter-width / 2);
    padding-left: ($grid-gutter-width / 2);
    margin-right: auto;
    margin-left: auto;
}

@mixin make-row() {
    display: flex;
    flex-wrap: wrap;
    margin-right: ($grid-gutter-width / -2);
    margin-left: ($grid-gutter-width / -2);
}

@mixin make-col($size, $columns: $grid-columns) {
    flex: 0 0 percentage($size / $columns);
    // Add a `max-width` to ensure content within each column does not blow out
    // the width of the column. Applies to IE10+ and Firefox. Chrome and Safari
    // do not appear to require this.
    max-width: percentage($size / $columns);
}
</code></pre>
<h4>响应式栅格系统</h4>
<p>要预定义样式，就是要指定每种栏在不同屏幕下的样式。显然，通过遍历<code>$grid-columns</code>和<code>$grid-breakpoints</code>即可完成:</p>
<pre><code class="language-SCSS">@mixin make-grid-columns($columns: $grid-columns, $gutter: $grid-gutter-width, $breakpoints: $grid-breakpoints) {

    // Common properties for all breakpoints
    %grid-column {
        position: relative;
        width: 100%;
        min-height: 1px; // Prevent columns from collapsing when empty
        padding-right: ($gutter / 2);
        padding-left: ($gutter / 2);
    }

    @each $breakpoint in map-keys($breakpoints) {

        // Returns a blank string if smallest breakpoint, 
        // otherwise returns the name with a dash infront
        // eg : &quot;&quot; || &quot;-sm&quot;
        $infix: breakpoint-infix($breakpoint, $breakpoints);

        // Allow columns to stretch full width below their breakpoints
        @for $i from 1 through $columns {
            .col#{$infix}-#{$i} {
                @extend %grid-column;
            }
        }

        .col#{$infix}, .col#{$infix}-auto {
            @extend %grid-column;
        }

        @include media-breakpoint-up($breakpoint, $breakpoints) {
            // Provide basic `.col-{bp}` classes for equal-width flexbox columns
            .col#{$infix} {
                flex-basis: 0;
                flex-grow: 1;
                max-width: 100%;
            }
            .col#{$infix}-auto {
                flex: 0 0 auto;
                width: auto;
                max-width: none; // Reset earlier grid tiers
            }

            @for $i from 1 through $columns {
                .col#{$infix}-#{$i} {
                    @include make-col($i, $columns);
                }
            }

            .order#{$infix}-first {
                order: -1;
            }

            @for $i from 1 through $columns {
                .order#{$infix}-#{$i} {
                    order: $i;
                }
            }

            // `$columns - 1` because offsetting by the width of an entire row isn't possible
            @for $i from 0 through ($columns - 1) {
                @if not ($infix == &quot;&quot; and $i == 0) { // Avoid emitting useless .offset-0
                    .offset#{$infix}-#{$i} {
                        @include make-col-offset($i, $columns);
                    }
                }
            }
        }
    }
}
</code></pre>
<p>最后，即可使用预设的样式类为不同尺寸的屏幕定义网格</p>
<pre><code class="language-HTML">&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-sm&quot;&gt;
            One of three columns
        &lt;/div&gt;
        &lt;div class=&quot;col-sm&quot;&gt;
            One of three columns
        &lt;/div&gt;
        &lt;div class=&quot;col-sm&quot;&gt;
            One of three columns
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>注意，这里采用的样式类是<code>col-sm</code>，而不是<code>col-sm-4</code>。由于采用<code>flexbox</code>实现，其宽度会自动设定。</p>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/DataStructureAndAlgo/最短路径算法-Floyd算法.html">
                    数据结构与算法笔记 最短路径算法——Floyd算法
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-11-02
                </p>
              </div>
              <div class="content article-body">
                <p><code>Floyd-Warshall</code> 算法也称 Floyd's 算法，是用于求解任意点对之间最短路径的算法。叫这个奇怪的名字是因为<code>Robert Floyd</code>和<code>Stephen Warshal</code>这两人在同一年(1962年)各自独立提出了这个算法。<code>Floyd-Warshall</code>算法是典型的动态规划算法。</p>
<p>对于图<code>$G=(V,E)$</code>，各顶点之间弧<code>$&lt;i,j&gt;$</code>的权重表示为<code>$weight(i,j)$</code>，当两个顶点重合时(也就是<code>$i=j$</code>)，规定<code>$weight(i,j)=0$</code>；当两个顶点之间无弧连接时，规定<code>$weight(i,j)=\infty$</code>。对于稠密图，我们可以执行<code>$|V|$</code>次<code>Dijkstra</code>算法来获取任意点对的最短路径，但是对于稀疏图，采用结构更简单的<code>Floyd</code>算法更简单。</p>
<h2>Floyd's algorithm</h2>
<p>在<code>Dijkstra</code>算法中我们指定始点为<code>$v_0$</code>，并将<code>$D_{v_0,k}(j)$</code>定义为从<code>$v_0$</code>到<code>$k$</code>只用到<code>$\{1,2,...,j\}$</code>的子集作为中间顶点的最短路径的值。现在我们把始点和终点扩展到任意点对：<code>$D_{p,q}(j)$</code>表示从始点<code>$p$</code>到终点<code>$p$</code>，期间可能经过、或者不经过、但是最多只能经过集合<code>$\{1,2,...,j\}$</code>中顶点的最短路径的长度。<!-- more --></p>
<ol>
<li>显然，当不经过其他任何中间顶点，有<code>$D_{p,q}(0)=weight(p,q)$</code></li>
<li>当<code>$k&gt;0$</code>，每次加入新的顶点<code>$k$</code>，最短路径必然只可能有以下几种情况：
<ol>
<li>最短路径还是不经过其他任何中间节点的弧<code>$&lt;p,q&gt;$</code>，故最短路径为<code>$D_{p,q}=weight(p,q)$</code>。这等同于初始情况。</li>
<li>尽管加入了顶点<code>$k$</code>，但是最短路径<code>$p \rightarrow q$</code>并不穿过顶点<code>$k$</code>，所以最短路径值仍然为<code>$D_{p,q}(k-1)$</code>。</li>
<li>加入了顶点<code>$k$</code>，有新的更短路径<code>$p \rightarrow q$</code>穿过了<code>$k$</code>。也就是最短路径由路径<code>$p \rightarrow k$</code>和<code>$k \rightarrow q$</code> 合成，在这两个分段路径中，由于<code>$k$</code>要么作为始点，要么作为终点，都不作为中间节点，故二者都只是最多只穿过了前<code>$(k-1)$</code>个顶点。即有<code>$D_{p,q}(k)= D_{p,k}(k-1)+D_{k,q}(k-1)$</code>。</li>
</ol>
</li>
</ol>
<p>综合以上情况，我们可以把<code>$D_{p,q}(k)$</code>的初值设置为<code>$D_{p,q}(0)=weight(p,q)$</code>，这样在每次迭代推算的过程中，必然就有<code>$D_{p,q}(k)=\displaystyle\min(D_{p,q}(k-1) \enspace,\enspace   D_{p,k}(k-1)+D_{k,q}(k-1) )$</code>。</p>
<p>注意，递推关系表明：经过、或者不经过、但是最多只经过中间顶点集<code>$\{1,2,3,...,k\}$</code>(规模为<code>$k$</code>)的问题可以分解为规模为<code>$k-1$</code>的问题。根据这个关系，很容易设计出相应算法。
首先引入一个集合<code>$S$</code>，表示中间顶点集。我们将按照序号从小到大的顺序，依次把顶点<code>$i\in V$</code>加入到集合<code>$S$</code>中，然后计算加入顶点<code>$i$</code>之后的各点对最短路径。经过<code>$k$</code>次加入后，集合<code>$S=\{1,2,3,...,k\}$</code>，最终当<code>$V-S=\emptyset$</code>时算法结束。为了不失一般性，我们分析图的任意两个顶点<code>$v_p$</code>和<code>$v_q$</code>，并用<code>$D[p,q]$</code>来表示从顶点<code>$p$</code>到顶点<code>$q$</code>最短路径长度。另外由于在上述过程只计算了最短路径长度，为了记录相应的路径，我们可以引入一个矩阵<code>$P[][]$</code>，其中元素<code>P[p][q]</code>表示始点<code>$p$</code>到终点<code>$p$</code>的最短路径一定经过顶点<code>$k$</code>，为了区分中间无节点的的情况，可以将其中每个元素初始化为<code>$-1$</code>。
，为了计算<code>$D[p,q]$</code>，我们需要逐步递推。</p>
<ol>
<li>在初始状态下，如果二者有弧连接，则<code>$&lt;v_p,v_q&gt;$</code>可能是最短路径（相应的路径长可能为<code>$D[p,q]=weight(p,q)$</code>）。这里说“可能”，是因为两点之间直接相连的弧的权重不一定比分段连接的弧的权重之和要小。具体是不是，还需要在后续计算过程中加以甄别，如果后续计算过程发现了比之前计算的<code>$D[p,q]$</code>更小，则更新之。如果二者之间没有弧链接，我们暂时标记<code>$D[p,q]=\infty$</code>，留待后续处理。总而言之，我们在这一步令<code>$D[p,q]=weight(p,q)$</code>。</li>
<li>根据递推关系，在每一步推算过程中，选择顶点<code>$k$</code>，准备加入到集合<code>$S$</code>，计算<code>$D[p,k]+D[k,q]$</code>，与之前的<code>$D[p,q]$</code>相比，取较小者作为新的最短路径；如果发现是<code>$D[p,k]+D[k,q]$</code>更小，同时更新<code>$P[p,q]=k$</code>表示此最短路径一定穿过中间节点<code>$k$</code>。</li>
<li>经过不停迭代，直至集合<code>$S$</code>包含了<code>$V$</code>中所有的顶点（也就是<code>$V-S=\emptyset$</code>），算法结束。</li>
</ol>
<p>那么如何根据矩阵<code>$P$</code>知道任意两点最短路径<code>$p \rightarrow q$</code>中间节点细节呢？根据<code>$P[p][q]=k$</code>知道<code>$p \rightarrow q$</code>一定穿过<code>$k$</code>，所以问题分解为<code>$P[p][k]$</code>和<code>$P[k][q]$</code>两个子问题，如此递归层层分解，直至不含中间节点即可。</p>
<h2>示例</h2>
<p>例如，有图结构如下：</p>
<pre><code>+---+                  2            +---+
|   +-------------------------------&gt;   |
| 0 |                               | 1 |
|   +----------------+              |   |
+-^-+       8        |              +-+-+
  |                  |                |
  |                +-v-+              |
  |                |   |       4      |
  |     5          | 2 &lt;--------------+
  +----------------+   |
                   +---+
</code></pre>
<ol>
<li>设置初值：<code>$S=\{\}$</code>，<code>$D=\begin{bmatrix} 0 &amp; 2 &amp; 8 \\ \infty &amp; 0 &amp; 4 \\ 5 &amp; \infty &amp; 0 \end{bmatrix}$</code></li>
<li>加入<code>$k=0$</code>：<code>$S=\{0\}$</code>。<code>$D=\begin{bmatrix} 0 &amp; 2 &amp; 8 \\ \infty &amp; 0 &amp; 4 \\ 5 &amp; \xcancel{\infty}\,7 &amp; 0 \end{bmatrix}$</code></li>
<li>加入<code>$k=1$</code>：<code>$S=\{0,1\}$</code>。<code>$D=\begin{bmatrix} 0 &amp; 2 &amp; \xcancel{8}\,6 \\ \infty &amp; 0 &amp; 4 \\ 5 &amp; 7 &amp; 0 \end{bmatrix}$</code></li>
<li>加入<code>$k=2$</code>：<code>$S=\{0,1,2\}$</code>。<code>$D=\begin{bmatrix} 0 &amp; 2 &amp; 6 \\ \xcancel{\infty}\,9 &amp; 0 &amp; 4 \\ 5 &amp; 7 &amp; 0 \end{bmatrix}$</code></li>
</ol>
<h2>算法实现</h2>
<p>说起来很啰嗦，但是代码实现非常简单，去掉初始化代码，剩下的推算过程核心只有几行：</p>
<pre><code class="language-c">// 逐步加入顶点k到集合S中
for(int k=0;k&lt;n;k++){
    // 计算新的D[p][q]
    for(int p=0;p&lt;n;p++){
        for(int q=0;q&lt;n;q++&gt;){
            // 一旦发现更短的路径，就更新到D[p][q]中
            if(D[p][q] &gt; D[p][k]+D[k][q]){ 
                D[p][q] = D[p][k]+D[k][q]; 
                P[p][q]=k;
            }
        }
    }
}
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/DataStructureAndAlgo/最短路径算法-Dijkstra算法.html">
                    数据结构与算法笔记 最短路径算法——Dijkstra算法
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-11-01
                </p>
              </div>
              <div class="content article-body">
                <p>最短路径算法分为单源点到任意点的最短路径算法和任意点对之间的最短路径算法。对于简单的无权值的图，求其最短路径等同于按照深度进行遍历，此处不予赘述。求最短路径，就是要找到这样一条路径，该路径之上的边的权值之和最小。第一个顶点称之为源点(<code>Source</code>)，最后一个顶点称之为终点(<code>Destination</code>)。</p>
<h2>Dijkstra's algorithm</h2>
<p>对于指定的单源点(设起始点为<code>$v_0$</code>)到任意点的最短路径问题，Dijkstra 给出了按照长度递增的次序产生最短路径的算法，它是一种典型的贪心算法。对于图<code>$G=(V,E)$</code>，包含<code>$n$</code>个顶点<code>$i=1,2,...n$</code>，弧<code>&lt;i,j&gt;</code>的权值为<code>$w(i,j)$</code>。现在指定始点为<code>$v_0$</code>，考虑始点<code>$v_0$</code>到任意一顶点<code>$v_k$</code>的最短距离。</p>
<h3>问题规模分解</h3>
<p>首先尝试把问题分解为更小规模的问题。当始点<code>$v_0$</code>和顶点<code>$i$</code>之间不存在直接相连的弧<code>$&lt;v_0,i&gt;$</code>，若它们之间存在路径，则该路径必定要经过某个和<code>$v_0$</code>直接相连的中间顶点（这里记作<code>$x$</code>）；基于同样的原理，如果顶点<code>$x$</code>和<code>$i$</code>仍然不直接相连，则这条最短路径必定还要经过一个和顶点<code>x</code>直接相连的某个顶点：</p>
<pre><code class="language-math">%% KaTex
\boxed{ v_0 \xrightarrow{w(v_0,x)} x \xrightarrow{w(x,?)} ...... } \xrightarrow{w(?,i)} i
</code></pre>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <div class="container">
      <div class="container has-text-centered">
        <a href="/posts/page11.html">
          Previous
        </a>
        13 of 32
        <a href="/posts/page13.html">
          Next
        </a>
      </div>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
      
 // 处理形如 <code>$E=mc^2$</code> 形式的公式
  var inlineMathNodes=document.querySelectorAll('code');
  var re=/^\$(.*)\$$/;
  for(var j=0;j<inlineMathNodes.length;j++){
    var result=re.exec(inlineMathNodes.item(j).innerText);
    if(result!==null){
      katex.render(result[1], inlineMathNodes.item(j));
    }
  }
  function removeNode(node){
    if(node.remove){
      node.remove();
    }else{
      return first.parentNode.removeChild(node);
    }
  };

  // 查找所有 pre code.language-math 节点 以备筛出数据公式
  var nodes=document.querySelectorAll("pre code.language-math");
  for(var i=0;i<nodes.length;i++){
    var node=nodes.item(i);
    // 魔术标记所在行 
    try{
      var lines = node.innerText.split('\n');
      if((!!lines) && lines.length > 0)
      {
        var first = lines[0];
        if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
          var views = "";
          // 逐行渲染
          for(var k=1; k <lines.length; k++){
              var f=lines[k];
              views += katex.renderToString(f);
          }
          // 消除父级嵌套 
          try{
            node.innerHTML=views;
          }catch(e){
            // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
            console.log('IE9 sucks',e);
            $(tr).html(node.innerHTML);
          }
        }
      }
    }
    catch(err){
      console.log(err)
    }
  }
    
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>