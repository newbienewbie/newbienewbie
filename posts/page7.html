<!DOCTYPE html><html>
  <head>

        <script type="text/javascript">
          var wsUri = "ws://localhost:8080/websocket";
      function init()
      {
        websocket = new WebSocket(wsUri);
        websocket.onclose = function(evt) { onClose(evt) };
      }
      function onClose(evt)
      {
        console.log('closing');
        websocket.close();
        document.location.reload();
      }
      window.addEventListener("load", init, false);
      </script>
            <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="/style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="/">
            <img src="/images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item is-active" href="/">
            Home
          </a>
          <a class="navbar-item" href="/about.html">
            About
          </a>
          <a class="navbar-item" href="/contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="/posts/WindWhisper/ECMAScript/popmotion/设计篇3 返回值.html">
                    popmotion 设计篇3 ：返回值
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-04-30
                </p>
              </div>
              <div class="content article-body">
                <p>在上一篇中，我们设计出了这样一种动作类：</p>
<pre><code class="language-javascript">class Action{
    constructor(props){
        this.props=props;
        // this.props.do 是一个算法框架函数
        // this.props.middlewares 是一个中间件数组
    }
    
    // 这里为了直观，我们直接修改当前对象，
    // todo: 改为创建一个新对象，让代码更函数式
    filter(predicate){
    
        // 自定义一个用于转换的中间件
        let mw=(update,complete,error)=&gt;{
            return {
                &quot;update&quot;: (v)=&gt;{
                    if(predicate(v)) update(v); 
                },
                &quot;complete&quot;: complete,
                &quot;error&quot;: error
            },
        };
        
        this.props.middlewares.push(mw);
    }

    /**
      * 根据executor和自身的middlewares合成新的函数对象
      */
    _produce(executor){
        let {
            update = (v)=&gt;{},
            complete =()=&gt;{},
            error=()=&gt;{},
        }=executor;
        
        let middlewares=this.props.middlewares;
        
        for(let i=0;i&lt;middwares.length;i++){
            let mw=this.middlewares[i];
            let r=mw(update,complete,error);
            update=r.update;     
            complete=r.complete;
            error=r.error;
        }

        return {update,complete, error };
    }
    
    start(executor){
        let {do}=this.props;
        
        let {update,complete,error}=this._produce(executor);
        
        do(update,complete,error);
    }
}
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="/posts/WindWhisper/ECMAScript/popmotion/设计篇2 中间件与扩展.html">
                    popmotion 设计篇2 ：中间件与扩展
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-04-29
                </p>
              </div>
              <div class="content article-body">
                <p>在上一篇中，我们设计出了这样一种动作类：</p>
<pre><code class="language-JavaScript">class Action{
    constructor(props){
        this.props=props;
    }
    
    start(executor){
        let {
            update=v=&gt;{},
            complete=()=&gt;{},
            error=()=&gt;{}
        }=executor;
        
        let {do}=this.props;
        
        do(update,complete,error);
    }
}

function action(do){
    return new Action({do,});
}
</code></pre>
<p>我们为<code>Action</code>在初始化的时候提供一个算法框架函数<code>do(update,complete,error)</code>，其中以三个名为<code>update</code>、<code>complete</code>、<code>error</code>三个函数作为基础，构建了整个函数的执行逻辑。具体在启动动作的时候，再传递一个执行器<code>executor</code>即可。</p>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="/posts/WindWhisper/ECMAScript/popmotion/设计篇1 动作与执行.html">
                    popmotion 设计篇1 ：动作与执行
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-04-28
                </p>
              </div>
              <div class="content article-body">
                <p>动作<code>action</code>是可以执行的对象。为了从头设计这样一种<code>API</code>我们希望其具有以下特征？</p>
<ol>
<li>一种动作用一个 <code>action</code> 对象表示，一个<code>action</code>对象表示一种动作类型</li>
<li>我们希望一个动作对象可以在未来被启动执行</li>
<li>我们希望一个动作对象可以反复被执行，也即是说，无状态、不可变</li>
</ol>
<p>据此，我们可能设想需要这样一种<code>API</code>调用方式：</p>
<pre><code class="language-javascript">actionInstance.start();    // 执行一种动作——动作对象调用启动方法: .start()
</code></pre>
<p>我们想让这种动作是无状态的，也就是说，可以反复调用：</p>
<pre><code class="language-javascript">actionInstance.start();
actionInstance.start();
// ...
actionInstance.start();
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="/posts/Misc/记Swiper.js 复制DOM引发的Bug.html">
                    记 Swiper.js 复制DOM引发的Bug
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-04-27
                </p>
              </div>
              <div class="content article-body">
                <p>最近接手了有个小项目，大致是做个类似于易企秀之类的前端页面。核心功能是，对于指定模板：</p>
<ol>
<li>在编辑模式下，可以对文字、图片进行在线编辑，点击保存后提交相应数据到服务器</li>
<li>在浏览模式下，向服务器请求数据，渲染生成个性页面</li>
</ol>
<p>在我之前已经有个前端做好的各屏样式、动效。但是他写的在线可编辑功能是用纯手工的<code>input name=&quot;&quot;</code>做的，这导致在线编辑基本是废的——因为每个模板都有很多不同的可编辑部分，不可能全靠手工完成；而且一到渲染环节就抓瞎。</p>
<h2>解决方案</h2>
<p>本想用<code>HTML5</code>的<code>content-editable</code>做，不过这货在移动端的监听内容改变比较操蛋；而且对于图片无能为力。</p>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="/posts/Boulevard/Alchemy/machine-learning/机器学习 - 世界观/机器学习 世界观 3.html">
                    机器学习 世界观 成本函数与另一种有监督的学习算法
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-04-10
                </p>
              </div>
              <div class="content article-body">
                <p>对于训练集<code>$\bold X$</code>中第<code>$i$</code>个<code>Sample</code> <code>$\bold x^{(i)}$</code>，记其目标值为<code>$y^{(i)}$</code>，预测值为<code>$\hat y^{(i)}$</code>。对于训练集中的样品，训练后的最好效果是，各预测值与相应的实际值完全相同，但实际情况必然是互有大小。为了衡量这组值的误差大小，可以用 <em>平方和</em> (<code>SSE</code>) 来表示这种误差：</p>
<pre><code class="language-math">%% KaTex
J(w) = \frac{1}{2} \displaystyle \sum_i{\Big(y^{(i)} -\hat y^{(i)} \Big)}^{2}
</code></pre>
<p>要让训练的效果最好，其实就是要让此<code>SSE</code>取得最小值。故而，我们将这个<code>$J(w)$</code>称之为 <em>目标函数</em> (<code>objective function</code>)，目标函数通常是 <em>成本函数</em> (<code>cost function</code>)，正如这里的<code>SSE</code>，训练就是要让成本函数取得最低值。</p>
<h2>梯度下降法的朴素思想</h2>
<p>那么，如何才让成本函数取得最低值呢？</p>
<p>根据泰勒公式，一个函数<code>$f(x)$</code>可以利用在<code>$x=x_0$</code>展开近似：</p>
<pre><code class="language-math">%% KaTex
f(x) = f(x_0)+f'(x_0)*(x-x_0)
</code></pre>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <div class="container">
      <div class="container has-text-centered">
        <a href="/posts/page6.html">
          Previous
        </a>
        8 of 32
        <a href="/posts/page8.html">
          Next
        </a>
      </div>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
      
 // 处理形如 <code>$E=mc^2$</code> 形式的公式
  var inlineMathNodes=document.querySelectorAll('code');
  var re=/^\$(.*)\$$/;
  for(var j=0;j<inlineMathNodes.length;j++){
    var result=re.exec(inlineMathNodes.item(j).innerText);
    if(result!==null){
      katex.render(result[1], inlineMathNodes.item(j));
    }
  }
  function removeNode(node){
    if(node.remove){
      node.remove();
    }else{
      return first.parentNode.removeChild(node);
    }
  };

  // 查找所有 pre code.language-math 节点 以备筛出数据公式
  var nodes=document.querySelectorAll("pre code.language-math");
  for(var i=0;i<nodes.length;i++){
    var node=nodes.item(i);
    // 魔术标记所在行 
    try{
      var lines = node.innerText.split('\n');
      if((!!lines) && lines.length > 0)
      {
        var first = lines[0];
        if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
          var views = "";
          // 逐行渲染
          for(var k=1; k <lines.length; k++){
              var f=lines[k];
              views += katex.renderToString(f);
          }
          // 消除父级嵌套 
          try{
            node.innerHTML=views;
          }catch(e){
            // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
            console.log('IE9 sucks',e);
            $(tr).html(node.innerHTML);
          }
        }
      }
    }
    catch(err){
      console.log(err)
    }
  }
    
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>