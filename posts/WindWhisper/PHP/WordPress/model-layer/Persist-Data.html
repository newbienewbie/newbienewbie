<!DOCTYPE html><html>
  <head>
    <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie/"/>
    <script>
      document.addEventListener('DOMContentLoaded', () => {

	// Get all "navbar-burger" elements
	const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);
  
	// Check if there are any navbar burgers
	if ($navbarBurgers.length > 0) {
  
	  // Add a click event on each of them
	  $navbarBurgers.forEach( el => {
		el.addEventListener('click', () => {
  
		  // Get the target from the "data-target" attribute
		  const target = el.dataset.target;
		  const $target = document.getElementById(target);
  
		  // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
		  el.classList.toggle('is-active');
		  $target.classList.toggle('is-active');
  
		});
	  });
	}
  });
    </script>
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item" href="">
            Home
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/PHP/WordPress/model-layer/Persist-Data.html">
                    保存插件的数据到数据库
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2015-04-10
                </p>
              </div>
              <div class="content article-body">
                <p>大多数WordPress插件都需要获取管理员或用户输入的一些信息，并保存在会话中，以便在过滤器函数(filter)、动作函数(action)和模板函数(template)中使用。若需要在下次会话中继续使用这些信息，就必须将它们保存到WordPress数据库中。以下是将插件数据保存到数据库的几种方法：</p>
<ol>
<li>使用WordPress的&quot;选项&quot;机制。</li>
<li>使用文章元数据（又名自定义域）。</li>
<li>使用自定义分类。</li>
<li>使用其他数据表</li>
<li>创建一个新的，自定义的数据库表。这种方式适合保存那些与个人文章、页面或附件无关的，会随着时间逐渐增长的，并且没有特定名称的数据。关于如何使用，你可以阅读Creating Tables with Plugins以获取更多信息</li>
</ol>
<h2>WordPress选项机制</h2>
<p>WordPress有一个&quot;选项&quot;机制，适合储存少量静态的、具有特定名称的数据(通常是网站所有者在创建插件时设置的一些初始化参数，并且以后很少会进行改动) 。
选项的值可以是字符串、数组，甚至是PHP对象（当然，PHP对象在保存时必须能够被序列化或转换成字符串，检索的时候也必须能够被反序列化）。选项的名称必须是字符串，且必须是唯一的，这样才能够确保它们不会和WoredPress或其它插件产生冲突。</p>
<p>对应数据库中数据表<code>{$wpdb-&gt;prefix}_options</code>。该表结构类似于：</p>
<pre><code>mysql&gt; select * from wp_options limit 25;
+-----------+---------------------------+-----------------------------+----------+
| option_id | option_name               | option_value                | autoload |
+-----------+---------------------------+-----------------------------+----------+
|        11 | comments_notify           | 1                           | yes      |
|        12 | posts_per_rss             | 10                          | yes      |
|        13 | rss_use_excerpt           | 0                           | yes      |
|        14 | mailserver_url            | mail.example.com            | yes      |
|        15 | mailserver_login          | login@example.com           | yes      |
|        16 | mailserver_pass           | password                    | yes      |
|        17 | mailserver_port           | 110                         | yes      |
|        18 | default_category          | 1                           | yes      |
|        19 | default_comment_status    | open                        | yes      |
|        20 | default_ping_status       | open                        | yes      |
|        21 | default_pingback_flag     | 1                           | yes      |
|        22 | posts_per_page            | 10                          | yes      |
|        23 | date_format               | F j, Y                      | yes      |
|        24 | time_format               | g:i a                       | yes      |
|        25 | links_updated_date_format | F j, Y g:i a                | yes      |
+-----------+---------------------------+-----------------------------+----------+
</code></pre>
<p>选项机制的几个主要函数：</p>
<ul>
<li><code>add_option($name,$value,$deprecated,$autoload)</code></li>
<li><code>get_option($name)</code></li>
<li><code>update_option($name,$value)</code></li>
<li><code>delete_option()</code></li>
</ul>
<p>通常情况下，最好能够对插件选项的数量进行一下精简。例如，如果有10个不同名称的选项需要保存到数据库中，那么，就可以考虑将这10个数据作为一个数组，并保存到数据库的同一个选项中。</p>
<h2>文章元数据</h2>
<p>这种方式与第一种方案类似，但是与具体的post相关联，故而适合保存与post相关的数据。</p>
<p>对应数据表<code>{$wpdb-&gt;prefix}_postmeta</code>,基本的数据结构类似于：</p>
<pre><code>mysql&gt; select * from wp_postmeta limit 15 ;
+---------+---------+-----------------------------+-----------------------------+
| meta_id | post_id | meta_key                    | meta_value                  |
+---------+---------+-----------------------------+-----------------------------+
|       1 |       2 | _wp_page_template           | default                     |
|       2 |       5 | _edit_last                  | 1                           |
|       3 |       5 | _edit_lock                  | 1441571672:1                |
|       4 |       7 | _edit_last                  | 1                           |
|       5 |       7 | _edit_lock                  | 1441572102:1                |
|       6 |       8 | _edit_last                  | 1                           |
|       7 |       8 | _edit_lock                  | 1441572197:1                |
|       8 |      10 | _menu_item_type             | custom                      |
|       9 |      10 | _menu_item_menu_item_parent | 0                           |
|      10 |      10 | _menu_item_object_id        | 10                          |
|      11 |      10 | _menu_item_object           | custom                      |
|      12 |      10 | _menu_item_target           |                             |
|      13 |      10 | _menu_item_classes          | a:1:{i:0;s:0:&quot;&quot;;}           |
|      14 |      10 | _menu_item_xfn              |                             |
|      15 |      10 | _menu_item_url              | http://localhost/wordpress/ |
+---------+---------+-----------------------------+-----------------------------+

</code></pre>
<p>涉及到的一些基本的CRUD函数为：</p>
<ul>
<li><code>add_post_meta()</code></li>
<li><code>get_post_meta()</code></li>
<li><code>update_post_meta()</code></li>
<li><code>delete_post_meta()</code></li>
</ul>
<p>实际上，WordPress2.9之后，引入了<code>register_post_type</code>来创建新的Post Type。配合对元数据的操作函数，可以极大程度上模拟各种实体功能，从而避免创建新的的数据表。</p>
<pre><code class="language-PHP">//...某插件提供的Post Type注册方法片段

register_post_type(
    self::POST_TYPE,
    array(
        'labels' =&gt; array(
            'name' =&gt; __(sprintf('%ss', ucwords(str_replace(&quot;_&quot;, &quot; &quot;, self::POST_TYPE)))),
            'singular_name' =&gt; __(ucwords(str_replace(&quot;_&quot;, &quot; &quot;, self::POST_TYPE)))
        ),
        'public' =&gt; true,
        'has_archive' =&gt; true,
        'description' =&gt; __(&quot;This is a sample post type meant only to illustrate a preferred structure of plugin development&quot;),
        'supports' =&gt; array(
            'title', 'editor', 'excerpt', 
        ),
    )
);
</code></pre>
<p>一旦使用了自定义的Post Type来作为Entity，就可以使用WordPress自带的CRUD函数来操作：</p>
<ul>
<li><code>wp_insert_post()</code> #Create a new post (C).</li>
<li><code>get_post()</code>       #Retrieve a post (R).</li>
<li><code>wp_update_post()</code> #Update an existing post (U).</li>
<li><code>wp_delete_post()</code> #Delete a post (D).</li>
</ul>
<p>当然，搭配到WordPress的钩子上，就更强大了。例如：</p>
<ul>
<li><code>save_post</code>             # 当保存文章时被触发的钩子事件</li>
<li><code>save_post_{post_type}</code> # WP3.7新增钩子,无须校验<code>is_post_type($post_type)</code></li>
</ul>
<h2>Custom Taxonomy</h2>
<p>WordPress默认内置了4种Taxonomies:</p>
<ol>
<li>Category      #往往是写文章之前就预定义好的</li>
<li>Tag           #往往拥有多个tag，可在写文章时即时生成</li>
<li>Link Category #往往只在内部使用，可用来categorize links</li>
<li>Post Formats  #meta信息，可以用来定制文章的呈现形式。</li>
</ol>
<p>除此之外，WordPress还允许创建自己的taxonomies。</p>
<p>这种方式适合保存那些需要分门别类存放的数据，如用户信息、评论内容以及用户可编辑的数据等，特别适合于当你想要根据某个类型去查看相关的文章和数据的情况。</p>
<h2>使用WordPress内置的其他数据表</h2>
<p>WordPress为内置数据表提供了许多便利函数，比如Users数据表:</p>
<pre><code>* `wp_create_user()`#Create a new user (C).
* `get_userdata()`  #Retrieve a user’s data (R).
* `wp_update_user()`#Update an existing user (U).
* `wp_delete_user()`#Delete a user (D).
</code></pre>
<h2>建立额外的数据表</h2>
<p>除了使用现有的数据库模式之外，还可以添加自己的数据表。如著名的插件WooCommerce就添加了定制的数据表：</p>
<pre><code>+-------------------------------------------------+
| Tables_in_wordpress                             |
+-------------------------------------------------+
| wp_woocommerce_api_keys                         |
| wp_woocommerce_attribute_taxonomies             |
| wp_woocommerce_downloadable_product_permissions |
| wp_woocommerce_order_itemmeta                   |
| wp_woocommerce_order_items                      |
| wp_woocommerce_tax_rate_locations               |
| wp_woocommerce_tax_rates                        |
| wp_woocommerce_termmeta                         |
+-------------------------------------------------+

</code></pre>
<h3>create schema</h3>
<h3>update schema</h3>
<h3>日常操作</h3>
<p>可借助于WPDB类全局类对象$wpdb提供的方法完成。</p>
<pre><code class="language-PHP">$wpdb-&gt;insert(
    $table_name,
    array(
        'time'=&gt;current_time('mysql'),
        'name'=&gt;$welcome_name,
        'text'=&gt;$welcome_text
    )
);
</code></pre>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
       // 处理形如 <code>$E=mc^2$</code> 形式的公式
 var inlineMathNodes=document.querySelectorAll('code');
 var re=/^\$(.*)\$$/;
 for(var j=0;j<inlineMathNodes.length;j++){
   var result=re.exec(inlineMathNodes.item(j).innerText);
   if(result!==null){
	 katex.render(result[1], inlineMathNodes.item(j));
   }
 }
 function removeNode(node){
   if(node.remove){
	 node.remove();
   }else{
	 return first.parentNode.removeChild(node);
   }
 };

 // 查找所有 pre code.language-math 节点 以备筛出数据公式
 var nodes=document.querySelectorAll("pre code.language-math");
 for(var i=0;i<nodes.length;i++){
   var node=nodes.item(i);
   // 魔术标记所在行 
   try{
	 var lines = node.innerText.split('\n');
	 if((!!lines) && lines.length > 0)
	 {
	   var first = lines[0];
	   if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
		 var views = "";
		 // 逐行渲染
		 for(var k=1; k <lines.length; k++){
			 var f=lines[k];
			 views += katex.renderToString(f);
		 }
		 // 消除父级嵌套 
		 try{
		   node.innerHTML=views;
		 }catch(e){
		   // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
		   console.log('IE9 sucks',e);
		   $(tr).html(node.innerHTML);
		 }
	   }
	 }
   }
   catch(err){
	 console.log(err)
   }
 }
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>