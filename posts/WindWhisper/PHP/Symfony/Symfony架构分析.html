<!DOCTYPE html><html>
  <head>
    <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie/"/>
    <script>
      document.addEventListener('DOMContentLoaded', () => {

	// Get all "navbar-burger" elements
	const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);
  
	// Check if there are any navbar burgers
	if ($navbarBurgers.length > 0) {
  
	  // Add a click event on each of them
	  $navbarBurgers.forEach( el => {
		el.addEventListener('click', () => {
  
		  // Get the target from the "data-target" attribute
		  const target = el.dataset.target;
		  const $target = document.getElementById(target);
  
		  // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
		  el.classList.toggle('is-active');
		  $target.classList.toggle('is-active');
  
		});
	  });
	}
  });
    </script>
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item" href="">
            Home
          </a>
          <a class="navbar-item" href="tags.html">
            Tags
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/PHP/Symfony/Symfony架构分析.html">
                    Symfony架构分析
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        PHP
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Symfony
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="/tags.html#Symfony">
                    <span class="tag is-info">
                      Symfony
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2015-04-10
                </p>
              </div>
              <div class="content article-body">
                <p>接触到的第一个PHP 框架就是CodeIgniter。轻巧，入门简单,概念清晰。</p>
<p>然而我快发现，我很难复用CodeIgniter的代码--代码耦合度太高了，所以我开始试着写了一个自己的MVC框架 <a href="https://github.com/newbienewbie/Bamboo">Bamboo</a>。我想包装自己的类和模块，这样我就可以搭积木一样搭建各种网站了。当然，我只写了个基本框架，下面的重头戏是把所有的模块都自己实现。比如，Logger，Security，Upload，etc.我开始意识到这是个浩大的工程，然后计划搁浅了。</p>
<p>直到有一天,我在Laravel里看到了它使用了Symfony组件的时候，我才发现，原来我在视图造一个很大的轮子。Symfony是可复用的,是组件化的。</p>
<h2>Request-Response模型</h2>
<p>从本质上来说，HTTP协议实际上描述了一个Request-Response模型。与之相关的PHP代码实际上都在做着<code>解释请求、生成响应</code>的工作，Symfony则更进一步的将Request和Response对象化了。</p>
<p>Request-Response模型是整个Symfony的基础模型，可以毫不夸张的说，整个Symfony都构筑在这个基础模型之上(参见Front Controller部分)。</p>
<h3>Request对象</h3>
<p>Request类很简单，封装了原生PHP的各大超全局输入变量:</p>
<pre><code class="language-PHP">use Symfony\Component\HttpFoundation\Request


$request = Request::createFromGlobals();

$request-&gt;getPathInfo();    //the URI being requested (e.g. /about) minus any query parameters
$request-&gt;query-&gt;get('foo');    //$_GET 
$request-&gt;request-&gt;get('bar', 'default value if bar does not exist');    /$_POST
$request-&gt;server-&gt;get('HTTP_HOST');    //$_SERVER
$request-&gt;files-&gt;get('foo');     //retrieves an instance of UploadedFile identified by foo
$request-&gt;cookies-&gt;get('PHPSESSID');   //$_COOKIE 
$request-&gt;headers-&gt;get('host');
$request-&gt;headers-&gt;get('content_type');
$request-&gt;getMethod();    //GET, POST, PUT, DELETE, HEAD
$request-&gt;getLanguages(); // an array of languages the client accepts
</code></pre>
<h3>Response对象</h3>
<p>Response类也非常简单，用来代替原生PHP的echo(),header():</p>
<pre><code class="language-PHP">Symfony\Component\HttpFoundation\Response

$response = new Response();

$response-&gt;setContent('&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');
$response-&gt;setStatusCode(Response::HTTP_OK);
$response-&gt;headers-&gt;set('Content-Type', 'text/html');
// prints the HTTP headers followed by the content

$response-&gt;send();
</code></pre>
<h2>Front Controller</h2>
<p><img src="#" alt="Symfony分层架构图" /></p>
<p>说来惭愧，第一次看到Front Controller的概念还是在PHPWind的9.x的源代码里看到的，当时还天真的以为它是PHPWind9.x的开发人员想出来的名词。后来看Symfony也有这个概念，这才发现原来自己是多么的孤陋寡闻。当然，我们一直都在使用这个东西，只是不知道那就叫FrontController.</p>
<p>一般情况下，代码会以各个独立的模块分层存在。为了根据请求的不同调用合适的功能代码，一些如CodeIgniter的框架(包括我自己写的Bamboo)都有一个统一入口文件(index.php)负责这项工作。
在Symfony等一些框架(其他如PHPWind9.x以后的版本)中，单独抽象出了Front Controller的概念。和CodeIgniter中的index.php一样，Front Controller是一个统一入口，一切发到我们Application的请求都会由其处理，然后根据接收到的Request不同，按照配置的Route规则加载对应的Controller的Action。
处理请求之后，生成响应对象并send()到客户端。</p>
<p>根据环境的不同，Symfony自带有两个Front Controller：</p>
<ul>
<li><code>web/app.php</code>    #生产环境</li>
<li><code>web/app_dev.php</code>  #开发环境</li>
</ul>
<p>之所以没有测试环境对应的前端控制器，是因为测试环境可以通常只在单元测试时使用。</p>
<p>当然console工具也提供了能在任意环境下运行的Front Controller。</p>
<p>Symfony中的Front Controller非常简单，遵循的逻辑可以概括为&quot;<code>处理请求，发送响应</code>&quot;,这也是整个Symfony框架对Request-Response模型的实现：</p>
<pre><code class="language-PHP">// web/app.php

require_once __DIR__.'/../app/bootstrap.php';
require_once __DIR__.'/../app/AppKernel.php';
use Symfony\Component\HttpFoundation\Request;

//初始化一个prod环境、非debug模式运行的AppKernel
$kernel = new AppKernel('prod', false);

$kernel-&gt;handle(Request::createFromGlobals())    //处理请求
        -&gt;send();    //发送响应
</code></pre>
<p>至此，针对Request-Response模型的处理流程已经总体规划完毕了。</p>
<p>对于一个Symfony项目<code>myproj</code>,为了方便起见，假设整个文件夹都位于<code>/var/www/</code>下,当我们在浏览器中访问：</p>
<p><code>localhost/myproj/web/some_route</code></p>
<p>实际上是在调用Front Controller来执行与some_route对应的代码。事实上，上面这个URL在默认情况下等效于：</p>
<p><code>localhost/myproj/web/app.php/some_route</code></p>
<p>当然，在开发模式下，可以访问：</p>
<p><code>localhost/myproj/web/app_dev.php/some_route</code></p>
<p>激活debug工具并能自动重建缓存。</p>
<p>正是由于Front Controller已经实现了Request-Response这样的基本流程，在Symfony中为一个基本组件（Bundle）添加页面只需要要遵循两步：</p>
<ol>
<li>创建Controller    #定义如何根据Response生成Response对象</li>
<li>配置Route    #配置URL和Controller的映射关系</li>
</ol>
<p>当然，为了避免组织混乱、保持结构清晰，实际中，Route、Controller等等都是以Bundle来设计的。</p>
<h2>Bundle</h2>
<p>Bundle从PHP的角度而言，可以视作一个命名空间。一旦一个PHP命名空间添加了Bundle Class，就成为Bundle。这个Bundle Class的命名必须遵循以下规则：</p>
<ul>
<li>只使用字母和下划线</li>
<li>使用CamelCased命名风格</li>
<li>使用descriptive和short的名字</li>
<li>以vender名为prefix</li>
<li>以&quot;Bundle&quot;为suffix</li>
</ul>
<p>Bundle Class的getClass()方法返回这个类名。</p>
<p>Bundle是Symfony的基本组件。Bundle存放了与某个特性相关的一切文件(比如PHP类、配置、甚至是css文件和JavaScript文件)的目录。
事实上，Symfony的Bundle和PHPCMS里的module作用相当，类似于模块、插件。但是相较于PHPCMS之类其他的框架，Symfony的Bundle具有更好的抽象和实现。</p>
<p>一个Bundle，通常位于src/VenderOfBundle/BundleName之下,其中的目录结构多为：</p>
<pre><code>Vender/
    YourBundle/
        VenderYourBundle.php
        Controller/               #控制器
            Spec1Controller.php
            Spec2Controller.php
        DependencyInjection/      #DI
        Resources/
            config/
            views/
        Tests/                    #测试
</code></pre>
<p>想要添加一个Bundle，应该先创建以上目录，然后修改app/Kernel.php文件，为registerBundles()方法添加一个该Bundle的实例：</p>
<pre><code class="language-PHP">// app/AppKernel.php

public function registerBundles(){

    $bundles=array(
        //...
        new Vender\YourBundle\VenderYourBundle();
    );

    //...

    return $bundles;
}
</code></pre>
<p>以上两步可以归纳为：</p>
<ol>
<li>创建Bundle</li>
<li>注册Bundle</li>
</ol>
<p>当然，添加Bundle的这些步骤可以用一个命令代替：</p>
<pre><code class="language-bash">    php app/console generate:bundle --namespace=Vender/YourBundle --format=yml
</code></pre>
<h2>Route</h2>
<p>Route是指从Request（如URL路径,HTTP Method)到控制器(具体到Action)的映射。所以， 一条路由规则有两个要素组成：</p>
<ol>
<li>URL Path</li>
<li>与URL Path匹配的Controller</li>
</ol>
<p>我们还可以为这条路由规则起一个独一无二的名字，这样我们就能用于生成URL了。</p>
<p>路由层的作用就是把输入进来的URL转换为要执行的Controller。</p>
<p>Symfony会从一个单独的路由配置文件中加载所有的路由规则。这个路由配置文件通常是</p>
<p><code>app/config/routing.yml</code></p>
<p>,当然，Symfony支持高度定制，我们可以把默认的路由文件配置成其他任意其他文件(包括XML和PHP文件)。如：</p>
<pre><code class="language-YAML"># app/config/config.yml
framework
    # ....
    router: { resource: &quot;%kernel.root_dir%/config/routing.yml&quot;}
</code></pre>
<p>当然，从URL到控制器动作，参数匹配是必不可少的。Symfony的路由系统支持:</p>
<ul>
<li>URL匹配         #通过@Route()设置
<ul>
<li>必选参赛    #通过占位符来设置</li>
<li>可选参数    #通过占位符和设置defaults来设置</li>
<li>正则匹配    #通过requirements设置</li>
</ul>
</li>
<li>HTTP Method匹配 #通过@Method()</li>
</ul>
<pre><code class="language-PHP">/**
 *@Route(&quot;/blog/{page}&quot;,defaults={&quot;page&quot;: 1},requirements={
 *    &quot;page&quot;: &quot;\d+&quot;
 *})
 *@Method(&quot;GET&quot;)
 */
public function indexAction($page){
    //...
}
</code></pre>
<p>当然，威力更巨大的是condition属性，支持无限可能的定制。</p>
<pre><code class="language-YAML">contact:
    path: /contact
    defaults: { _controller: AcmeDemoBundle:Main:contact}
    condition: &quot;context.getMethod() in ['GET','HEAD'] and request.headers.get('User-Agent') matches '/firefox/i' &quot;
</code></pre>
<p>这个配置会被转换为以下的PHP代码：</p>
<pre><code class="language-PHP">if(rtrim($pathinfo,&quot;/contact&quot;)===''&amp;&amp;
    (
        in_array($context-&gt;getMethod(),array(0=&gt;'GET',1=&gt;'HEAD')) &amp;&amp;
        preg_match('/firefox/i',$request-&gt;headers-&gt;get(&quot;User-Agent&quot;))
    )
    
){
    //....
}
</code></pre>
<h3>一个Bundle中的Route</h3>
<p>要让合适的Controller和Action发生调用，必须建立url与之的映射。</p>
<pre><code class="language-PHP">#src/Vender/YourBundle/Resources/config/routing.yml

specController:
    path: /specController/{limit}
    defaults: { _controller: VenderYourBundle:specController:yourAction}

</code></pre>
<h3>app级Route</h3>
<p>尽管所有的路由配置规则是从一个单独的文件中读取的，大家在实际中还是会通过<code>resource</code>导入其他路由规则。比如，使用Annotation格式的路由配置应设置:</p>
<pre><code class="language-YAML">app: 
    resource: &quot;@AppBundle/Controller&quot;
    type: annotation  #使用Annotation reader来读取resource变量
</code></pre>
<p>如果我们手工添加了一个Bundle，我们可以把它自身包含的Route规则导入app level的配置中，即应该在app/config/routing.yml中添加配置：</p>
<pre><code class="language-YAML"># app/config/routing.yml

vender_yourbundlename
    resource: &quot;@VenderYourBundle/Resources/config/routing.yml&quot;
    prefix: /
    
</code></pre>
<p>当然，如果是用<code>php app/console generate:bundle</code>命令生成的bundle，那么这一步已经由Symfony替我们做好了。</p>
<h3>双向映射</h3>
<p>Route提供了bidirectional System:</p>
<ol>
<li>match($URL)      #返回匹配到的控制器及参数构成的数组</li>
<li>generate($RouteName,$paramsArray)       #生成URL</li>
</ol>
<h2>Controller</h2>
<p>我们知道，每一个Route规则都有一个<code>_controller</code>对象，我们当然可以用</p>
<p><code>完全限定名的ClassName::ActionName</code></p>
<p>的形式来引用一个Controller，比如：</p>
<p><code>AppBundle\Controller\BlogController::ShowAction </code>。</p>
<p>但实际上这样的表达是有冗余信息的，最起码还要指出BlogController位于的命名空间Controller是没必要的，所以Symfony还支持对Controller的逻辑命名, 一条指定Controller的Action的逻辑命名通常遵循这样的约定：</p>
<p><code>BundleName:ControllerName:ActionName</code></p>
<p>通常这样的逻辑名称会被映射为</p>
<p><code>path/to/BundleName/Controller/ControllerName.php</code>文件中的<code>ActionName</code>方法</p>
<p>比如：</p>
<p><code>AcmeDemoBundle:Random:Index</code></p>
<p>这个控制器通常会会映射为：</p>
<p><code>Acme\DemoBundle\Controller\RandomController</code>类中的<code>indexAction</code>方法。</p>
<p>另外值得注意的是，Symfony中Controller的Action 与CodeIgniter之类的框架并完全一样:</p>
<ol>
<li>CodeIgniter中的控制器直接输出响应，而Symfony中则是必须返回Response对象;</li>
<li>Symfony支持从Route和Request定制Action方法的参数。而且对于Action方法声明，参数顺序并不重要。</li>
</ol>
<pre><code class="language-PHP">
use Symfony\Component\HttpFoundation\Request;

/**
 * @Route(&quot;/hello/{firstName}/{lastName}&quot;,name=&quot;hello&quot;)
 */
public function indexAction($lastName,$firstName,Request $request){

    //$firstName和$lastName等参赛顺序并不重要
    //可以直接使用$request
    $page=$request-&gt;query-&gt;get(&quot;page&quot;,1);
}
</code></pre>
<p>此外，Symfony\Bundle\FrameworkBundle\Controller\Controller提供了一系列helper方法。</p>
<ul>
<li>Redirecting
<ul>
<li>generateUrl($route)</li>
<li>redirect($absUrl)</li>
<li>redirectToRoute($route)   # new RedirectResponse($this-&gt;generateUrl($route))</li>
</ul>
</li>
<li>Rendering Templates
<ul>
<li>render($pathOrLogicalTemplateName,$array)    #render a template and return a Response object</li>
</ul>
</li>
<li>Accessing other Services
<ul>
<li>get('templating')</li>
<li>get('router')</li>
<li>get('mailer')</li>
</ul>
</li>
<li>Exception</li>
<li>FlashMessage
<ul>
<li>addFlash()</li>
</ul>
</li>
<li>Forwarding</li>
</ul>
<h2>Symfony目录结构</h2>
<p>Symfony的基本架构便如上文所述，十分清晰。与架构相对应，Symfony的目录结构也是非常清晰的。默认的结构组织形式为：</p>
<pre><code>app/    #application config ,cache,
src/    #project源码
vender/ #第三方依赖,由composer独占管理权
web/    #包含了公共访问文件,比如Front Controller和静态文件
</code></pre>
<p><code>web/</code>目录类似于网站的根目录，一切的公开访问都是从这里开始的，其下的Front Controller文件如<code>app.php</code>和<code>app_dev.php</code>是整个网站的入口管理文件。其他一些静态资源也会以一定的结构组织在这个目录下。</p>
<p><code>app/</code>目录是Application级的一些文件存放地。如<code>app/console</code>、<code>app/config</code>，<code>app/cache</code></p>
<p><code>src/</code>目录是针对网站各个功能的源码存放地，其中文件一般以各个Vender提供的Bundle分别组织。</p>
<p>尽管拥有如此清晰的文件结构，Symfony也支持任意定制目录结构。</p>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
       // 处理形如 <code>$E=mc^2$</code> 形式的公式
 var inlineMathNodes=document.querySelectorAll('code');
 var re=/^\$(.*)\$$/;
 for(var j=0;j<inlineMathNodes.length;j++){
   var result=re.exec(inlineMathNodes.item(j).innerText);
   if(result!==null){
	 katex.render(result[1], inlineMathNodes.item(j));
   }
 }
 function removeNode(node){
   if(node.remove){
	 node.remove();
   }else{
	 return first.parentNode.removeChild(node);
   }
 };

 // 查找所有 pre code.language-math 节点 以备筛出数据公式
 var nodes=document.querySelectorAll("pre code.language-math");
 for(var i=0;i<nodes.length;i++){
   var node=nodes.item(i);
   // 魔术标记所在行 
   try{
	 var lines = node.innerText.split('\n');
	 if((!!lines) && lines.length > 0)
	 {
	   var first = lines[0];
	   if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
		 var views = "";
		 // 逐行渲染
		 for(var k=1; k <lines.length; k++){
			 var f=lines[k];
			 views += katex.renderToString(f);
		 }
		 // 消除父级嵌套 
		 try{
		   node.innerHTML=views;
		 }catch(e){
		   // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
		   console.log('IE9 sucks',e);
		   $(tr).html(node.innerHTML);
		 }
	   }
	 }
   }
   catch(err){
	 console.log(err)
   }
 }
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>