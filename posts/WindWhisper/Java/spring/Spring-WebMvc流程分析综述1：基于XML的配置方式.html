<!DOCTYPE html><html>
  <head>

        <script type="text/javascript">
          var wsUri = "ws://localhost:8080/websocket";
      function init()
      {
        websocket = new WebSocket(wsUri);
        websocket.onclose = function(evt) { onClose(evt) };
      }
      function onClose(evt)
      {
        console.log('closing');
        websocket.close();
        document.location.reload();
      }
      window.addEventListener("load", init, false);
      </script>
            <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item" href="">
            Home
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/Java/spring/Spring-WebMvc流程分析综述1：基于XML的配置方式.html">
                    Spring WebMvc流程分析综述1：基于XML的配置方式
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2016-10-18
                </p>
              </div>
              <div class="content article-body">
                <p>Spring WebMvc 启动流程是怎么样的？</p>
<h2>从DispatcherServlet说起</h2>
<p>首先，在标准部署描述符<code>web.xml</code>文件中，有类似如下的一段<code>Servlet</code>配置：</p>
<pre><code class="language-XML">&lt;servlet&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<p>声明所有以<code>*.htm</code>结尾的url-pattern都交给<code>org.springframework.web.servlet.DispatcherServlet</code>类去处理，这个类扮演着前端控制器(Front Controller)的角色，
默认情况下会去加载与<code>sevlet-name</code>元素相关的一个配置文件（应用上下文配置文件），其路径名规则为：</p>
<p><code>WEB-INF/${servlet-name}-servlet.xml</code></p>
<p>比如，这里指定的<code>sevlet-name</code>元素名为<code>dispatcher</code>，则会默认去加载<code>web/WEB-INF/dispatcher-servlet.xml</code>文件。
这是一种<code>约定优于配置</code>的做法，当然，我们也可以手工指定<code>DispatcherServlet</code>配置文件：</p>
<pre><code class="language-XML">&lt;servlet&gt;
    &lt;description&gt;spring mvc servlet&lt;/description&gt;
    &lt;servlet-name&gt;springMvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;description&gt;spring mvc 配置文件&lt;/description&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
</code></pre>
<p><code>DispatcherServlet</code>的相关配置文件还可以是JavaConfig形式：</p>
<pre><code class="language-XML">&lt;servlet&gt;
    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt; 
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt; 
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value&gt;
    &lt;/init-param&gt; 
    &lt;init-param&gt; 
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; 
        &lt;param-value&gt;com.habuma.spitter.config.WebConfigConfig&lt;/param-value&gt;
    &lt;/init-param&gt; 
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
</code></pre>
<p><code>DsipatcherServlet</code>配置文件是一个Spring应用上下文配置文件，XML结构类似于：</p>
<pre><code class="language-XML">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!-- was: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; --&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd
    http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&quot;&gt;

    &lt;bean class=&quot;org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping&quot;/&gt;
    &lt;!--
    Most controllers will use the ControllerClassNameHandlerMapping above, but
    for the index controller we are using ParameterizableViewController, so we must
    define an explicit mapping for it.
    --&gt;
    &lt;bean id=&quot;urlMapping&quot; class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;
        &lt;property name=&quot;mappings&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;index.htm&quot;&gt;indexController&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;viewResolver&quot;
        class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
        p:prefix=&quot;/WEB-INF/jsp/&quot;
        p:suffix=&quot;.jsp&quot; /&gt;

    &lt;!-- The index controller. --&gt;
    &lt;bean name=&quot;indexController&quot;
        class=&quot;org.springframework.web.servlet.mvc.ParameterizableViewController&quot;
        p:viewName=&quot;index&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<p>当<code>DispatcherServlet</code>接到一个匹配<code>*.htm</code>形式的请求（比如这里配置的<code>index.htm</code>）时，就会知道对应的<code>控制器Bean</code>的名称（比如，这里配置的<code>indexControll</code>），
再通过IoC获取相应的<code>控制器Bean</code>。</p>
<p>当然，这种把</p>
<ul>
<li><code>路径-控制器Bean</code>映射关系的声明</li>
<li>控制器Bean的声明</li>
</ul>
<p>写到XML文件中的方式很啰嗦，也不够直观，Spring支持：</p>
<ul>
<li>通过<code>@Controller</code>注解声明Bean</li>
<li>通过<code>@RequestMapping</code>注解来配置这种映射关系。</li>
</ul>
<p>控制器在完成相应的业务逻辑后，设置Model参数，返回视图的逻辑名；通过IoC获取视图解析器；
再由视图解析器完成从逻辑视图名转到View视图对象的转换，
最后由View对象的render()方法进行渲染到response。</p>
<h2>ContextLoaderListener</h2>
<p>由于<code>前端控制器</code>所加载的配置文件是只是<code>{$dispatcherServletConfigName}</code>的文件，对于其他配置文件的加载怎么办?
这可以用<code>Servlet监听器</code>实现。</p>
<h3>标准的 ServletContext</h3>
<h4>ServletContext 简介</h4>
<p>根据标准，一个Host下可以部署多个Web Application，Web Application 都有一个<code>ServletContext</code>接口对象：</p>
<p>每一个<code>Context</code>都可以配置自己独立的资源，比如数据源资源。在具体项目目录的META-INF/，创建<code>context.xml</code>即可：</p>
<pre><code class="language-XML">&lt;?xml version='1.0' encoding='utf-8'?&gt;

&lt;Context docBase=&quot;demods&quot; path=&quot;/demods&quot; reloadable=&quot;true&quot;&gt;
    &lt;Resource name=&quot;jdbc/EmployeeDB&quot;
        auth=&quot;Container&quot;
        type=&quot;javax.sql.DataSource&quot;
        username=&quot;dbusername&quot;
        password=&quot;dbpassword&quot;
        driverClassName=&quot;org.hsql.jdbcDriver&quot;
        url=&quot;jdbc:HypersonicSQL:database&quot;
        maxActive=&quot;8&quot;
        maxIdle=&quot;4&quot;
    /&gt;
&lt;/Context&gt;
</code></pre>
<p><code>Servlet</code>可以用之与<code>Servlet容器</code>通信，例如：</p>
<ul>
<li>得到文件的MIME类型</li>
<li>转发请求</li>
<li>向日志文件写入日志消息。</li>
</ul>
<p><code>ServletContext</code>的具体表现就是Web服务器中一个已知路径的根。比如<code>http://localhost:8080/demo/</code>，这里demo便是。</p>
<h4>ServletContext 参数</h4>
<p>在<code>web.xml</code>文件中，还可以指定若干<context-param>元素来配置<code>ServletContext</code>的参数</p>
<pre><code class="language-XML">&lt;context-param&gt;
    &lt;param-name&gt;url&lt;/param-name&gt;
    &lt;param-value&gt;jdbc:microsoft:sqlserver://localhost:1433;databse=snptest&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre>
<p>如此，即可在<code>Servlet</code>中，通过</p>
<pre><code class="language-Java">getServletContext().getInitParameter(&quot;paramName&quot;);
</code></pre>
<p>来获取之。</p>
<p>总之，如名字暗示的那样，<code>ServletContext</code>代表了<code>Servlet</code>的运行上下文环境。</p>
<h4>ServletContext 的事件与监听器</h4>
<p>与<code>ServletContext</code>相关的事件主要有两个：</p>
<ul>
<li><code>生命周期</code>:<code>ServletContext</code>初始化、销毁，监听器为<code>ServletContextListener</code></li>
<li><code>属性改变</code>:<code>ServletContext</code>的属性被增加、删除或者替换时发生，监听器为<code>ServletContextAttributeListener</code></li>
</ul>
<p>其中，<code>ServletContextListener</code>接口如下:</p>
<pre><code class="language-Java">public interface ServletContextListener extends EventListener {

    /**
     * Receives notification that the web application initialization
     * process is starting.
     *
     * &lt;p&gt;All ServletContextListeners are notified of context
     * initialization before any filters or servlets in the web
     * application are initialized.
     *
     * @param sce the ServletContextEvent containing the ServletContext
     * that is being initialized
     */
    public void contextInitialized(ServletContextEvent sce);

    /**
     * Receives notification that the ServletContext is about to be
     * shut down.
     *
     * &lt;p&gt;All servlets and filters will have been destroyed before any
     * ServletContextListeners are notified of context
     * destruction.
     *
     * @param sce the ServletContextEvent containing the ServletContext
     * that is being destroyed
     */
    public void contextDestroyed(ServletContextEvent sce);
}
</code></pre>
<h3>Spring 的 ContextLoaderListener</h3>
<p>Spring 加载其他配置文件是通过在<code>web.xml</code>中注册<code>ServletContextListener</code>实现的。</p>
<pre><code class="language-XML">&lt;listener&gt;
    &lt;listener-class&gt;
        org.springframework.web.context.ContextLoaderListener
    &lt;/listener-class&gt;
&lt;/listener&gt;

</code></pre>
<p>Spring 提供的<code>ContextLoaderListener</code>是标准接口<code>javax.servlet.ServletContextListener</code>的一个实现。
用于加载其他配置文件到Spring应用上下文中。默认情况下，这个监听器会加载<code>WEB-INF/applicationContext.xml</code>配置文件。也可以手工指定这个配置文件名：</p>
<pre><code class="language-XML">&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;
        /WEB-INF/spitter-security.xml
        classpath:service-context.xml
        classpath:persistence-context.xml
        classpath:dataSource-context.xml
    &lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre>
<h2>小结</h2>
<p>Spring WebMvc 启动流程主要是通过标准的<code>web.xml</code>部署描述符完成。</p>
<ul>
<li>指定一切请求交由调度器<code>DipatcherServlet</code>根据相关配置（默认是<code>WEB-INF/${servlet-name}-servlet.xml</code>）处理。</li>
<li>通过<code>ServletContext</code>监听器<code>ContextLoaderListener</code>加载上下文配置文件（默认是<code>WEB-INF/applicationContext.xml</code>）。</li>
</ul>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
      
 // 处理形如 <code>$E=mc^2$</code> 形式的公式
  var inlineMathNodes=document.querySelectorAll('code');
  var re=/^\$(.*)\$$/;
  for(var j=0;j<inlineMathNodes.length;j++){
    var result=re.exec(inlineMathNodes.item(j).innerText);
    if(result!==null){
      katex.render(result[1], inlineMathNodes.item(j));
    }
  }
  function removeNode(node){
    if(node.remove){
      node.remove();
    }else{
      return first.parentNode.removeChild(node);
    }
  };

  // 查找所有 pre code.language-math 节点 以备筛出数据公式
  var nodes=document.querySelectorAll("pre code.language-math");
  for(var i=0;i<nodes.length;i++){
    var node=nodes.item(i);
    // 魔术标记所在行 
    try{
      var lines = node.innerText.split('\n');
      if((!!lines) && lines.length > 0)
      {
        var first = lines[0];
        if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
          var views = "";
          // 逐行渲染
          for(var k=1; k <lines.length; k++){
              var f=lines[k];
              views += katex.renderToString(f);
          }
          // 消除父级嵌套 
          try{
            node.innerHTML=views;
          }catch(e){
            // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
            console.log('IE9 sucks',e);
            $(tr).html(node.innerHTML);
          }
        }
      }
    }
    catch(err){
      console.log(err)
    }
  }
    
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>