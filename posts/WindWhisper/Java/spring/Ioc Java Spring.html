<!DOCTYPE html><html>
  <head>
    <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie/"/>
    <script>
      document.addEventListener('DOMContentLoaded', () => {

	// Get all "navbar-burger" elements
	const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);
  
	// Check if there are any navbar burgers
	if ($navbarBurgers.length > 0) {
  
	  // Add a click event on each of them
	  $navbarBurgers.forEach( el => {
		el.addEventListener('click', () => {
  
		  // Get the target from the "data-target" attribute
		  const target = el.dataset.target;
		  const $target = document.getElementById(target);
  
		  // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
		  el.classList.toggle('is-active');
		  $target.classList.toggle('is-active');
  
		});
	  });
	}
  });
    </script>
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item" href="">
            Home
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/Java/spring/Ioc Java Spring.html">
                    IoC ，以 Spring 为例
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Java
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Spring
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <span class="tag is-info">
                    Java
                  </span>
                  <span class="tag is-info">
                    Spring
                  </span>
                  <span class="tag is-info">
                    Spring IoC
                  </span>
                  <span class="tag is-info">
                    IoC
                  </span>
                  <span class="tag is-info">
                    依赖注入
                  </span>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2015-05-31
                </p>
              </div>
              <div class="content article-body">
                <h2>IoC的核心理念</h2>
<p>IoC的核心理念在于分离这两种职责：</p>
<ol>
<li>类对象的依赖解析（即：生成或者查找过程）</li>
<li>类对象的使用</li>
</ol>
<p>具体而言，就是把各个类对象实例的依赖解析过程统一交给容器负责，类的使用者只负责使用类对象，不再去承担类实例的创建、查找职责（即不再去控制依赖解析过程），从而实现了控制反转（IoC），也就是传说中的好莱坞法则：“别打电话给我，我会打给你”的意义：“别自己生成对象，我会替你生成”。</p>
<p>要生成一个类，如果不考虑工厂方法，传统的做法总是类似于：</p>
<pre><code class="language-Java">MyClass mc=new MyClass(1,&quot;hello,world&quot;,true);

</code></pre>
<p>如果我们丢开这些语法形式，可以发现，通过new生成新对象实际上提供了两个基本信息：</p>
<ol>
<li>类名</li>
<li>构造器参数</li>
</ol>
<p>如果把这些信息写入到配置文件中，然后在主程序中读取配置，就可以利用反射技术动态生成这些类的实例。</p>
<p>比如,现有若干个Java类，其中一个POJO类如下所示：</p>
<pre><code class="language-Java">package com.mycompany.mavenproject1;

public class MyBean {
    private int a;
    private String b;

    public MyBean(int a,String b){
        this.a=a;
        this.b=b;
    }

    /**
        * @return the a
        */
    public int getA() {
        return a;
    }

    /**
        * @param a the a to set
        */
    public void setA(int a) {
        this.a = a;
    }

    /**
        * @return the b
        */
    public String getB() {
        return b;
    }

    /**
        * @param b the b to set
        */
    public void setB(String b) {
        this.b = b;
    }
	
}

</code></pre>
<p>将其信息写入配置文件，随便其一个名字，比如叫<code>config.xml</code></p>
<pre><code class="language-XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd &quot;
&gt;

    &lt;bean id=&quot;myBean&quot; class=&quot;com.mycompany.mavenproject1.MyBean&quot;&gt;
        &lt;constructor-arg name=&quot;a&quot; value=&quot;2&quot;/&gt;
        &lt;constructor-arg name=&quot;b&quot; value=&quot;Hello,world&quot;/&gt;
    &lt;/bean &gt;

    &lt;!--其他bean的配置信息 --&gt;
&lt;/beans&gt;
</code></pre>
<p>读取配置，这样我们就很容易利用反射创建相应的类:</p>
<pre><code class="language-Java">	    
public static void main(String[] args) throws ClassNotFoundException {

    String myBeanClassName=&quot;&quot;;
    int myBeanConstructorA;
    String myBeanConstructorB;

    //...
    //...从配置文件中读取myBean类名称：&quot;com.mycompany.mavenproject1.MyBean&quot;;
    //...从配置文件中读取myBean类构造器参数a;	
    //...从配置文件中读取myBean类构造器参数b;	
    //...
    Class c=Class.forName(myBeanClassName);
    MyBean myBean;
    try {
        myBean = (MyBean) c.getConstructor(Integer.TYPE,String.class).newInstance(myBeanConstructorA,myBeanConstructorB);
        System.out.println(myBean.getA());
    } catch (InstantiationException ex) {
        //....	 
    }
    //...
}
	
</code></pre>
<p>由于这里读配置、并根据相关信息进行实例化是个非常普遍的过程，可以将之封装。为了不重复造轮子，利用Maven添加spring-context依赖：</p>
<pre><code class="language-XML">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>即可使用如下的方式获取对象:</p>
<pre><code class="language-Java">import org.springframework.context.ApplicationContext;
import org.springframework.context.support.FileSystemXmlApplicationContext;

/**
 *
 * @author snp
 */
public class Main {

    public static void main(String[] args) {
        ApplicationContext ctx=new FileSystemXmlApplicationContext(&quot;config.xml&quot;);
        MyBean myBean;
        myBean = (MyBean) ctx.getBean(MyBean.class);
        System.out.println(myBean.getA());
        System.out.println(myBean.getB());
    }
}
</code></pre>
<h2>Spring IoC容器的XML-based的配置</h2>
<p>从上面可以看到，只需要在XML中提供配置，就可以通过反射技术由容器自动创建对应的类，完成相应的依赖解析。</p>
<h3>constructor注入与静态方法注入</h3>
<p>基于XML的配置类似于：</p>
<pre><code class="language-XML">&lt;bean id=&quot;sss&quot; class=&quot;SSS&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;xxx&quot; class=&quot;XXX&quot;&gt;
    &lt;constructor-arg value=&quot;15&quot;/&gt;    &lt;!--构造器注入：基本类型的参数--&gt;
    &lt;constructor-arg ref=&quot;sss&quot;/&gt;     &lt;!--构造器注入：引用类型的参数--&gt;
&lt;/bean&gt;
&lt;bean id=&quot;yyy&quot; class=&quot;YYY&quot; factory-method=&quot;getInstance&quot;/&gt;   &lt;!--通过静态方法构建--&gt;
</code></pre>
<p>Spring Bean默认为单例，当容器分配一个Bean时，总是返回该Bean类的同一个实例。如何修改这种默认特性呢？可以为Bean声明一个作用域：</p>
<pre><code class="language-XML">&lt;bean id=&quot;zzz&quot; class=&quot;ZZZ&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;
</code></pre>
<p>常见的作用域包括：</p>
<ul>
<li>prototype        #每次都是新的</li>
<li>singleton       #默认</li>
<li>request           #每次HTTP Request都产生新的</li>
<li>session            #每次HTTP Session都产生新的</li>
<li>global-session</li>
</ul>
<h3>setter注入</h3>
<p>基于XML的配置类似于：</p>
<pre><code class="language-XML">&lt;bean id=&quot;sss&quot; class=&quot;SSS&quot;&gt;
    &lt;property name=&quot;x&quot; value=&quot;Jingle Bells&quot;/&gt;
    &lt;property name=&quot;y&quot; ref=&quot;yId&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h2>Spring IoC容器的Java-based的配置</h2>
<p>使用XML是一种比较传统的做法，但是缺点也很明显：</p>
<ul>
<li>啰嗦</li>
<li>非类型安全的：如果手误打错一个字符串，可能要到运行时才能发现</li>
</ul>
<p>为了利用静态语言类型安全的优势，基于Java注解的配置方式被发明了出来。</p>
<p>既然IoC核心在于将依赖解析这个职责分离出去，我们大可以向容器提供基于Java的配置，用以直接调用new来生成相应的类对象（Bean）：</p>
<pre><code class="language-Java">@Configuration
class MyJavaConfig
{
    @Bean
    public MyBean1 myBean1(){
        return new MyBean1();
    }
    
    //...
}
</code></pre>
<p>如此，同样达到了控制反转、分离依赖解析职责的目的。</p>
<p>由于这种每一个Bean都需要手工显式声明Bean的方式很麻烦，对此Spring提供了auto wiring机制：</p>
<ul>
<li>组件的自动扫描</li>
<li>组件的自动装配</li>
</ul>
<p>当然，Spring允许混搭风格的配置，你完全可以杂糅XML-based的配置、Java-based的配置和显式声明Bean与隐式声明Bean（让Spring自动查找及装配）多种配置方式。</p>
<h3>组件的注解</h3>
<p>Spring默认提供了以下4种注解将POJO声明为组件：</p>
<ul>
<li><code>@Component</code>：通用的构造型注解，标识该类为Spring组件</li>
<li><code>@Controller</code>：标识该类为Spring MVC controller</li>
<li><code>@Repository</code>：标识该类为数据仓库</li>
<li><code>@Service</code>：标识该类为服务</li>
</ul>
<p>当需要声明由容器自动进行装配时，应用<code>@Autowired</code>注解之。</p>
<p>JSR-330中提供了</p>
<ul>
<li><code>@Named</code>作为标准的组件注解。</li>
<li><code>@Inject</code>作为标准的注入注解</li>
</ul>
<p>一般而言，特定的组件Bean应以<code>@Component</code>（或者标准的<code>@Named</code>）注解之。当该组件不是单例模式时，应以<code>@Scope</code>注解之。需要注入的地方应以<code>@Autowired</code>（或者标准的<code>@Inject</code>）注解之。</p>
<h3>配置类的注解</h3>
<p>配置类可以使用</p>
<ul>
<li><code>@Configuration</code> 来表示这是一个基于注解的配置类</li>
<li><code>@ComponentScan</code> 来表示让Spring去自动扫描合适的组件</li>
<li><code>@Import</code> 表示需要从其他JavaConfig中导入配置</li>
<li><code>@ImportResource</code> 表示要从XML文件中导入配置</li>
</ul>
<p>对于部分要要显式声明的Bean，应在配置类的相关方法使用<code>@Bean</code>注解之。</p>
<p>最后，基于Java注解配置的ApplicationContext应该如此获取：</p>
<pre><code class="language-Java">ApplicationContext context=new AnnotationConfigApplicationContext(KnightConfig.class);
</code></pre>
<p>这种基于Java注解的Java配置类效果类似于以下的XML文件：</p>
<pre><code class="language-XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;

    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd&quot;
&gt;
    &lt;context:annotation-config/&gt;
    &lt;context:component-scan  base-package=&quot;testannotationinject.instrument&quot; &gt;&lt;/context:component-scan&gt;
    &lt;context:component-scan  base-package=&quot;testannotationinject.performer&quot; &gt;&lt;/context:component-scan&gt;
    &lt;context:component-scan  base-package=&quot;testannotationinject.performer.instrumentalist&quot; &gt;&lt;/context:component-scan&gt;
    &lt;context:component-scan  base-package=&quot;testannotationinject.performer.juggler&quot; &gt;&lt;/context:component-scan&gt;

&lt;/beans&gt;
</code></pre>
<p>其中：</p>
<ul>
<li><code>&lt;context:annotation-config/&gt;</code>用于告诉Spring使用注解配置</li>
<li><code>&lt;context:component-scan&gt;</code>用于通知Spring自动扫描base-package，对使用构造型(<code>stereotype</code>)标注的类会自动注册为Bean。</li>
</ul>
<p>当然，类似于Java配置类获取容器的方式，利用XML格式的配置文件生成容器的方式为：</p>
<pre><code class="language-Java">ApplicationContext context=new FileSystemXmlApplicationContext(KnightConfig.class);
</code></pre>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
       // 处理形如 <code>$E=mc^2$</code> 形式的公式
 var inlineMathNodes=document.querySelectorAll('code');
 var re=/^\$(.*)\$$/;
 for(var j=0;j<inlineMathNodes.length;j++){
   var result=re.exec(inlineMathNodes.item(j).innerText);
   if(result!==null){
	 katex.render(result[1], inlineMathNodes.item(j));
   }
 }
 function removeNode(node){
   if(node.remove){
	 node.remove();
   }else{
	 return first.parentNode.removeChild(node);
   }
 };

 // 查找所有 pre code.language-math 节点 以备筛出数据公式
 var nodes=document.querySelectorAll("pre code.language-math");
 for(var i=0;i<nodes.length;i++){
   var node=nodes.item(i);
   // 魔术标记所在行 
   try{
	 var lines = node.innerText.split('\n');
	 if((!!lines) && lines.length > 0)
	 {
	   var first = lines[0];
	   if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
		 var views = "";
		 // 逐行渲染
		 for(var k=1; k <lines.length; k++){
			 var f=lines[k];
			 views += katex.renderToString(f);
		 }
		 // 消除父级嵌套 
		 try{
		   node.innerHTML=views;
		 }catch(e){
		   // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
		   console.log('IE9 sucks',e);
		   $(tr).html(node.innerHTML);
		 }
	   }
	 }
   }
   catch(err){
	 console.log(err)
   }
 }
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>