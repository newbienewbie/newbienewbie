<!DOCTYPE html><html>
  <head>
    <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie/"/>
    <script>
      document.addEventListener('DOMContentLoaded', () => {

	// Get all "navbar-burger" elements
	const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);
  
	// Check if there are any navbar burgers
	if ($navbarBurgers.length > 0) {
  
	  // Add a click event on each of them
	  $navbarBurgers.forEach( el => {
		el.addEventListener('click', () => {
  
		  // Get the target from the "data-target" attribute
		  const target = el.dataset.target;
		  const $target = document.getElementById(target);
  
		  // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
		  el.classList.toggle('is-active');
		  $target.classList.toggle('is-active');
  
		});
	  });
	}
  });
    </script>
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item" href="">
            Home
          </a>
          <a class="navbar-item" href="tags.html">
            Tags
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/Rust/智能指针/Rust智能指针4——引用计数型智能指针.html">
                    Rust智能指针4——引用计数型智能指针
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Rust
                      </a>
                    </li>
                    <li>
                      <a href="">
                        智能指针
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="/tags.html#Rust">
                    <span class="tag is-info">
                      Rust
                    </span>
                  </a>
                  <a href="/tags.html#智能指针">
                    <span class="tag is-info">
                      智能指针
                    </span>
                  </a>
                  <a href="/tags.html#引用计数">
                    <span class="tag is-info">
                      引用计数
                    </span>
                  </a>
                  <a href="/tags.html#Rc">
                    <span class="tag is-info">
                      Rc
                    </span>
                  </a>
                  <a href="/tags.html#Arc">
                    <span class="tag is-info">
                      Arc
                    </span>
                  </a>
                  <a href="/tags.html#RefCell">
                    <span class="tag is-info">
                      RefCell
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-02-28
                </p>
              </div>
              <div class="content article-body">
                <p>智能指针并非什么新概念，<code>C++</code>里随处可见。所谓智能指针，其本身是一个数据结构，可以表现得像一个指针(得益于<code>Deref</code>)，往往还能自动析构资源(益于<code>Drop</code>)。</p>
<p><code>Rust</code>在标准库中提供了很多种智能指针。这篇笔记要说的都是引用计数型指针，比如</p>
<ol>
<li><code>Rc&lt;T&gt;</code>(及<code>std::rc::Weak&lt;T&gt;</code>) : 引用计数型智能指针，适用于单线程场景的共享。</li>
<li><code>Arc&lt;T&gt;</code>(及<code>std::sync::Weak&lt;T&gt;</code>) ：原子的引用计数型智能指针，适用于多线程场景的共享。</li>
<li><code>RefCell&lt;T&gt;</code>等。</li>
</ol>
<h2><code>std::rc::Rc&lt;T&gt;</code>及<code>std::rc::Weak&lt;T&gt;</code></h2>
<p>所谓<code>Rc</code>，意指<code>Reference Count</code>，也即“引用计数”。还记得 <a href="http://www.itminus.com/blog/2017/12/29/WindWhisper/Rust/%E6%89%80%E6%9C%89%E6%9D%83%E7%B3%BB%E7%BB%9F/%E6%89%80%E6%9C%89%E6%9D%83%E7%B3%BB%E7%BB%9F1%E2%80%94%E2%80%94%E4%B8%96%E7%95%8C%E8%A7%82/">所有权规则</a> 吗？</p>
<blockquote>
<ol>
<li><code>Rust</code>中每个值都有一个相应的变量，称之为<code>owner</code>。</li>
<li>一个值在一个时刻只能有一个<code>owner</code>。</li>
<li>一旦到了作用域(<code>scope</code>)之外，与<code>owner</code>相应的值就会被丢弃(<code>drop</code>)。</li>
</ol>
</blockquote>
<p>为了不<code>Move</code>所有权，我们又引入了<code>Copy</code>或者<code>Borrow</code>的概念。但是不管怎么说，<code>Rust</code>里是强调“单所有权”的，也即资源只能从属于单个<code>owner</code>。单所有权有效的保证了内存安全，不过也带来了很大的不方便。拷贝意味着更大的性能消耗和无法改变原对象；而即便是引用和可变引用，用起来也有很多不便之处，比如遭人烦的生命周期检查问题。 <!--more--></p>
<h3><code>Rc&lt;T&gt;</code></h3>
<p><code>std::rc::Rc&lt;T&gt;</code>，采用了引用计数的方式，让<code>Rust</code>在形式上拥有了“多所有权”的能力。<code>Rc::clone()</code>并不会对数据做深拷贝，每当我们调用<code>Rc::clone()</code>函数，对相关数据的内部引用计数都会<code>+=1</code>，然后返回另一个对象供再使用。一旦这个返回对象<code>scope</code>结束，就会触发引用计数<code>-=1</code>。当内部的引用计数降到0，相关数据就会被清理。</p>
<ul>
<li><code>Rc::new(T)</code> :创建一个 <code>Rc&lt;T&gt;</code>智能指针</li>
<li><code>Rc::clone(&amp;rc): </code> 根据<code>Rc&lt;T&gt;</code>类型实例<code>rc</code>克隆出一个对象，会增加实例<code>rc</code>的引用计数，</li>
</ul>
<p><code>Rust Book</code> 中有<a href="https://doc.rust-lang.org/book/second-edition/ch15-04-rc.html#using-rct-to-share-data">一段代码</a>说明<code>Rc&lt;T&gt;</code>的“多所有权”作用，我们在此之上加了两句输出：</p>
<pre><code class="language-Rust">use List::{Cons, Nil};
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));

    if let Cons(v,ref x) = b {
        println!(&quot;{:?} {:?}&quot;,v,x);
    }
    if let Cons(v,ref x) = c {
        println!(&quot;{:?} {:?}&quot;,v,x);
    }
}
</code></pre>
<p>事实上，如果不用<code>Rc&lt;T&gt;</code>也可以做到共享数据，那就是多个不可变引用<code>&amp;T</code>机制：</p>
<pre><code class="language-Rust">#[derive(Debug)]
enum List&lt;'a&gt; {
    Cons(i32, &amp;'a List&lt;'a&gt;),
    Nil,
}

fn main() {
    let a = Cons(5, &amp;Nil);
    let b = Cons(3, &amp;a);
    let c = Cons(4, &amp;a);
    
    if let Cons(v,ref x) = b {
        println!(&quot;{:?} {:?}&quot;,v,x);
    }
    if let Cons(v,ref x)= c {
        println!(&quot;{:?} {:?}&quot;,v,x);
    }
}
</code></pre>
<p>以上两端代码都会输出：</p>
<pre><code>3 Cons(5, Cons(10, Nil))
4 Cons(5, Cons(10, Nil))
</code></pre>
<p>不过，<code>&amp;T</code>用起来蛋疼的地方在于要和生命周期检查作斗争，比如这里我们手工标注了<code>lifetime</code>，有时候对于复杂的数据结构，要光靠引用和<code>lifetime</code>，是非常吃力的。例如某个数据结构中有引用一个嵌套的对象，为了避免悬空引用，就必须让编译器确认，所引用的那个嵌套对象的<code>lifetime</code>绝对不会比外层数据结构的<code>lifetime</code>短。</p>
<h4><code>Rc&lt;T&gt;</code>局限性</h4>
<ol>
<li>尽管<code>Rc&lt;T&gt;</code>通过不可变引用，可以让我们在多处共享同一个数据，但是这种共享并不可变，</li>
<li>由循环引用问题，比如A引用B，B引用A，结果谁都无法计数归零。解决这个问题可以使用<code>Weak&lt;T&gt;</code></li>
<li><code>Rc&lt;T&gt;</code>只能用于单线程场景。要在多线程场景下使用，还需要<code>Rc&lt;T&gt;</code>的线程安全版本<code>Arc&lt;T&gt;</code>。</li>
</ol>
<h3><code>std::rc::Weak&lt;T&gt;</code></h3>
<p><code>std::rc::Weak</code>是<code>Rc</code>的弱引用版本，<code>Weak&lt;T&gt;</code>并不会增加计数，所以通常可用于解决循环引用问题：</p>
<ol>
<li>可访问，但不拥有，故不会增加引用计数</li>
<li>可由<code>Rc&lt;T&gt;::downgrade(&amp;T)</code>获取一个<code>Weak&lt;T&gt;</code></li>
<li><code>Weak&lt;T&gt;</code>类型可以使用<code>upgrade()</code>方法转换为<code>Option&lt;Rc&lt;T&gt;&gt;</code>类型，如果资源已经释放，则返回值为<code>Option::None</code></li>
</ol>
<p>一个示例：</p>
<pre><code class="language-Rust">fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;count={}&quot;,Rc::strong_count(&amp;a));                    // count=1
    let b = Cons(3, Rc::clone(&amp;a));                                  
    let c =Rc::downgrade(&amp;a);                                        
    println!(&quot;count={}&quot;,Rc::strong_count(&amp;a));                    // count=2
    {                                                             
        let d = Cons(4,Rc::clone(&amp;a));                            
        println!(&quot;count={}&quot;,Rc::strong_count(&amp;a));                // count=3
    }     // d 作用域结束
    if let Some(e) =c.upgrade(){
        println!(&quot;弱引用升级成功，count={}&quot;,Rc::strong_count(&amp;e)); // count=3
    }     // e 作用域结束
    println!(&quot;count={}&quot;,Rc::strong_count(&amp;a));                    // count=2
}
</code></pre>
<h2><code>std::sync::Arc&lt;T&gt;</code>及<code>std::sync::Weak&lt;T&gt;</code></h2>
<p><code>Rc</code>只适用于单线程的主要原因之一就是增减操作不是原子的。要在多线程场景下使用，就需要使用特殊的方式，确保引用计数的增减操作是原子的。</p>
<h3><code>std::sync::Arc&lt;T&gt;</code></h3>
<p><code>std::sync::Arc</code>是原子引用计数，可视作<code>Rc</code>的多线程版本。</p>
<ol>
<li><code>Arc</code>可跨线程传递，用于跨线程共享一个对象；</li>
<li>用<code>Arc</code>包裹起来的类型对象，对可变性没有要求；</li>
<li>一旦最后一个拥有者消失，则资源会被自动回收，这个生命周期是在编译期就确定下来的</li>
<li><code>Arc</code>可以视作一个引用，它不影响包裹对象的方法调用形式</li>
<li><code>Arc</code>对于多线程的共享状态几乎是必须的（减少复制，提高性能）。</li>
</ol>
<p>使用示例：</p>
<pre><code class="language-Rust">use std::sync::Arc;
use std::thread;

fn main() {
    let numbers: Vec&lt;_&gt; = (0..100u32).collect();
    let shared_numbers = Arc::new(numbers);

    for _ in 0..10 {
        let child_numbers = shared_numbers.clone();

        thread::spawn(move || {
            let local_numbers = &amp;child_numbers[..];
            // ...
        });
    }
}
</code></pre>
<h3><code>std::sync::Weak&lt;T&gt;</code></h3>
<p>与<code>std::rc::Rc</code>类似，<code>std::sync::Arc</code>也有一个对应的弱引用类型<code>std::sync::Weak</code>，可视作<code>std::rc::Weak</code>的多线程的版本。用法类似，不做赘述。</p>
<h2><code>RefCell&lt;T&gt;</code></h2>
<p>根据<code>Rust</code>的设计，<code>Rc</code>及<code>Arc</code>具备了共享性，他们就不能具备修改性。为了解决<code>修改性</code>问题，这需要使用<code>RefCell&lt;T&gt;</code>这个类型：</p>
<blockquote>
<p>Using <code>RefCell&lt;T&gt;</code> to be able to mutate an inner value while the outer value is considered immutable</p>
</blockquote>
<p><code>RefCell&lt;T&gt;</code>类型提供了<code>borrow()</code>和<code>borrow_mut()</code> 两个安全的方法。</p>
<ol>
<li><code>borrow()</code> 方法返回智能指针类型<code>Ref</code></li>
<li><code>borrow_mut()</code>方法返回智能指针类型<code>RefMut</code></li>
</ol>
<p>由于<code>Ref</code>和<code>RefMut</code>这两个类型都实现了<code>Deref </code>，所以我们可以当作普通引用那样使用之。<code>RefCell&lt;T&gt;</code>对象会追踪当前有多少<code>Ref</code>和<code>RefMut</code>智能指针是有效的。 每次我们调用<code>borrow()</code>, <code>RefCell&lt;T&gt;</code>就会增加不可变借用计数，而当一个<code>Ref</code>值的作用域结束, 不可变借用的计数就会减1。</p>
<p>就像之前编译期借用规则中说的那样，<code>RefCell&lt;T&gt;</code>也只允许我们在任一个时间点上，可以有多个不可变借用，或者唯一一个可变借用。如果我们试图违反这个规则，<code>Rust</code>并不会像使用普通引用那样在编译期就报错，而是会在运行时<code>panic!</code>。</p>
<h4>局限性</h4>
<p>根据上文所述，<code>RefCell</code>也是采用了简单的引用计数，所以<code>Rust</code>规定，它只适用于单线程场景。</p>
<h2><code>Rc&lt;T&gt;</code>和<code>RefCell&lt;T&gt;</code>配合使用</h2>
<p><code>Rc&lt;T&gt;</code>在形式上给了我们“多所有者”的能力(不可变的访问)，<code>RefCell&lt;T&gt;</code>给我们以改变不可变对象内部数据的能力，把这二者结合起来——简单的说，就是让<code>Rc&lt;T&gt;</code>包含一个<code>RefCell&lt;T&gt;</code>——就能拥有一个类型，其值可以有多个所有者，而且我们还能改变它！</p>
<p>以下这个例子来自 <a href="https://doc.rust-lang.org/book/second-edition/ch15-05-interior-mutability.html#having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt">《The Rust Programming Language》</a></p>
<pre><code class="language-Rust">use List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&quot;a after = {:?}&quot;, a);
    println!(&quot;b after = {:?}&quot;, b);
    println!(&quot;c after = {:?}&quot;, c);
}
</code></pre>
<h2><code>Arc&lt;T&gt;</code>和<code>Mutex</code>配合使用</h2>
<p><code>Arc&lt;T&gt;</code>给了我们跨线程共享数据的能力，<code>Mutex</code>给了我们锁和修改的能力，把二者结合起来，就能跨进程修改同一个变量！</p>
<pre><code class="language-Rust">use std::sync::Arc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let global = Arc::new(Mutex::new(0));

    let clone1 = global.clone();
    let h1= thread::spawn(move|| {
        for _ in 0..100{
            let mut value = clone1.lock().unwrap();
            *value += 1;
            println!(&quot;from thread1 : current={}&quot;,value);
            thread::sleep(std::time::Duration::from_secs(1));
        }
    });

    let clone2 = global.clone();
    let h2= thread::spawn(move|| {
        for _ in 0..100{
            let mut value = clone2.lock().unwrap();
            *value -= 1;
            println!(&quot;from thread2 : current={}&quot;,&amp;value);
            thread::sleep(std::time::Duration::from_secs(1));
        }
    });

    h1.join().ok();
    h2.join().ok();
    println!(&quot;at last value= {:?}&quot;, global);
}
</code></pre>
<h2>小结</h2>
<ol>
<li>引用计数型指针<code>Rc&lt;T&gt;</code>和<code>RefCell</code>可以用于单线程版本，虽然各自都有不足，但是结合起来就可以实现单线程下多所有者、内部可变的访问能力(也要满足同一时刻下要么有任意个只读引用、要么只有一个可变引用)。</li>
<li><code>Weak</code>是<code>Rc</code>的弱引用版本，由于不增加引用计数，可以用于处理循环引用的情况。</li>
<li>在并发情况下，<code>Arc&lt;T&gt;</code>提供了和<code>Rc&lt;T&gt;</code>类似的能力，是<code>Rc&lt;T&gt;</code>的线程安全版本。和<code>Mutex</code>连用，可以实现多进程下同时修改同一个变量。</li>
</ol>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
       // 处理形如 <code>$E=mc^2$</code> 形式的公式
 var inlineMathNodes=document.querySelectorAll('code');
 var re=/^\$(.*)\$$/;
 for(var j=0;j<inlineMathNodes.length;j++){
   var result=re.exec(inlineMathNodes.item(j).innerText);
   if(result!==null){
	 katex.render(result[1], inlineMathNodes.item(j));
   }
 }
 function removeNode(node){
   if(node.remove){
	 node.remove();
   }else{
	 return first.parentNode.removeChild(node);
   }
 };

 // 查找所有 pre code.language-math 节点 以备筛出数据公式
 var nodes=document.querySelectorAll("pre code.language-math");
 for(var i=0;i<nodes.length;i++){
   var node=nodes.item(i);
   // 魔术标记所在行 
   try{
	 var lines = node.innerText.split('\n');
	 if((!!lines) && lines.length > 0)
	 {
	   var first = lines[0];
	   if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
		 var views = "";
		 // 逐行渲染
		 for(var k=1; k <lines.length; k++){
			 var f=lines[k];
			 views += katex.renderToString(f);
		 }
		 // 消除父级嵌套 
		 try{
		   node.innerHTML=views;
		 }catch(e){
		   // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
		   console.log('IE9 sucks',e);
		   $(tr).html(node.innerHTML);
		 }
	   }
	 }
   }
   catch(err){
	 console.log(err)
   }
 }
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>