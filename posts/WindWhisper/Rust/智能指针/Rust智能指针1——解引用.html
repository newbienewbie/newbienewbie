<!DOCTYPE html><html>
  <head>

        <script type="text/javascript">
          var wsUri = "ws://localhost:8080/websocket";
      function init()
      {
        websocket = new WebSocket(wsUri);
        websocket.onclose = function(evt) { onClose(evt) };
      }
      function onClose(evt)
      {
        console.log('closing');
        websocket.close();
        document.location.reload();
      }
      window.addEventListener("load", init, false);
      </script>
            <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item" href="">
            Home
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/Rust/智能指针/Rust智能指针1——解引用.html">
                    Rust智能指针1——解引用
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-02-27
                </p>
              </div>
              <div class="content article-body">
                <p>本文是正式开始智能指针学习之前的基础知识之一：解引用。</p>
<p><code>Deref</code>这个<code>trait</code>允许我们在一定形式上重载<code>*</code>操作符。换言之，通过智能指针实现<code>Deref</code>的方式，就能让智能指针被当作一个普通引用来使用：在那些需要操作引用的地方，我们也可以直接使用智能指针。</p>
<h2><code>*</code>操作符的工作机制</h2>
<p>在本质上，<code>Rust</code>中的常规引用是与<code>C</code>语言中的指针相等价的，而<code>*</code>操作符所做的就是解引用。以下这段<code>Rust</code>代码和<code>C</code>的指针用法完全一致：</p>
<pre><code class="language-Rust">fn main() {
    let x = 42;
    let y = &amp;x;

    assert_eq!(42, x);
    assert_eq!(42, *y);
}
</code></pre>
<p>在上述例子中，<code>y</code>是个常规引用，<code>*</code>操作符会顺着指针进行取值。事实上，如果一个任意类型实现了<code>Deref</code>，<code>Rust</code>编译器就会自动对<code>*</code>解引用操作进行替换：先进行<code>Deref</code>的<code>deref()</code>方法调用，然后再对返回值进行一个普通的解引用。</p>
<p>举个例子，为了获取宇宙的终极奥秘，我们写一个任意类型：</p>
<!--more-->
<pre><code class="language-Rust">use std::ops::Deref;

struct Anything&lt;T&gt;(T);

impl&lt;T&gt; Anything&lt;T&gt; {
    fn new(x: T) -&gt; Anything&lt;T&gt; {
        Anything(x)
    }
}

impl&lt;T&gt; Deref for Anything&lt;T&gt; {
    type Target = T;            // 定义关联类型
    fn deref(&amp;self) -&gt; &amp;T {     // 注意，返回引用
        &amp;self.0
    }
}
</code></pre>
<p>当我们进行解引用操作：</p>
<pre><code class="language-Rust">fn main() {
    let anything=Anything::new(42);
    assert_eq!(42,*anything);
}
</code></pre>
<p><code>Rust</code>编译器会先调用<code>Deref</code>中的<code>deref()</code>方法，返回自身的第一个字段引用，然后再进行普通的解引用，得到字段值。也就是说，<code>Rust</code>编译器会自动将上述<code>*y</code>转换为：</p>
<pre><code class="language-Rust">*(y.deref())
</code></pre>
<p>这一切都是编译期发生的事，并没有运行时负担。第一次看到这种方式解引用的时候，我心中有个疑惑：为什么<code>Rust</code>不规定<code>Deref</code>的<code>deref()</code>方法直接返回真正的对象，而要再绕一步地进行普通<code>*</code>解引用？原因在于<code>Rust</code>的所有权系统。如果这里<code>deref()</code>方法返回的不是一个引用类型，那么该值的所有权就会随着<code>deref()</code>方法的返回被转移出去，从而导致自身再也没办法使用该值。这也是<code>Rust</code>的<code>*</code>操作符是对<code>deref()</code>返回的引用再常规解引用的原因。</p>
<h2>强制解引用</h2>
<p>显然，对于实现了<code>Deref</code>的类型的引用，可以根据<code>deref()</code>方法转换为其他类型的引用。当我们将特定类型的引用作为参数，传递给函数(或方法)时，如果编译器发现参数的类型并不严格匹配函数(或方法)的定义，就会隐式产生一系列<code>deref()</code>，来把我们实际提供的类型转换成参数所需的类型。这一切都是自动发生的，称之为 <em>deref coercion</em> 。</p>
<p>举个例子，假设现有一个函数，接受一个<code>&amp;str</code>型参数，然后输出宇宙的终极答案:</p>
<pre><code class="language-Rust">fn foo(s :&amp;str){
    println!(&quot;the answer is : {}&quot;,s);
}
</code></pre>
<p>然后我们可以在不重写这个函数定义的前提下，就进行这样调用：</p>
<pre><code class="language-Rust">fn main() {
    let anything=Anything::new(&quot;42&quot;);
    foo(&amp;anything);

    let anything=Anything::new(String::from(&quot;42&quot;));
    foo(&amp;anything);
}
</code></pre>
<p>原因在于，<code>Rust</code>编译器发现<code>foo()</code>函数接受的应是<code>&amp;str</code>类型，但是我们提供了<code>&amp;Anything&lt;&gt;</code>类型。由于<code>Anything&lt;&gt;</code>类型是个<code>Deref</code>，然后就会顺着<code>Deref</code>的<code>deref()</code>提取：</p>
<ol>
<li>在第一个示例中，实际传递的<code>&amp;Anything&lt;&amp;str&gt;</code>并不符合函数定义，但是<code>Anything&lt;String&gt;</code>是个<code>Deref</code>，所以编译器自动为我们插入<code>deref()</code>的调用代码，拿到了<code>&amp;str</code>，最后才进行<code>foo()</code>函数调用。</li>
<li>在第二个示例中，实际传递的<code>&amp;Anything&lt;String&gt;</code>也不符合函数定义，所以先通过<code>Anything&lt;String&gt;</code>的<code>deref()</code>返回了 <code>&amp;String</code>型，此时仍然不满足要求；又由于<code>String</code>同样也是个<code>Deref</code>，还会继续<code>deref()</code>，拿到一个 <code>string slice</code>，也就是<code>&amp;str</code>类型，最终匹配函数定义。</li>
</ol>
<p>值得说明的是<code>deref coercion</code>是编译期发生的事，属于零成本抽象。类似于<code>Deref</code>，为了重载<code>mutable reference</code>的<code>*</code>行为，<code>Rust</code>还提供了<code>DerefMut Trait</code>。在以下三种情况下，会触发<code>deref coercion</code>：</p>
<ol>
<li>当<code>T: Deref&lt;Target=U&gt;</code>，可将<code>&amp;T</code>转换为<code>&amp;U</code></li>
<li>当<code>T: Deref&lt;Target=U&gt;</code>，可将<code>&amp;mut T</code>转换为<code>&amp;U</code></li>
<li>当<code>T: DerefMut&lt;Target=U&gt;</code>，可将<code>&amp;mut T</code>转换为<code>&amp;mut U</code></li>
</ol>
<h2>小结</h2>
<p>从本质上说，<code>Deref</code>和<code>DerefMut</code>给了类型以重载解引用的能力，基于这种机制，我们可以让包装类型的引用表现的和常规引用一样。<code>Deref</code>的这种特性是智能指针和常规引用的重要区别之一。</p>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
      
 // 处理形如 <code>$E=mc^2$</code> 形式的公式
  var inlineMathNodes=document.querySelectorAll('code');
  var re=/^\$(.*)\$$/;
  for(var j=0;j<inlineMathNodes.length;j++){
    var result=re.exec(inlineMathNodes.item(j).innerText);
    if(result!==null){
      katex.render(result[1], inlineMathNodes.item(j));
    }
  }
  function removeNode(node){
    if(node.remove){
      node.remove();
    }else{
      return first.parentNode.removeChild(node);
    }
  };

  // 查找所有 pre code.language-math 节点 以备筛出数据公式
  var nodes=document.querySelectorAll("pre code.language-math");
  for(var i=0;i<nodes.length;i++){
    var node=nodes.item(i);
    // 魔术标记所在行 
    try{
      var lines = node.innerText.split('\n');
      if((!!lines) && lines.length > 0)
      {
        var first = lines[0];
        if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
          var views = "";
          // 逐行渲染
          for(var k=1; k <lines.length; k++){
              var f=lines[k];
              views += katex.renderToString(f);
          }
          // 消除父级嵌套 
          try{
            node.innerHTML=views;
          }catch(e){
            // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
            console.log('IE9 sucks',e);
            $(tr).html(node.innerHTML);
          }
        }
      }
    }
    catch(err){
      console.log(err)
    }
  }
    
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>