<!DOCTYPE html><html>
  <head>
    <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie/"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item" href="">
            Home
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/Python/Python-类与三个内置装饰器.html">
                    Python 类与三个内置装饰器
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-03-12
                </p>
              </div>
              <div class="content article-body">
                <p>在<a href="http://www.itminus.com/2015/04/10/WindWhisper/Python/Python%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">Python函数装饰器原理分析</a>中说到，Python有几个内置装饰器：</p>
<ul>
<li>类属性<code>@property</code></li>
<li>静态方法<code>@staticmethod</code></li>
<li>类方法<code>@classmethod</code></li>
</ul>
<p>可以用来包装属性、静态方法、和类方法。</p>
<p>首先要说明，本文中所有的类都使用的新式类，即使使用了Python2.7.x版本，某些特性在“old-style”类中也不适用。要使用新式类，有两种方法：</p>
<ol>
<li>在<code>module</code>顶部添加语句：<code>__metaclass__ = type</code></li>
<li>定义的类要是内置<code>object</code>对象的子类。</li>
</ol>
<h2><code>staticmethod</code>和<code>classmethod</code></h2>
<p>静态方法和类方法都是不需要具体实例就可以运行的。区别在于<code>classmethod</code>的第一个参数是<code>cls</code>，这是个对“类”的引用。可以通过<code>cls</code>对类的属性进行获取。</p>
<p>在没有装饰器的情况下，我们可以使用原始的<code>staticmethod()</code>和<code>classmethod()</code>函数来定义静态方法和类方法：</p>
<pre><code class="language-Python">class MyClass:
    
    a=3

    def my_static_method():
        print('This is a static method')
    my_static_method = staticmethod(my_static_method)

    def my_class_method(cls,sth):
        print('This is a class method of', cls.a,sth)
    my_class_method = classmethod(my_class_method)
</code></pre>
<p>有了装饰器语法糖，以上代码可以改写为：</p>
<pre><code class="language-Python">class MyClass:

    a=3

    @staticmethod
    def my_static_method():
        print('This is a static method')

    @classmethod
    def my_class_method(cls,sth):
        print('This is a class method of', cls.a,sth)
</code></pre>
<h2>property</h2>
<p>假设现在有个矩形，可以设置其宽、高。</p>
<ul>
<li>如果需要面积，我们可以使用类似于<code>area()</code>的方法来计算。</li>
<li>如果需要周长，我们可以使用类似于<code>perimeter()</code>的方法来计算。</li>
</ul>
<p>现在问题来了，类的用户获取宽度的时候用的是<code>rect.width</code>，获取面积的时候却要使用<code>rect.area()</code>，多了一个冒号！对于这种简单的情况用户似乎还可以分辨，问题是对于一些复杂的类如何保持一致呢？</p>
<p><code>Java</code>中的惯用方法是定义私有的<code>width</code>、<code>height</code>，然后定义公有方法<code>getWidth()</code>、<code>getHeight()</code>、<code>getArea()</code>、<code>getPerimeter()</code>。<code>C#</code>的惯用方法是采用：</p>
<pre><code class="language-CSharp">class Rectangle {
    public double Width { get; set; }
    public double Height { get; set; }
    public double Area {
        get{ return Width*Height; }
    }
    public double Perimeter {
        get{ return (Width+Height)*2; }
    }
}
</code></pre>
<p>对于<code>Python</code>这种动态语言来说，上<code>Java</code>那一套是不符合价值观的，可以用<code>perperty()</code>加以包装：</p>
<pre><code class="language-Python">class Rectangle(object):
    def __init__ (self,width,height):
        self.__width = width
        self.__height = height

    def get_width(self):
        return self.__width
    def set_width(self, size):
        self.__width= size
    width=property(get_width,set_width)
    
    def get_height(self):
        return self.__height
    def set_height(self,size):
        self.__height=size
    height=property(get_height,set_height)

    def area(self):
        return self.width*self.height
    area=property(area)
    

    def perimeter(self):
        return (self.width+self.height)*2
    perimeter=property(perimeter)
</code></pre>
<p>这样，就使用了<code>property()</code>函数包装出了<code>width</code>、<code>height</code>、<code>area</code>、<code>perimeter</code>三个特性:</p>
<pre><code class="language-Python">rect=Rectangle(3,4)
rect.width=5
rect.height=6
print(rect.width)
print(rect.height)
print(rect.area)
print(rect.perimeter)
</code></pre>
<p>有了装饰器语法，以上代码可以简化为：</p>
<pre><code class="language-Python">class Rectangle(object):
    def __init__ (self,width,height):
        self.__width = width
        self.__height = height

    @property
    def width(self):
        return self.__width
    
    @width.setter
    def width(self, size):
        self.__width= size
    
    @property
    def height(self):
        return self.__height
    
    @height.setter
    def height(self,size):
        self.__height=size

    @property
    def area(self):
        return self.width*self.height
    
    @property
    def perimeter(self):
        return (self.width+self.height)*2
</code></pre>
<h2>Property 魔法</h2>
<p>利用<code>@property</code>装饰一个方法函数，看起来非常完美。但是有一个问题，经过<code>property()</code>函数返回的还是一个函数，为什么<code>Python</code>可以直接通过<code>rect.width</code>这种普通属性语法拿到宽度值呢？</p>
<p>这其实是<code>Python</code>的魔法：<code>property</code>返回了一种特殊的属性，访问时会计算它的值！如果没有<code>property</code>，则会以简单属性的方式去访问。</p>
<p>事实上，<code>Python</code>类实例方法的调用也是很意思的，对于这样一个类：</p>
<pre><code class="language-Python">class Foo(object):
    def bar(self,x):
        return x
</code></pre>
<p>实例方法的调用某种程度上可以认为是这样：</p>
<pre><code class="language-Python">foo=Foo()
bar=foo.bar    # 这里返回的方法不是原始的bar函数，是绑定方法对象
bar(x)
</code></pre>
<p>首先获取 Foo 类的 bar 的绑定方法（<code>bound method</code>）对象，它类似于<code>partial</code>方法，已经绑定了<code>self</code>参数，显然，这个绑定方法并原始的函数对象 bar。绑定方法对象是由在后台执行的特性函数静默创建的！</p>
<p><code>@staticmethod</code> <code>@classmethod</code> 定义静态方法和类方法时，实际上就指定了使用不同的特性函数，以不同的方式处理对这些方法的访问。<code>staticmethod</code>表明按原样返回方法函数，不会进行任何包装。</p>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
      
 // 处理形如 <code>$E=mc^2$</code> 形式的公式
  var inlineMathNodes=document.querySelectorAll('code');
  var re=/^\$(.*)\$$/;
  for(var j=0;j<inlineMathNodes.length;j++){
    var result=re.exec(inlineMathNodes.item(j).innerText);
    if(result!==null){
      katex.render(result[1], inlineMathNodes.item(j));
    }
  }
  function removeNode(node){
    if(node.remove){
      node.remove();
    }else{
      return first.parentNode.removeChild(node);
    }
  };

  // 查找所有 pre code.language-math 节点 以备筛出数据公式
  var nodes=document.querySelectorAll("pre code.language-math");
  for(var i=0;i<nodes.length;i++){
    var node=nodes.item(i);
    // 魔术标记所在行 
    try{
      var lines = node.innerText.split('\n');
      if((!!lines) && lines.length > 0)
      {
        var first = lines[0];
        if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
          var views = "";
          // 逐行渲染
          for(var k=1; k <lines.length; k++){
              var f=lines[k];
              views += katex.renderToString(f);
          }
          // 消除父级嵌套 
          try{
            node.innerHTML=views;
          }catch(e){
            // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
            console.log('IE9 sucks',e);
            $(tr).html(node.innerHTML);
          }
        }
      }
    }
    catch(err){
      console.log(err)
    }
  }
    
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>