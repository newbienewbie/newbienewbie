<!DOCTYPE html><html>
  <head>

        <script type="text/javascript">
          var wsUri = "ws://localhost:8080/websocket";
      function init()
      {
        websocket = new WebSocket(wsUri);
        websocket.onclose = function(evt) { onClose(evt) };
      }
      function onClose(evt)
      {
        console.log('closing');
        websocket.close();
        document.location.reload();
      }
      window.addEventListener("load", init, false);
      </script>
            <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie/"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item" href="">
            Home
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/CSharp/Bot Framework/BotBuilder 源码通读1.html">
                    BotBuilder 源码通读1 —— A Big Picture
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2019-01-17
                </p>
              </div>
              <div class="content article-body">
                <pre><code>+---------------+     +-----------+                                  +---------------+
|               |     |           |                                  |               |
|  ASP.NET Core +-----&gt;           |                            +-----&gt;  QnA Services |                   
|               &lt;-----+           |                            |     |               |
+---------------+     |           |                            |     +-------------- +
                      |           |                            |     +---------------+
                      |           +-------------+ +--------+   |     |               |
+---------------+     |           |             | |        |   +-----&gt; Luis Services |
|               |     |           |             --&gt;        |   |     |               |
|  ASP.NET Web  +-----&gt; BotAdapter| Middlewares | |  IBot  +---&gt;     +---------------+
|               &lt;-----+           |             &lt;--        |                         
+---------------+     |           |             | |        |   |     +---------------+
                      |           +-------------+ +--------+   |     |               |
+---------------+     |           |                            |     |   ... Other   |
| Console App   |     |           |                            +-----&gt;   Connected   |
|     ...       +-----&gt;           |                                  |    Services   |
|  other apps   |     |           |                                  |               |
+---------------+     +-----------+                                  +---------------+
</code></pre>
<!-- more -->
<h2><code>IBot</code></h2>
<p><code>IBot</code>代表了对聊天机器人抽象：</p>
<pre><code class="language-csharp">public interface IBot
{
    Task OnTurnAsync(ITurnContext turnContext, CancellationToken cancellationToken = default(CancellationToken));
}
</code></pre>
<p>该接口只有唯一的一个方法<code>OnTurnAsync(context,ct)</code>，旨在处理收到的<code>Activity</code>。注意:</p>
<ol>
<li><code>IBot</code>并不关心<code>Activity</code>是怎么来的，也不关心具体如何发出<code>Activity</code>，他只负责处理<code>TurnContext</code>。</li>
<li><code>IBot</code>并不关心<code>TurnContext</code>是如何构建的，这是外层<code>BotAdapter</code>的事情</li>
<li><code>IBot</code>的<code>OnTurnAsync(context,ct)</code>方法并不接收<code>next</code>参数，这是因为该接口方法是作为中间件集的最内层（回调函数）调用——这在后文中会解释。</li>
</ol>
<h2><code>BotAdapter</code></h2>
<p><code>BotAdapter</code>代表聊天机器人和各种<code>Endpoint Service</code>之间的适配器。每当收到活动，适配器就会提取必要信息(诸如身份信息之类)，创建相应的聊天上下文<code>ITurnContext</code>；然后调用<code>RunPipelineAsync(context, callback,ct)</code>触发中间件依次调用，完成之后会回调<code>IBot</code>的<code>OnTurnAsync(context)</code>；最后，拿到结果，发送给channel。</p>
<p><code>BotAdapter</code>是一个抽象类，提供了三组<code>API</code>：</p>
<ul>
<li>中间件注册: 利用<code>Use()</code>方法向内部的<code>MiddlewareSet</code>属性注册中间件</li>
<li>会话流（中间件调用）:<code>ContinueConversationAsync()</code>。从本质上说，会话流其实就是中间件调用的过程</li>
<li>活动相关的抽象方法：发送<code>Activity</code>、更新<code>Update</code>、删除<code>Activity</code>，均为抽象方法，留待具体的子类实现</li>
</ul>
<p><strong>中间件注册</strong></p>
<pre><code class="language-csharp">public abstract class BotAdapter
{
    protected MiddlewareSet MiddlewareSet { get; } = new MiddlewareSet();
    
    // ...
    
    // 注册中间件
    public BotAdapter Use(IMiddleware middleware)
    {
        MiddlewareSet.Use(middleware);
        return this;
    }
    
    // ...
}

</code></pre>
<p><strong>会话流（中间件调用）</strong></p>
<pre><code class="language-csharp">public abstract class BotAdapter
{
    // ...
       
    public virtual Task ContinueConversationAsync(string botId, ConversationReference reference, Func&lt;ITurnContext, Task&gt; callback, CancellationToken cancellationToken)
    {
        using (var context = new TurnContext(this, reference.GetContinuationActivity()))
        {
            return RunPipelineAsync(context, callback, cancellationToken);
        }
    }

    protected async Task RunPipelineAsync(ITurnContext context, BotCallbackHandler callback,  CancellationToken cancellationToken)
    {
        BotAssert.ContextNotNull(context);
        if (context.Activity != null){
            try {
                // 传入callback作为中间件集的最内层
                await MiddlewareSet.ReceiveActivityWithStatusAsync(context, callback, cancellationToken).ConfigureAwait(false);
            } catch (Exception e) {
                // ... 错误处理
            }
        }else {
            if (callback != null){
                await callback(context).ConfigureAwait(false);
            }
        }
    }
}
</code></pre>
<p>注意：<code>RunPipelineAsync()</code>接收一个<code>BotCallbackHandler</code>委托类型作为回调参数。其实该委托类型就是<code>Func&lt;ITurnContext,CancellationToken,Task&gt;</code>：</p>
<pre><code class="language-csharp">public delegate Task BotCallbackHandler(ITurnContext turnContext, CancellationToken cancellationToken);
</code></pre>
<p><strong>当<code>BotAdapter</code>自身中间件全部调用完成后会触发该回调</strong>。事实上，在与<code>ASP.NET Core</code>集成时，<code>IBot::OnTurnAsync()</code> 方法就是作为回调函数传入<code>RunPipelineAsync()</code>的。换言之，<strong><code>IBot</code>的<code>OnTurnAsync()</code>是作为中间件集的最内层参与调用的</strong>。</p>
<p>此外，<code>BotAdapter</code>还规定了几个抽象方法用于如何处理活动：</p>
<pre><code class="language-csharp">public abstract class BotAdapter
{
    // 异步地发出活动
    public abstract Task&lt;ResourceResponse[]&gt; SendActivitiesAsync(ITurnContext context, Activity[] activities, CancellationToken cancellationToken);

    // 异步地更新活动
    public abstract Task&lt;ResourceResponse&gt; UpdateActivityAsync(ITurnContext context, Activity activity, CancellationToken cancellationToken);

    // 异步地删除活动
    public abstract Task DeleteActivityAsync(ITurnContext context, ConversationReference reference, CancellationToken cancellationToken);
}
</code></pre>
<p>这些抽象方法留待继承自<code>BotAdapter</code>的子类去实现。借助<code>BotAdapter</code>，<code>Bot</code>可以独立于具体的服务：比如可以构筑于<code>Website</code>之上，借助于<code>HTTP</code>传输活动；甚至可以构建于一个控制台适配器之上，例如可能有类似如下的代码：</p>
<pre><code class="language-csharp">// 创建一个控制台适配器
var adapter = new ConsoleAdapter()    // 自定义的ConsoleAdapter类
    // 为适配器添加中间件
    .Use(/*...*/);

// 创建一个聊天机器人
var echoBot = new EchoBot();

// 连接适配器和机器人 
adapter.ProcessActivity(async (context) =&gt; await echoBot.OnTurn(context))
    .Wait();
</code></pre>
<p>这里的<code>ProcessActivity()</code>方法是<code>ConsoleAdapter</code>的自定义方法，只是负责构建<code>OnTurnContext</code>，该方法会调用具体的<code>Bot</code>处理相关逻辑。</p>
<h3><code>BotFrameworkAdapter</code></h3>
<p>上文说到，<code>IBot</code>并不关心如何接收<code>Activity</code>，也不关心具体如何传输<code>Activity</code>，这些工作是外层的<code>BotAdapter</code>完成的。具体的适配器还需要根据收到的<code>Activity</code>创建<code>TurnContext</code>。然后触发中间件调用<code>RunPipelineAsync(context, callback, cancellationToken)</code>。比如<code>BotFrameworkAdapter</code>作为<code>BotAdapter</code>的子类，提供了一个名为<code>ProcessActivityAsync</code>的方法:</p>
<pre><code class="language-csharp">public async Task&lt;InvokeResponse&gt; ProcessActivityAsync(ClaimsIdentity identity, Activity activity, BotCallbackHandler callback, CancellationToken cancellationToken)
{
    using (var context = new TurnContext(this, activity))
    {
        // ...
        await RunPipelineAsync(context, callback, cancellationToken).ConfigureAwait(false);
        // ...
    }
    
    return null;
}
</code></pre>
<p>可以看到，该<code>ProcessActivity(id,activity,cb,ct)</code>方法会根据<code>Activity</code>创建<code>TurnConext</code>，并转而调用<code>RunPipelineAsync(ctx,cb,ct)</code>方法，从而触发中间件调用及<code>IBot</code>的<code>OnTurnAsync()</code>的执行。</p>
<h3>与 ASP.NET Core 集成</h3>
<p>其实，从上文分析过程中，我们已经发现了与其他应用集成的基本思路：</p>
<ul>
<li>找到<code>BotAdapter</code>实现</li>
<li>找到<code>IBot</code>实现</li>
<li>构建<code>Activity</code>，</li>
<li>构建<code>TurnContext</code></li>
<li>调用<code>RunPipelineAsync(ctx,cb,ct)</code>，从而触发<code>BotAdapter</code>的各中间件执行及<code>IBot::OnTurnAsync()</code>回调</li>
</ul>
<p>第一步和第二步可以借助于依赖注入实现，所以在<code>ASP.NET Core</code>中使用时，要先要注册<code>IBot</code>服务；然后再注册<code>ASP.NET Core</code>框架的中间件触发<code>RunPipeline(ctx,cb,ct)</code>的执行：</p>
<pre><code class="language-csharp">public void ConfigureServices(IServiceCollection services)
{
     services.AddBot&lt;YourBot&gt;(options =&gt;{
         // ...
     });
}

public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
{
    app.UseDefaultFiles()
        .UseStaticFiles()
        .UseBotFramework();
}
</code></pre>
<p><strong><code>ASP.NET Core</code>服务注册</strong></p>
<p>通常在与<code>ASP.NET Core</code>集成时，用户需要添加两个服务：</p>
<ol>
<li><code>IBot</code>服务：瞬态的</li>
<li><code>IAdapterIntegration</code>服务: 通过<code>TryAddBotFrameworkAdapterIntegration()</code>注册一个<code>IAdapterIntegration</code>单例工厂<code>BotFrameworkAdapterSingletonFactory</code>。该工厂只是简单的创建一个<code>BotFrameworkAdapter</code>对象，并<code>Options</code>中配置的中间件都注册到其中间件集中。</li>
</ol>
<pre><code class="language-csharp">public static IServiceCollection AddBot&lt;TBot&gt;(this IServiceCollection services, Func&lt;IServiceProvider, TBot&gt; botFactory, Action&lt;BotFrameworkOptions&gt; configureAction = null)
    where TBot : class, IBot
{
    if (services == null) {/* throw  */}
    if (botFactory == null) {/* throw  */}

    if (configureAction != null) {
        services.Configure(configureAction);
    }

    return services
        .TryAddBotFrameworkAdapterIntegration()
        .AddTransient&lt;IBot&gt;(botFactory);
}

private static BotFrameworkAdapter BotFrameworkAdapterSingletonFactory(IServiceProvider serviceProvider)
{
    var options = serviceProvider.GetRequiredService&lt;IOptions&lt;BotFrameworkOptions&gt;&gt;().Value;
    var logger = serviceProvider.GetRequiredService&lt;ILogger&lt;IAdapterIntegration&gt;&gt;();

    var botFrameworkAdapter = new BotFrameworkAdapter(
        options.CredentialProvider,
        options.ChannelProvider,
        options.ConnectorClientRetryPolicy,
        options.HttpClient,
        null,
        logger)
    {
        OnTurnError = options.OnTurnError,
    };

    foreach (var middleware in options.Middleware)
    {
        botFrameworkAdapter.Use(middleware);
    }

    return botFrameworkAdapter;
}
</code></pre>
<p><strong><code>ASP.NET Core</code>中间件调用</strong></p>
<p><code>app.UseBotFramework()</code>的核心是针对特定<code>path</code>的请求进行处理：</p>
<pre><code class="language-csharp">public static IApplicationBuilder UseBotFramework(this IApplicationBuilder applicationBuilder)
{
    // ...
    
    applicationBuilder.Map(
        paths.BasePath + paths.MessagesPath,
        botAppBuilder =&gt; botAppBuilder.Run(new BotMessageHandler().HandleAsync)
    );
}
</code></pre>
<p>而<code>BotMessageHandler</code>只是简单地根据当前<code>HttpContext.Request</code>构建<code>Activity</code>；并通过依赖注入，索取<code>BotAdapter</code>服务及<code>IBot</code>服务；再把<code>IBot::OnTurnAsync(context,ct)</code>方法作<code>BotAdapter</code>的中间件的回调执行。</p>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
      
 // 处理形如 <code>$E=mc^2$</code> 形式的公式
  var inlineMathNodes=document.querySelectorAll('code');
  var re=/^\$(.*)\$$/;
  for(var j=0;j<inlineMathNodes.length;j++){
    var result=re.exec(inlineMathNodes.item(j).innerText);
    if(result!==null){
      katex.render(result[1], inlineMathNodes.item(j));
    }
  }
  function removeNode(node){
    if(node.remove){
      node.remove();
    }else{
      return first.parentNode.removeChild(node);
    }
  };

  // 查找所有 pre code.language-math 节点 以备筛出数据公式
  var nodes=document.querySelectorAll("pre code.language-math");
  for(var i=0;i<nodes.length;i++){
    var node=nodes.item(i);
    // 魔术标记所在行 
    try{
      var lines = node.innerText.split('\n');
      if((!!lines) && lines.length > 0)
      {
        var first = lines[0];
        if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
          var views = "";
          // 逐行渲染
          for(var k=1; k <lines.length; k++){
              var f=lines[k];
              views += katex.renderToString(f);
          }
          // 消除父级嵌套 
          try{
            node.innerHTML=views;
          }catch(e){
            // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
            console.log('IE9 sucks',e);
            $(tr).html(node.innerHTML);
          }
        }
      }
    }
    catch(err){
      console.log(err)
    }
  }
    
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>