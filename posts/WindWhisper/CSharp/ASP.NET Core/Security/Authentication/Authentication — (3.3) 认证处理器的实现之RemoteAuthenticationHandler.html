<!DOCTYPE html><html>
  <head>

        <script type="text/javascript">
          var wsUri = "ws://localhost:8080/websocket";
      function init()
      {
        websocket = new WebSocket(wsUri);
        websocket.onclose = function(evt) { onClose(evt) };
      }
      function onClose(evt)
      {
        console.log('closing');
        websocket.close();
        document.location.reload();
      }
      window.addEventListener("load", init, false);
      </script>
            <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item" href="">
            Home
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/CSharp/ASP.NET Core/Security/Authentication/Authentication — (3.3) 认证处理器的实现之RemoteAuthenticationHandler.html">
                    Authentication — (3.3) 认证处理器的实现之RemoteAuthenticationHandler
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2019-08-14
                </p>
              </div>
              <div class="content article-body">
                <p>设想我们要写一个支持<code>OAuth2.0</code>的认证处理器，它支持使用<code>Google</code>、<code>Microsoft</code>、<code>Facebook</code>等账号登陆。由于它们共用一套认证逻辑<code>OAuth2.0</code>，所以我们不希望为每一个网站都写一遍处理认证的方法，而是希望针对每个网站的一些特性部分进行简单填充。一个合理的方式是让处理认证的方法接受一个如何登陆的字符串（比如<code>Google</code>），然后通过认证服务去自动调用对应具体的认证处理器（比如<code>GoogleHandler</code>）。
更一般的，除了<code>OAuth</code>,<code>OIDC</code>也是一种常见的远程认证方式。</p>
<p>为了抽象这种利用远程服务器进行认证的方式，<code>ASP.NET Core</code>提供了<code>RemoteAuthenticationHandler&lt;TOptions&gt;</code>抽象类。该类继承自<code>AuthenticationHandler&lt;TOptions&gt;</code>抽象基类，并且实现了<code>IAuthenticationRequestHandler</code>接口：</p>
<pre><code class="language-csharp">public abstract class RemoteAuthenticationHandler&lt;TOptions&gt; : AuthenticationHandler&lt;TOptions&gt;, IAuthenticationRequestHandler
    where TOptions : RemoteAuthenticationOptions, new()
{
    protected string SignInScheme =&gt; Options.SignInScheme;
    
    protected new RemoteAuthenticationEvents Events
    {
        get { return (RemoteAuthenticationEvents)base.Events; }
        set { base.Events = value; }
    }
    
    // ...
}
</code></pre>
<p>由于在继承自<code>AuthenticationHandler&lt;TOptions&gt;</code>的同时，还实现了<code>IAuthenticationRequestHandler</code>接口，这个<code>RemoteAuthenticationHandler&lt;TOptions&gt;</code>类就有两套处理认证的机制。一套是<code>AuthenticationHandler&lt;TOptions&gt;</code>的认证、质询、禁止等方法；另一套是<code>IAuthenticationRequestHandler</code>的接口方法<code>HandleRequestAsync()</code>用于直接对请求进行中间件级别的处理，并中断后续请求处理过程。<!-- more --></p>
<p>需要特别指出的是，<code>RemoteAuthenticationHandler</code>中有一个受保护的 <strong><code>SignInScheme</code></strong> 属性。其用途为：</p>
<ol>
<li>当用户认证成功时，使用该<code>SignInScheme</code>将用户<strong>登入</strong></li>
<li>当需要认证用户时，只需查看当前用户在该<code>SignInScheme</code>下是否已经登陆</li>
<li>当用户被判定登陆失败提示<code>Forbidden</code>时，调用认证服务转而调用<code>SignInScheme</code>模式对应的认证处理器方法。</li>
</ol>
<h3><code>AuthenticationHandler&lt;TOptions&gt;</code>系的方法</h3>
<p>这一系列的方法包括处理认证、处理质询、处理禁止、处理登入、和处理登出几个方法。其中，处理禁止的方法最为简单，只是简单转而调用<code>SignInScheme</code>对应的处理器方法：</p>
<pre><code class="language-csharp">protected override Task HandleForbiddenAsync(AuthenticationProperties properties)=&gt; Context.ForbidAsync(SignInScheme);
</code></pre>
<p>而其处理认证的方法也只是复用<code>SigninScheme</code>模式进行认证：</p>
<pre><code class="language-csharp">protected override async Task&lt;AuthenticateResult&gt; HandleAuthenticateAsync()
{
    var result = await Context.AuthenticateAsync(SignInScheme);
    if (result != null)
    {
        if (result.Failure != null) {  return result; }

        // The SignInScheme may be shared with multiple providers, make sure this provider issued the identity.
        string authenticatedScheme;
        var ticket = result.Ticket;
        if (ticket != null &amp;&amp; ticket.Principal != null &amp;&amp; ticket.Properties != null
            &amp;&amp; ticket.Properties.Items.TryGetValue(AuthSchemeKey, out authenticatedScheme)
            &amp;&amp; string.Equals(Scheme.Name, authenticatedScheme, StringComparison.Ordinal))
        {
            return AuthenticateResult.Success(new AuthenticationTicket(ticket.Principal,
                ticket.Properties, Scheme.Name));
        }

        return AuthenticateResult.Fail(&quot;Not authenticated&quot;);
    }

    return AuthenticateResult.Fail(&quot;Remote authentication does not directly support AuthenticateAsync&quot;);
}
</code></pre>
<p>其他几个方法均类似，故不复赘述。</p>
<h3><code>IAuthenticationRequestHandler</code>系的接口方法</h3>
<p>在开始这部分内容之前，先要了解下这个类的一个辅助方法：<code>ShouldHandleRequestAsync()</code>。我们知道，远程认证结束后，远程服务器需要把用户重定向到本服务器的某个地址（称之为<strong>回调地址</strong>）。该方法的工作原理便是判断当前路径是否为配置好的<strong>回调地址</strong>，如果是，则意味着当前请求是远程服务器认证结束后重定向来的<strong>回调请求</strong>，需要拦截处理。</p>
<pre><code class="language-csharp">public virtual Task&lt;bool&gt; ShouldHandleRequestAsync() =&gt; Task.FromResult(Options.CallbackPath == Request.Path);
</code></pre>
<p>作为<code>IAuthenticationRequestHandler</code>接口的核心方法，<code>HandleRequestAsync()</code>方法基本思路是，<strong>判断当前路径是否为预配返回地址，如果不是，则意味着当前请求并不适合用<code>IAuthenticationRequestHandler</code>接口处理，直接返回<code>false</code>；否则，意味着当前的请求是由远程认证服务器认证结束后重定向来的请求，应当确认用户身份，触发相关事件钩子，最终在登入用户之后，中断后续的请求处理过程(<code>return true</code>)</strong>。</p>
<pre><code class="language-csharp">public virtual async Task&lt;bool&gt; HandleRequestAsync()
{
    if (!await ShouldHandleRequestAsync())
    {
        return false;
    }
    
    // ...
    
    var authResult = await HandleRemoteAuthenticateAsync();
    // check authResult... 
    
    // create a ticketContext if authResult succeeds 
    // ... await Events.TicketReceived(ticketContext);
    
    await Context.SignInAsync(SignInScheme, ticketContext.Principal, ticketContext.Properties);

    // Default redirect path is the base path
    if (string.IsNullOrEmpty(ticketContext.ReturnUri))
    {
        ticketContext.ReturnUri = &quot;/&quot;;
    }

    Response.Redirect(ticketContext.ReturnUri);
    return true;
}
</code></pre>
<p>这里<code>HandleRemoteAuthenticateAsync()</code>是一个抽象方法，留待不同的子类提供实现。</p>
<h2><code>RemoteAuthenticationHandler</code> 流程概述</h2>
<p>总结而言，<code>RemoteAuthenticationHandler</code>的完整调用流程可以</p>
<p>以<code>GoogleHandler</code>为例，</p>
<ol>
<li>用户访问某个页面，点击“使用Google登陆”按钮，申请使用Google账号提交，浏览器发送请求到<code>https://your-server/Identity/Account/ExternalLogin?returnUrl=%2F</code>:</li>
<li><code>ASP.NET Core</code> 相关登陆页面将之重定向至<code>Google</code>授权页面</li>
</ol>
<pre><code>https://accounts.google.com/o/oauth2/v2/auth?
    response_type=code
    &amp;client_id=xxx
    &amp;scope=openid%20profile%20email
    &amp;redirect_uri=https%3A%2F%2Fyour-server%2Fsignin-google
    &amp;state=xxx
</code></pre>
<ol start="3">
<li><code>Google</code>认证用户完成以后，将用户重定向至<code>ASP.NET Core</code> 的指定URL（携带<code>code</code>等参数），该URL通常是：<code>/sigin-google</code>:</li>
</ol>
<pre><code> https://your-server/signin-google?
    state=xxx
    &amp;code=yyy
    &amp;scope=zzz
    &amp;authuser=0
    &amp;session_state=abc
    &amp;prompt=none
</code></pre>
<ol start="4">
<li>浏览器访问上述URL，中间件<code>AuthenticationMiddleware</code>会调用<code>GetRequestHandlerSchemesAsync()</code>方法获取所有的<code>RequestHandlerSchemes</code>，然后逐一尝试将该认证处理器转换<code>AuthenticationRequestHandler</code>，如果成功，则调用其<code>HandleRequestAsync()</code>方法。<code>GoogleHandler::HandleRequestAsync()</code>方法继承自<code>RemoteAuthenticationHandler</code>，会先调用<code>ShouldHandleRequestAsync()</code>进行判断是否需要处理请求。默认情况下，该方法只是检测<code>Options.CallbackPath</code>和 <code>Request.Path</code>是否相等而已。如果不等，说明当前认证处理器不应当处理当前请求相等；否则，比如这里等于<code>signin-google</code>，则会进行远程认证处理(不同的远程认证模式，其处理方式也不同，比如，<code>OAuth2.0</code>中常见的方式是用<code>code</code>换取<code>token</code>)，处理认证完成之后，倘若认证成功，则再将用户<code>SigninAsync()</code>之。</li>
</ol>
<p>参见SO上的回答:
https://stackoverflow.com/questions/52980581/how-signin-google-in-asp-net-core-authentication-is-linked-to-the-google-handler/52984793#52984793</p>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
      
 // 处理形如 <code>$E=mc^2$</code> 形式的公式
  var inlineMathNodes=document.querySelectorAll('code');
  var re=/^\$(.*)\$$/;
  for(var j=0;j<inlineMathNodes.length;j++){
    var result=re.exec(inlineMathNodes.item(j).innerText);
    if(result!==null){
      katex.render(result[1], inlineMathNodes.item(j));
    }
  }
  function removeNode(node){
    if(node.remove){
      node.remove();
    }else{
      return first.parentNode.removeChild(node);
    }
  };

  // 查找所有 pre code.language-math 节点 以备筛出数据公式
  var nodes=document.querySelectorAll("pre code.language-math");
  for(var i=0;i<nodes.length;i++){
    var node=nodes.item(i);
    // 魔术标记所在行 
    try{
      var lines = node.innerText.split('\n');
      if((!!lines) && lines.length > 0)
      {
        var first = lines[0];
        if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
          var views = "";
          // 逐行渲染
          for(var k=1; k <lines.length; k++){
              var f=lines[k];
              views += katex.renderToString(f);
          }
          // 消除父级嵌套 
          try{
            node.innerHTML=views;
          }catch(e){
            // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
            console.log('IE9 sucks',e);
            $(tr).html(node.innerHTML);
          }
        }
      }
    }
    catch(err){
      console.log(err)
    }
  }
    
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>