<!DOCTYPE html><html>
  <head>

        <script type="text/javascript">
          var wsUri = "ws://localhost:8080/websocket";
      function init()
      {
        websocket = new WebSocket(wsUri);
        websocket.onclose = function(evt) { onClose(evt) };
      }
      function onClose(evt)
      {
        console.log('closing');
        websocket.close();
        document.location.reload();
      }
      window.addEventListener("load", init, false);
      </script>
            <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item" href="">
            Home
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/CSharp/ASP.NET Core/Security/Authorization/Authorization — (2) 授权处理器、授权服务、和Policy Evaluator.html">
                    Authorization — (2) 授权处理器、授权服务、和Policy Evaluator
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2019-08-20
                </p>
              </div>
              <div class="content article-body">
                <h2>授权处理器与Provider</h2>
<h3><code>AuthorizationHandler</code></h3>
<p><code>AuthorizationHandler</code>表示针对具体<code>Requirement</code>的处理器：</p>
<pre><code class="language-csharp">public interface IAuthorizationHandler
{
    Task HandleAsync(AuthorizationHandlerContext context);
}
</code></pre>
<p>抽象类<code>AuthorizationHandler&lt;TRequirement&gt;</code>的默认逻辑是针对所有的<code>TRequirement</code>都进行处理：</p>
<pre><code class="language-csharp">public abstract class AuthorizationHandler&lt;TRequirement&gt; : IAuthorizationHandler
        where TRequirement : IAuthorizationRequirement
{
    public virtual async Task HandleAsync(AuthorizationHandlerContext context)
    {
        foreach (var req in context.Requirements.OfType&lt;TRequirement&gt;())
        {
            await HandleRequirementAsync(context, req);
        }
    }
    
    protected abstract Task HandleRequirementAsync(AuthorizationHandlerContext context, TRequirement requirement);
}
</code></pre>
<p>注意，尽管<code>AuthorizatoinHandler&lt;TRequirement&gt;</code>类包含了为一个<code>TRequirement</code>类型，但是一种类型的<code>TRequirement</code>，可以被应用于多种类型的<code>Handler</code>——在<code>HandleAsync()</code>方法中，这些<code>Handler</code>会被逐一调用。</p>
<p>特别地，根据所要授权的目标的不同，授权处理器还分化出了针对<code>Requirement</code>及<code>Resource</code>的抽象类：</p>
<pre><code class="language-csharp">public abstract class AuthorizationHandler&lt;TRequirement, TResource&gt; : IAuthorizationHandler
    where TRequirement : IAuthorizationRequirement
{
    public virtual async Task HandleAsync(AuthorizationHandlerContext context)
    {
        if (context.Resource is TResource)
        {
            foreach (var req in context.Requirements.OfType&lt;TRequirement&gt;())
            {
                await HandleRequirementAsync(context, req, (TResource)context.Resource);
            }
        }
    }

    protected abstract Task HandleRequirementAsync(AuthorizationHandlerContext context, TRequirement requirement, TResource resource);
}
</code></pre>
<!-- more -->
<p><code>WebApp</code>项目所注册的相关授权处理器会被<code>Provider</code>提供给授权服务。</p>
<h3><code>IAuthorizationHandlerProvider</code></h3>
<p><code>IAuthorizationHandlerProvider</code>用于向其他服务提供一组<code>IAuthorizationHandler</code>：</p>
<pre><code class="language-csharp">public interface IAuthorizationHandlerProvider
{
    Task&lt;IEnumerable&lt;IAuthorizationHandler&gt;&gt; GetHandlersAsync(AuthorizationHandlerContext context);
}
</code></pre>
<p>其默认实现是把<code>IAuthorizationHandler</code>所有的实现都返回：</p>
<pre><code class="language-csharp">public class DefaultAuthorizationHandlerProvider : IAuthorizationHandlerProvider
{
    private readonly IEnumerable&lt;IAuthorizationHandler&gt; _handlers;

    public DefaultAuthorizationHandlerProvider(IEnumerable&lt;IAuthorizationHandler&gt; handlers)
    {
        if (handlers == null){ /*  throw  */ }
        _handlers = handlers;
    }

    public Task&lt;IEnumerable&lt;IAuthorizationHandler&gt;&gt; GetHandlersAsync(AuthorizationHandlerContext context)
        =&gt; Task.FromResult(_handlers);
}
</code></pre>
<p>这要求我们需要手工为自定义的<code>AuthorizationHandler</code>注册服务：</p>
<pre><code class="language-csharp">services.AddSingleton&lt;IAuthorizationHandler,TokenValidationHandler&gt;();
services.AddSingleton&lt;IAuthorizationHandler, MinimumAgeHandler&gt;();
...
</code></pre>
<h2>授权服务</h2>
<h3><code>IAuthorizationService</code>接口</h3>
<p><code>IAuthorizationService</code>的作用是判断用户是否满足特定的<code>Policy</code>或者一系列<code>Requirements</code>：</p>
<pre><code class="language-csharp">public interface IAuthorizationService
{
    Task&lt;AuthorizationResult&gt; AuthorizeAsync(ClaimsPrincipal user, object resource, IEnumerable&lt;IAuthorizationRequirement&gt; requirements);
    Task&lt;AuthorizationResult&gt; AuthorizeAsync(ClaimsPrincipal user, object resource, string policyName);
}
</code></pre>
<p>这里的<code>AuthroizationResult</code>表示授权的结果是成功还是失败:</p>
<pre><code class="language-csharp">public class AuthorizationResult
{
    private AuthorizationResult() { }
    public bool Succeeded { get; private set; }
    public AuthorizationFailure Failure { get; private set; }

    // 三个静态工厂方法
    public static AuthorizationResult Success() =&gt; new AuthorizationResult { Succeeded = true };
    public static AuthorizationResult Failed(AuthorizationFailure failure) =&gt; new AuthorizationResult { Failure = failure };
    public static AuthorizationResult Failed() =&gt; new AuthorizationResult { Failure = AuthorizationFailure.ExplicitFail() };
}
</code></pre>
<p>判断当前用户是否满足一个<code>Policy</code>，本质上也是对该用户能否满足这个<code>policy</code>的所有<code>Requirements</code>进行判断。</p>
<pre><code class="language-csharp">public static Task&lt;AuthorizationResult&gt; AuthorizeAsync(this IAuthorizationService service, ClaimsPrincipal user, object resource, AuthorizationPolicy policy)
{
    // ... check if service / policy is null
    return service.AuthorizeAsync(user, resource, policy.Requirements);
}
</code></pre>
<p><code>ASP.NET Core</code>还为<code>IAuthorizationService</code>接口提供了一系列<code>AuthorizeAsync()</code>其它扩展方法：</p>
<ul>
<li>判断用户是否满足某个单独的<code>Requirement</code>：把该<code>Requirement</code>变换成一个具有唯一元素的数组</li>
<li>只指定Policy名，而无<code>Resource</code>
由于实现均较简单，此处不予赘述。</li>
</ul>
<h3>授权服务的默认实现</h3>
<p><code>AuthorizationService</code>的默认实现依赖于<code>IAuthorizationEvaluator</code>、<code>IAuthorizationHandlerProvider</code>、<code>IAuthorizationPolicyProvider</code>、<code>AuthorizationOptions</code>等服务:</p>
<ul>
<li><code>IAuthorizationHandlerProvider</code>: 用于提供当前<code>WebApp</code>的众多<code>AuthorizatonHandler</code>服务</li>
<li><code>IAuthorizationEvaluator</code>：对<code>AuthorizatonHandler</code>授权结束后的当前授权上下文进行评估（只是简单判断），给出授权结果</li>
<li><code>IAuthorizationPolicyProvider</code>：用于根据指定的<code>Policy</code>名给出相应<code>Policy</code>实例</li>
</ul>
<pre><code class="language-csharp">public class DefaultAuthorizationService : IAuthorizationService
{
    private readonly AuthorizationOptions _options;
    private readonly IAuthorizationHandlerContextFactory _contextFactory;
    private readonly IAuthorizationHandlerProvider _handlers;
    private readonly IAuthorizationEvaluator _evaluator;
    private readonly IAuthorizationPolicyProvider _policyProvider;
    private readonly ILogger _logger;

    // 注入这些依赖
    public DefaultAuthorizationService(IAuthorizationPolicyProvider policyProvider, IAuthorizationHandlerProvider handlers, ILogger&lt;DefaultAuthorizationService&gt; logger, IAuthorizationHandlerContextFactory contextFactory, IAuthorizationEvaluator evaluator, IOptions&lt;AuthorizationOptions&gt; options)
    {
        ... 
    }
    
    ....
    
}
</code></pre>
<p>默认实现：</p>
<pre><code class="language-csharp">public class DefaultAuthorizationService : IAuthorizationService
{
    public async Task&lt;AuthorizationResult&gt; AuthorizeAsync(ClaimsPrincipal user, object resource, IEnumerable&lt;IAuthorizationRequirement&gt; requirements)
    {
        if (requirements == null){ /*  throw  */ }

        var authContext = _contextFactory.CreateContext(requirements, user, resource);
        var handlers = await _handlers.GetHandlersAsync(authContext);
        foreach (var handler in handlers)
        {
            await handler.HandleAsync(authContext);
            if (!_options.InvokeHandlersAfterFailure &amp;&amp; authContext.HasFailed)
            {
                break;
            }
        }

        var result = _evaluator.Evaluate(authContext);
        // ...logging
        return result;
    }

    public async Task&lt;AuthorizationResult&gt; AuthorizeAsync(ClaimsPrincipal user, object resource, string policyName)
    {
        if (policyName == null) { /*  throw  */ }
        var policy = await _policyProvider.GetPolicyAsync(policyName);
        if (policy == null)     { /*  throw  */ }
        return await this.AuthorizeAsync(user, resource, policy);
    }
}
</code></pre>
<h2><code>IPolicyEvaluator</code></h2>
<p><code>IPolicyEvaluator</code>在<code>IAuthorizationService</code>的基础之上提供了对具体<code>Policy</code>进行认证、授权的功能。</p>
<pre><code class="language-csharp">public interface IPolicyEvaluator
{
    Task&lt;AuthenticateResult&gt; AuthenticateAsync(AuthorizationPolicy policy, HttpContext context);

    Task&lt;PolicyAuthorizationResult&gt; AuthorizeAsync(AuthorizationPolicy policy, AuthenticateResult authenticationResult, HttpContext context, object resource);
}
</code></pre>
<p>其实现</p>
<pre><code class="language-csharp">public class PolicyEvaluator : IPolicyEvaluator
{
    private readonly IAuthorizationService _authorization;

    public PolicyEvaluator(IAuthorizationService authorization)
    {
        _authorization = authorization;
    }

    public virtual async Task&lt;AuthenticateResult&gt; AuthenticateAsync(AuthorizationPolicy policy, HttpContext context)
    {
        if (policy.AuthenticationSchemes != null &amp;&amp; policy.AuthenticationSchemes.Count &gt; 0)
        {
            ClaimsPrincipal newPrincipal = null;
            foreach (var scheme in policy.AuthenticationSchemes)
            {
                var result = await context.AuthenticateAsync(scheme);
                if (result != null &amp;&amp; result.Succeeded)
                {
                    newPrincipal = SecurityHelper.MergeUserPrincipal(newPrincipal, result.Principal);
                }
            }

            if (newPrincipal != null)
            {
                context.User = newPrincipal;
                return AuthenticateResult.Success(new AuthenticationTicket(newPrincipal, string.Join(&quot;;&quot;, policy.AuthenticationSchemes)));
            }
            else
            {
                context.User = new ClaimsPrincipal(new ClaimsIdentity());
                return AuthenticateResult.NoResult();
            }
        }

        return (context.User?.Identity?.IsAuthenticated ?? false) 
            ? AuthenticateResult.Success(new AuthenticationTicket(context.User, &quot;context.User&quot;))
            : AuthenticateResult.NoResult();
    }

    public virtual async Task&lt;PolicyAuthorizationResult&gt; AuthorizeAsync(AuthorizationPolicy policy, AuthenticateResult authenticationResult, HttpContext context, object resource)
    {
        if (policy == null) { /* throw */ }

        var result = await _authorization.AuthorizeAsync(context.User, resource, policy);
        if (result.Succeeded)
        {
            return PolicyAuthorizationResult.Success();
        }

        // If authentication was successful, return forbidden, otherwise challenge
        return (authenticationResult.Succeeded) 
            ? PolicyAuthorizationResult.Forbid() 
            : PolicyAuthorizationResult.Challenge();
    }
}
</code></pre>
<p>这个类是会被用于授权中间件、及<code>MVC</code>的<code>AuthorizeFilter</code>中</p>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
      
 // 处理形如 <code>$E=mc^2$</code> 形式的公式
  var inlineMathNodes=document.querySelectorAll('code');
  var re=/^\$(.*)\$$/;
  for(var j=0;j<inlineMathNodes.length;j++){
    var result=re.exec(inlineMathNodes.item(j).innerText);
    if(result!==null){
      katex.render(result[1], inlineMathNodes.item(j));
    }
  }
  function removeNode(node){
    if(node.remove){
      node.remove();
    }else{
      return first.parentNode.removeChild(node);
    }
  };

  // 查找所有 pre code.language-math 节点 以备筛出数据公式
  var nodes=document.querySelectorAll("pre code.language-math");
  for(var i=0;i<nodes.length;i++){
    var node=nodes.item(i);
    // 魔术标记所在行 
    try{
      var lines = node.innerText.split('\n');
      if((!!lines) && lines.length > 0)
      {
        var first = lines[0];
        if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
          var views = "";
          // 逐行渲染
          for(var k=1; k <lines.length; k++){
              var f=lines[k];
              views += katex.renderToString(f);
          }
          // 消除父级嵌套 
          try{
            node.innerHTML=views;
          }catch(e){
            // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
            console.log('IE9 sucks',e);
            $(tr).html(node.innerHTML);
          }
        }
      }
    }
    catch(err){
      console.log(err)
    }
  }
    
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>