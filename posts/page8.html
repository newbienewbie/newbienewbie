<!DOCTYPE html><html>
  <head>

        <script type="text/javascript">
          var wsUri = "ws://localhost:8080/websocket";
      function init()
      {
        websocket = new WebSocket(wsUri);
        websocket.onclose = function(evt) { onClose(evt) };
      }
      function onClose(evt)
      {
        console.log('closing');
        websocket.close();
        document.location.reload();
      }
      window.addEventListener("load", init, false);
      </script>
            <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie/"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item is-active" href="">
            Home
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/Alchemy/machine-learning/机器学习 - 世界观/机器学习 世界观 2.html">
                    机器学习 世界观 一种有监督学习的算法
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-04-10
                </p>
              </div>
              <div class="content article-body">
                <p>训练集可以视作一个矩阵<code>$\bold X$</code>，其中每一行都代表一条训练数据向量<code>$\bold x$</code>。我们的目标就是要通过训练集反复调整权重向量，得到能够刻画数据内在规律的数学方程。</p>
<h2>朴素思想</h2>
<p>不妨先只考虑单个神经元的情况。对于训练集中的每一组训练数据<code>$\bold x$</code>，都通过<code>$\phi(\bold w \cdot \bold x +b)$</code>计算出一个预测值<code>$\hat y$</code>。 并和真实值<code>$y$</code>相比较得到误差<code>$e=y - \hat y$</code> 。由于<code>$\phi(\bold w \cdot \bold x +b)$</code>是对<code>$\bold w \cdot \bold x$</code>简单变换，为了简单起见，我们假设<code>$\phi$</code>是正相关函数，这样只需考虑<code>$\bold w \cdot \bold x$</code>即可推知<code>$\phi(z)$</code>的变化趋势：</p>
<ol>
<li>如果误差<code>$e = 0$</code>，则说明预测值与真实值相同，不需要调整权重向量<code>$\bold w$</code>。</li>
<li>如果误差<code>$e &gt; 0$</code>，则说明预测值与真实值相比偏小，需要修正<code>$\bold w$</code>。我们可以通过调整<code>$\bold w$</code>，使之与输入向量<code>$\bold x$</code>之间的夹角更小一点，这样计算出来的<code>$\bold w \cdot \bold x$</code>值会更大，从而导致预测值<code>$\phi(z)$</code>会增大一点。</li>
<li>如果误差<code>$e &lt; 0$</code>，则说明预测值与真实值相比偏大，需要修正<code>$\bold w$</code>。我们可以通过调整<code>$\bold w$</code>，使之与输入向量<code>$\bold x$</code>之间的夹角更大一点，这样计算出来的<code>$\bold w \cdot \bold x$</code>值会更小，从而导致预测值<code>$\phi(z)$</code>会减小一点。</li>
</ol>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/Alchemy/Math/牛顿下山法.html">
                    牛顿下山法
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-04-09
                </p>
              </div>
              <div class="content article-body">
                <p>方程求根可以视作函数的零点求解问题，牛顿迭代法与方程求解有密切的关联。</p>
<h2>朴素的迭代思想</h2>
<p>对于方程<code>$f(x)=0$</code>，若已知相应函数<code>$f(x)$</code>在 <code>$[x_1,x_2]$</code> 之间单调有根，并且直接求解根比较困难。一种朴素的思想是，我们可以转而去求解一个近似方程<code>$s(x)=0$</code>的根(假设这种求解又比较容易)。</p>
<p>不妨记此近似方程的根为 <code>$x_r$</code>。若 <code>$x_r$</code> 位于区间<code>$[x_1,x_2]$</code> 中，则实际根必位于区间 <code>$[x_1,x_r]$</code>中或者 <code>$[x_r,x_2]$</code> 之中。显然，我们通过这种近似求解的操作，把根的区间缩小到了更精确的范围。如此多次迭代到一定程度，就可以求出方程<code>$f(x)=0$</code>在区间  <code>$[x_1,x_2]$</code> 上的数值解。</p>
<h2>牛顿迭代法</h2>
<p>既然叫“牛顿”，必然要用到导数或者说切线的概念，这里就是利用泰勒公式对函数进行近似。利用一阶泰勒公式可以对函数 <code>$f(x)$</code> 在 <code>$x_2$</code> 点进行展开</p>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/Alchemy/machine-learning/机器学习 - 世界观/机器学习 世界观 1.html">
                    机器学习 世界观
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-04-09
                </p>
              </div>
              <div class="content article-body">
                <p>机器学习大体上是在利用某些学习规则，发现问题的潜在规律，然后拟合出数学方程（也即是训练，或者可以叫学习、拟合），最后加以应用的过程。机器学习有许多数学方法，当下最热门的莫过于神经网络了。</p>
<h2>神经网络的概念</h2>
<p>所谓神经网络，从数学角度说，是一个数学方程，可以视作<b>将一组输入通过权重变换，再经过偏置处理，得到净输入，最后送入传输函数得到结果。</b>其工作过程如下图所示：</p>
<pre><code class="language-math">%% KaTex
\color{Blue}\text{Input}  \color{white} \xrightarrow{z=\bold w \cdot \bold x +b} \text{NetInput} \color{white} \xrightarrow{\phi(z)} \color{Orange} \text{Output}
</code></pre>
<p>为了表述简便，采用如下记号约定：</p>
<ul>
<li>向量：用加粗小写表示，如<code>$\bold x$</code></li>
<li>矩阵：用加粗大写表示，如<code>$\bold X$</code></li>
<li><code>$\Bbb R^{n \times m}$</code>：表示由<code>$n \times m$</code>型实数域矩阵构成的集合</li>
</ul>
<p>为了理解神经网络的数学原理，不妨只考虑单个神经元的情况：假设有单个单神经元，记该神经元的权重向量为<code>$\bold w$</code>，偏置值为<code>$b$</code>，传输函数<code>$\phi(z)$</code>。当输入一组变量<code>$\bold x$</code>，显然就可以通过单神经元的作用<code>$\phi(\bold w \cdot \bold x + b)$</code>，得到一个输出。</p>
<p>一般情况下，单个神经元并不能满足实际应用要求。可以把若干个神经元编成一组(称之为一层神经网络)。这种情况下，各个神经元的权重向量就构成了一个权重矩阵<code>$\bold W$</code>，各个神经元的偏置值构成了一组偏置向量<code>$\bold b$</code>。当对该神经网络输入一组变量<code>$\bold x$</code>，经过单层神经网络的作用<code>$\phi(\bold W \bold x + \bold b)$</code>，即可得到一组输出值。</p>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/Rust/并发编程/Rust并发编程2——状态共享可修改.html">
                    Rust并发编程2——状态共享可修改
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-03-11
                </p>
              </div>
              <div class="content article-body">
                <p>在<code>Rust</code>中，一贯的理念是，一个类型应该要么是共享只读，要么是独占可改。这也是所有权系统要求对同一实例的引用(<code>&amp;T</code>)、可变引用(<code>&amp;mut T</code>)不能共存的原因。不过，这种所有权规则有时候会给编程带来极大的不变性，在单线程场景下，可以通过<code>RefCell&lt;T&gt;</code>实现内部可修改，通过<code>Rc&lt;T&gt;</code>实现共享所有权，这样组合后就可以实现基于共享不可变引用的内部可修改了。</p>
<p>在多线程场景下，如果只是简单的数据共享，可以借助于<a href="http://www.itminus.com/blog/2018/03/10/WindWhisper/Rust/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Rust%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B1%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/">上一篇笔记中</a>的消息传递机制；但是要实现数据共享且可修改，就要借助于<code>Mutex&lt;T&gt;</code>和<code>Arc&lt;T&gt;</code>了。</p>
<h2><code>Mutex</code>和<code>MutexGuard</code>智能指针</h2>
<p><code>Mutex</code>(互斥体)是用于共享内存的并发原语，表示在任何给定的时间点，只允许唯一一个线程去访问数据，为了访问<code>Mutex</code>中的数据，线程必须首先发出信号请求获得<code>Mutex</code>的锁，表示想要访问数据。这里的锁是<code>mutex</code>中的数据结构，用于追踪当前是谁在访问这个数据。由于是基于锁机制，<code>Mutex</code>要求程序员遵循以下原则:</p>
<ol>
<li>使用数据前，必须要尝试获取锁。倘若获取不到，则无法使用数据；倘若获取到，则可以独占数据。</li>
<li>一旦处理完数据，必须释放锁。倘若不释放锁，则其他人无法再使用数据。</li>
</ol>
<p>在<code>Rust</code>中，<code>Mutext&lt;T&gt;</code>类型可以使用<code>Mutext::new()</code>构造一个实例，在使用之前需要尝试通过<code>Mutex</code>类型的<code>lock()</code>方法加锁，需要注意的是：</p>
<ul>
<li><code>lock()</code>方法会阻塞当前线程</li>
<li><code>lock()</code>方法成功之后会返回一个<code>MutextGuard</code>类型的智能指针，此智能指针实现的<code>Deref</code>让其可以被当作一个对内部数据的可变引用，而此类型实现的<code>Drop</code>会在作用域结束之后自动释放锁。</li>
</ul>
<pre><code class="language-Rust">use std::sync::Mutex;

fn main(){
    let m=Mutex::new(String::from(&quot;hello world&quot;));
    {
        let mut num=m.lock().unwrap();     // 调用 lock() 会阻塞当前线程，成功之后会返回`MutexGuard`类型
        *num=String::from(&quot;fuck world&quot;);   // 解引用
    }                                      // 一旦`MutexGuard`到了作用域之外，就会自动释放锁
    println!(&quot;{:?}&quot;, m)
}
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/Rust/并发编程/Rust并发编程1——消息传递.html">
                    Rust并发编程1——消息传递
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-03-10
                </p>
              </div>
              <div class="content article-body">
                <p>传统的并发编程在共享数据时，往往选择的是共享且可变的多所有权的方式。如今，<code>message passing</code> 是一种越来越流行的应对安全并发的手法，在这种机制下，线程或者<code>actor</code>通过发送包含数据的消息来通讯。<code>Rust</code>提供了<code>channel</code>的机制来实现消息传递，在绝大多数编程语言里，一旦发送端利用<code>channel</code>将数据发出，就再也不能使用该数据，这十分类似于<code>Rust</code>中所有权的世界观设定，因而采用这种方式的并发编程，可以确保并发的安全可控。</p>
<h3>通道与消息传递</h3>
<p><code>std::sync::mpsc</code>模块提供了<code>channel()</code>方法，可以生成一对<code>transmitter</code>和<code>receiver</code>，前者是消息的发送端，提供了<code>send()</code>方法，返回一个<code>Result&lt;T,E&gt;</code>对象。后者是消息的接收端，提供<code>recv()</code>、<code>try_recv()</code>方法，用以接收消息，以<code>recv()</code>方法为例：</p>
<ol>
<li><code>recv()</code>方法会阻塞当前线程，直到收到消息为止。</li>
<li>当收到消息，<code>recv()</code>方法便会返回一个<code>Result&lt;T,E&gt;</code>类型</li>
<li>一旦发送端和接收端的通道(<code>channel</code>)关闭，<code>recv()</code>方法便会返回一个<code>error</code>，以通知以后不会再有新的值被发送。</li>
</ol>
<p>举一个例子，子线程每隔一秒产生一个数，主线程负责对子线程生成的数进行处理。</p>
<pre><code class="language-Rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx,rx)=mpsc::channel();

    let _handle= thread::spawn(move||{
        for x in 0 .. 100 {
            tx.send(x).unwrap();
            println!(&quot;sub thread send a : {}&quot;,x);
            thread::sleep(std::time::Duration::from_secs(1));
        }
    });

    while let Ok(received)=rx.recv(){
        println!(&quot;main thread received a : {}&quot;,received);
    }
    println!(&quot;done&quot;);
}
</code></pre>
<h3>迭代器模式</h3>
<p>这种不停地循环调用<code>rx.recv()</code>直至通道关闭，十分类似于迭代器模式。为此，<code>Rust</code>提供了<code>recv.iter()</code>方法，返回一个迭代器<code>std::sync::mpsc::Iter</code>结构体，每次迭代取值，都会调用<code>rx.recv().ok()</code>：</p>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <div class="container">
      <div class="container has-text-centered">
        <a href="posts/page7.html">
          Previous
        </a>
        9 of 32
        <a href="posts/page9.html">
          Next
        </a>
      </div>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
      
 // 处理形如 <code>$E=mc^2$</code> 形式的公式
  var inlineMathNodes=document.querySelectorAll('code');
  var re=/^\$(.*)\$$/;
  for(var j=0;j<inlineMathNodes.length;j++){
    var result=re.exec(inlineMathNodes.item(j).innerText);
    if(result!==null){
      katex.render(result[1], inlineMathNodes.item(j));
    }
  }
  function removeNode(node){
    if(node.remove){
      node.remove();
    }else{
      return first.parentNode.removeChild(node);
    }
  };

  // 查找所有 pre code.language-math 节点 以备筛出数据公式
  var nodes=document.querySelectorAll("pre code.language-math");
  for(var i=0;i<nodes.length;i++){
    var node=nodes.item(i);
    // 魔术标记所在行 
    try{
      var lines = node.innerText.split('\n');
      if((!!lines) && lines.length > 0)
      {
        var first = lines[0];
        if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
          var views = "";
          // 逐行渲染
          for(var k=1; k <lines.length; k++){
              var f=lines[k];
              views += katex.renderToString(f);
          }
          // 消除父级嵌套 
          try{
            node.innerHTML=views;
          }catch(e){
            // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
            console.log('IE9 sucks',e);
            $(tr).html(node.innerHTML);
          }
        }
      }
    }
    catch(err){
      console.log(err)
    }
  }
    
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>