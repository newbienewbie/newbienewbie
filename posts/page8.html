<!DOCTYPE html><html>
  <head>
    <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie/"/>
    <script>
      document.addEventListener('DOMContentLoaded', () => {

	// Get all "navbar-burger" elements
	const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);
  
	// Check if there are any navbar burgers
	if ($navbarBurgers.length > 0) {
  
	  // Add a click event on each of them
	  $navbarBurgers.forEach( el => {
		el.addEventListener('click', () => {
  
		  // Get the target from the "data-target" attribute
		  const target = el.dataset.target;
		  const $target = document.getElementById(target);
  
		  // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
		  el.classList.toggle('is-active');
		  $target.classList.toggle('is-active');
  
		});
	  });
	}
  });
    </script>
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/fsharp.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item is-active" href="">
            Home
          </a>
          <a class="navbar-item" href="tags.html">
            Tags
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/Alchemy/machine-learning/机器学习 - 世界观/机器学习 世界观 3.html">
                    机器学习 世界观 成本函数与另一种有监督的学习算法
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        大道
                      </a>
                    </li>
                    <li>
                      <a href="">
                        炼丹
                      </a>
                    </li>
                    <li>
                      <a href="">
                        机器学习
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#炼丹">
                    <span class="tag is-info">
                      炼丹
                    </span>
                  </a>
                  <a href="tags.html#机器学习">
                    <span class="tag is-info">
                      机器学习
                    </span>
                  </a>
                  <a href="tags.html#神经网络">
                    <span class="tag is-info">
                      神经网络
                    </span>
                  </a>
                  <a href="tags.html#Adaline">
                    <span class="tag is-info">
                      Adaline
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-04-10
                </p>
              </div>
              <div class="content article-body">
                <p>对于训练集<code>$\bold X$</code>中第<code>$i$</code>个<code>Sample</code> <code>$\bold x^{(i)}$</code>，记其目标值为<code>$y^{(i)}$</code>，预测值为<code>$\hat y^{(i)}$</code>。对于训练集中的样品，训练后的最好效果是，各预测值与相应的实际值完全相同，但实际情况必然是互有大小。为了衡量这组值的误差大小，可以用 <em>平方和</em> (<code>SSE</code>) 来表示这种误差：</p>
<pre><code class="language-math">%% KaTex
J(w) = \frac{1}{2} \displaystyle \sum_i{\Big(y^{(i)} -\hat y^{(i)} \Big)}^{2}
</code></pre>
<p>要让训练的效果最好，其实就是要让此<code>SSE</code>取得最小值。故而，我们将这个<code>$J(w)$</code>称之为 <em>目标函数</em> (<code>objective function</code>)，目标函数通常是 <em>成本函数</em> (<code>cost function</code>)，正如这里的<code>SSE</code>，训练就是要让成本函数取得最低值。</p>
<h2>梯度下降法的朴素思想</h2>
<p>那么，如何才让成本函数取得最低值呢？</p>
<p>根据泰勒公式，一个函数<code>$f(x)$</code>可以利用在<code>$x=x_0$</code>展开近似：</p>
<pre><code class="language-math">%% KaTex
f(x) = f(x_0)+f'(x_0)*(x-x_0)
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/Alchemy/machine-learning/机器学习 - 世界观/机器学习 世界观 2.html">
                    机器学习 世界观 一种有监督学习的算法
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        大道
                      </a>
                    </li>
                    <li>
                      <a href="">
                        炼丹
                      </a>
                    </li>
                    <li>
                      <a href="">
                        机器学习
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#炼丹">
                    <span class="tag is-info">
                      炼丹
                    </span>
                  </a>
                  <a href="tags.html#机器学习">
                    <span class="tag is-info">
                      机器学习
                    </span>
                  </a>
                  <a href="tags.html#神经网络">
                    <span class="tag is-info">
                      神经网络
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-04-10
                </p>
              </div>
              <div class="content article-body">
                <p>训练集可以视作一个矩阵<code>$\bold X$</code>，其中每一行都代表一条训练数据向量<code>$\bold x$</code>。我们的目标就是要通过训练集反复调整权重向量，得到能够刻画数据内在规律的数学方程。</p>
<h2>朴素思想</h2>
<p>不妨先只考虑单个神经元的情况。对于训练集中的每一组训练数据<code>$\bold x$</code>，都通过<code>$\phi(\bold w \cdot \bold x +b)$</code>计算出一个预测值<code>$\hat y$</code>。 并和真实值<code>$y$</code>相比较得到误差<code>$e=y - \hat y$</code> 。由于<code>$\phi(\bold w \cdot \bold x +b)$</code>是对<code>$\bold w \cdot \bold x$</code>简单变换，为了简单起见，我们假设<code>$\phi$</code>是正相关函数，这样只需考虑<code>$\bold w \cdot \bold x$</code>即可推知<code>$\phi(z)$</code>的变化趋势：</p>
<ol>
<li>如果误差<code>$e = 0$</code>，则说明预测值与真实值相同，不需要调整权重向量<code>$\bold w$</code>。</li>
<li>如果误差<code>$e &gt; 0$</code>，则说明预测值与真实值相比偏小，需要修正<code>$\bold w$</code>。我们可以通过调整<code>$\bold w$</code>，使之与输入向量<code>$\bold x$</code>之间的夹角更小一点，这样计算出来的<code>$\bold w \cdot \bold x$</code>值会更大，从而导致预测值<code>$\phi(z)$</code>会增大一点。</li>
<li>如果误差<code>$e &lt; 0$</code>，则说明预测值与真实值相比偏大，需要修正<code>$\bold w$</code>。我们可以通过调整<code>$\bold w$</code>，使之与输入向量<code>$\bold x$</code>之间的夹角更大一点，这样计算出来的<code>$\bold w \cdot \bold x$</code>值会更小，从而导致预测值<code>$\phi(z)$</code>会减小一点。</li>
</ol>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/Alchemy/Math/牛顿下山法.html">
                    牛顿下山法
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        大道
                      </a>
                    </li>
                    <li>
                      <a href="">
                        炼丹
                      </a>
                    </li>
                    <li>
                      <a href="">
                        数学
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#炼丹">
                    <span class="tag is-info">
                      炼丹
                    </span>
                  </a>
                  <a href="tags.html#牛顿下山法">
                    <span class="tag is-info">
                      牛顿下山法
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-04-09
                </p>
              </div>
              <div class="content article-body">
                <p>方程求根可以视作函数的零点求解问题，牛顿迭代法与方程求解有密切的关联。</p>
<h2>朴素的迭代思想</h2>
<p>对于方程<code>$f(x)=0$</code>，若已知相应函数<code>$f(x)$</code>在 <code>$[x_1,x_2]$</code> 之间单调有根，并且直接求解根比较困难。一种朴素的思想是，我们可以转而去求解一个近似方程<code>$s(x)=0$</code>的根(假设这种求解又比较容易)。</p>
<p>不妨记此近似方程的根为 <code>$x_r$</code>。若 <code>$x_r$</code> 位于区间<code>$[x_1,x_2]$</code> 中，则实际根必位于区间 <code>$[x_1,x_r]$</code>中或者 <code>$[x_r,x_2]$</code> 之中。显然，我们通过这种近似求解的操作，把根的区间缩小到了更精确的范围。如此多次迭代到一定程度，就可以求出方程<code>$f(x)=0$</code>在区间  <code>$[x_1,x_2]$</code> 上的数值解。</p>
<h2>牛顿迭代法</h2>
<p>既然叫“牛顿”，必然要用到导数或者说切线的概念，这里就是利用泰勒公式对函数进行近似。利用一阶泰勒公式可以对函数 <code>$f(x)$</code> 在 <code>$x_2$</code> 点进行展开</p>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/Alchemy/machine-learning/机器学习 - 世界观/机器学习 世界观 1.html">
                    机器学习 世界观
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        大道
                      </a>
                    </li>
                    <li>
                      <a href="">
                        炼丹
                      </a>
                    </li>
                    <li>
                      <a href="">
                        机器学习
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#炼丹">
                    <span class="tag is-info">
                      炼丹
                    </span>
                  </a>
                  <a href="tags.html#机器学习">
                    <span class="tag is-info">
                      机器学习
                    </span>
                  </a>
                  <a href="tags.html#神经网络">
                    <span class="tag is-info">
                      神经网络
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-04-09
                </p>
              </div>
              <div class="content article-body">
                <p>机器学习大体上是在利用某些学习规则，发现问题的潜在规律，然后拟合出数学方程（也即是训练，或者可以叫学习、拟合），最后加以应用的过程。机器学习有许多数学方法，当下最热门的莫过于神经网络了。</p>
<h2>神经网络的概念</h2>
<p>所谓神经网络，从数学角度说，是一个数学方程，可以视作<b>将一组输入通过权重变换，再经过偏置处理，得到净输入，最后送入传输函数得到结果。</b>其工作过程如下图所示：</p>
<pre><code class="language-math">%% KaTex
\color{Blue}\text{Input}  \color{white} \xrightarrow{z=\bold w \cdot \bold x +b} \text{NetInput} \color{white} \xrightarrow{\phi(z)} \color{Orange} \text{Output}
</code></pre>
<p>为了表述简便，采用如下记号约定：</p>
<ul>
<li>向量：用加粗小写表示，如<code>$\bold x$</code></li>
<li>矩阵：用加粗大写表示，如<code>$\bold X$</code></li>
<li><code>$\Bbb R^{n \times m}$</code>：表示由<code>$n \times m$</code>型实数域矩阵构成的集合</li>
</ul>
<p>为了理解神经网络的数学原理，不妨只考虑单个神经元的情况：假设有单个单神经元，记该神经元的权重向量为<code>$\bold w$</code>，偏置值为<code>$b$</code>，传输函数<code>$\phi(z)$</code>。当输入一组变量<code>$\bold x$</code>，显然就可以通过单神经元的作用<code>$\phi(\bold w \cdot \bold x + b)$</code>，得到一个输出。</p>
<p>一般情况下，单个神经元并不能满足实际应用要求。可以把若干个神经元编成一组(称之为一层神经网络)。这种情况下，各个神经元的权重向量就构成了一个权重矩阵<code>$\bold W$</code>，各个神经元的偏置值构成了一组偏置向量<code>$\bold b$</code>。当对该神经网络输入一组变量<code>$\bold x$</code>，经过单层神经网络的作用<code>$\phi(\bold W \bold x + \bold b)$</code>，即可得到一组输出值。</p>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/Rust/并发编程/Rust并发编程2——状态共享可修改.html">
                    Rust并发编程2——状态共享可修改
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Rust
                      </a>
                    </li>
                    <li>
                      <a href="">
                        并发编程
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#Rust">
                    <span class="tag is-info">
                      Rust
                    </span>
                  </a>
                  <a href="tags.html#并发编程">
                    <span class="tag is-info">
                      并发编程
                    </span>
                  </a>
                  <a href="tags.html#状态共享">
                    <span class="tag is-info">
                      状态共享
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2018-03-11
                </p>
              </div>
              <div class="content article-body">
                <p>在<code>Rust</code>中，一贯的理念是，一个类型应该要么是共享只读，要么是独占可改。这也是所有权系统要求对同一实例的引用(<code>&amp;T</code>)、可变引用(<code>&amp;mut T</code>)不能共存的原因。不过，这种所有权规则有时候会给编程带来极大的不变性，在单线程场景下，可以通过<code>RefCell&lt;T&gt;</code>实现内部可修改，通过<code>Rc&lt;T&gt;</code>实现共享所有权，这样组合后就可以实现基于共享不可变引用的内部可修改了。</p>
<p>在多线程场景下，如果只是简单的数据共享，可以借助于<a href="http://www.itminus.com/blog/2018/03/10/WindWhisper/Rust/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Rust%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B1%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/">上一篇笔记中</a>的消息传递机制；但是要实现数据共享且可修改，就要借助于<code>Mutex&lt;T&gt;</code>和<code>Arc&lt;T&gt;</code>了。</p>
<h2><code>Mutex</code>和<code>MutexGuard</code>智能指针</h2>
<p><code>Mutex</code>(互斥体)是用于共享内存的并发原语，表示在任何给定的时间点，只允许唯一一个线程去访问数据，为了访问<code>Mutex</code>中的数据，线程必须首先发出信号请求获得<code>Mutex</code>的锁，表示想要访问数据。这里的锁是<code>mutex</code>中的数据结构，用于追踪当前是谁在访问这个数据。由于是基于锁机制，<code>Mutex</code>要求程序员遵循以下原则:</p>
<ol>
<li>使用数据前，必须要尝试获取锁。倘若获取不到，则无法使用数据；倘若获取到，则可以独占数据。</li>
<li>一旦处理完数据，必须释放锁。倘若不释放锁，则其他人无法再使用数据。</li>
</ol>
<p>在<code>Rust</code>中，<code>Mutext&lt;T&gt;</code>类型可以使用<code>Mutext::new()</code>构造一个实例，在使用之前需要尝试通过<code>Mutex</code>类型的<code>lock()</code>方法加锁，需要注意的是：</p>
<ul>
<li><code>lock()</code>方法会阻塞当前线程</li>
<li><code>lock()</code>方法成功之后会返回一个<code>MutextGuard</code>类型的智能指针，此智能指针实现的<code>Deref</code>让其可以被当作一个对内部数据的可变引用，而此类型实现的<code>Drop</code>会在作用域结束之后自动释放锁。</li>
</ul>
<pre><code class="language-Rust">use std::sync::Mutex;

fn main(){
    let m=Mutex::new(String::from(&quot;hello world&quot;));
    {
        let mut num=m.lock().unwrap();     // 调用 lock() 会阻塞当前线程，成功之后会返回`MutexGuard`类型
        *num=String::from(&quot;fuck world&quot;);   // 解引用
    }                                      // 一旦`MutexGuard`到了作用域之外，就会自动释放锁
    println!(&quot;{:?}&quot;, m)
}
</code></pre>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <div class="container">
      <div class="container has-text-centered">
        <a href="posts/page7.html">
          Previous
        </a>
        9 of 32
        <a href="posts/page9.html">
          Next
        </a>
      </div>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
       // 处理形如 <code>$E=mc^2$</code> 形式的公式
 var inlineMathNodes=document.querySelectorAll('code');
 var re=/^\$(.*)\$$/;
 for(var j=0;j<inlineMathNodes.length;j++){
   var result=re.exec(inlineMathNodes.item(j).innerText);
   if(result!==null){
	 katex.render(result[1], inlineMathNodes.item(j));
   }
 }
 function removeNode(node){
   if(node.remove){
	 node.remove();
   }else{
	 return first.parentNode.removeChild(node);
   }
 };

 // 查找所有 pre code.language-math 节点 以备筛出数据公式
 var nodes=document.querySelectorAll("pre code.language-math");
 for(var i=0;i<nodes.length;i++){
   var node=nodes.item(i);
   // 魔术标记所在行 
   try{
	 var lines = node.innerText.split('\n');
	 if((!!lines) && lines.length > 0)
	 {
	   var first = lines[0];
	   if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
		 var views = "";
		 // 逐行渲染
		 for(var k=1; k <lines.length; k++){
			 var f=lines[k];
			 views += katex.renderToString(f);
		 }
		 // 消除父级嵌套 
		 try{
		   node.innerHTML=views;
		 }catch(e){
		   // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
		   console.log('IE9 sucks',e);
		   $(tr).html(node.innerHTML);
		 }
	   }
	 }
   }
   catch(err){
	 console.log(err)
   }
 }
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>