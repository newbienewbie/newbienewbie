<!DOCTYPE html><html>
  <head>
    <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie/"/>
    <script>
      document.addEventListener('DOMContentLoaded', () => {

	// Get all "navbar-burger" elements
	const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);
  
	// Check if there are any navbar burgers
	if ($navbarBurgers.length > 0) {
  
	  // Add a click event on each of them
	  $navbarBurgers.forEach( el => {
		el.addEventListener('click', () => {
  
		  // Get the target from the "data-target" attribute
		  const target = el.dataset.target;
		  const $target = document.getElementById(target);
  
		  // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
		  el.classList.toggle('is-active');
		  $target.classList.toggle('is-active');
  
		});
	  });
	}
  });
    </script>
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item is-active" href="">
            Home
          </a>
          <a class="navbar-item" href="tags.html">
            Tags
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/CSharp/ASP.NET Core/Security/Authentication/Authentication — (3.2) 认证处理器的实现之JwtBearerHandler.html">
                    Authentication — (3.2) 认证处理器的实现之JwtBearerHandler
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        CSharp
                      </a>
                    </li>
                    <li>
                      <a href="">
                        ASP.NET Core
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Security
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Authentication
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#ASP.NET Core">
                    <span class="tag is-info">
                      ASP.NET Core
                    </span>
                  </a>
                  <a href="tags.html#CSharp">
                    <span class="tag is-info">
                      CSharp
                    </span>
                  </a>
                  <a href="tags.html#Authentication">
                    <span class="tag is-info">
                      Authentication
                    </span>
                  </a>
                  <a href="tags.html#源码分析">
                    <span class="tag is-info">
                      源码分析
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2019-08-14
                </p>
              </div>
              <div class="content article-body">
                <p>仅就认证处理器的工作机理而言，<code>JwtBearer</code>认证模式是最为简单的一种认证。所以，我们选择<code>JwtBearer</code>认证处理器作为本系列源码分析中关于认证处理器第一个具体实现的来讲述。</p>
<p><code>HandleAuthenticateAsync()</code>的基本逻辑是:</p>
<ol>
<li>触发接收到消息事件，事件处理程序通常可以设置新的<code>token</code>——这在使用<code>WebSocket</code>/<code>SignalR</code>认证中尤其有用，因为难以传递<code>Authorization: Bearer {token}</code>报头。事件处理程序甚至可以直接设置<code>messageReceivedContext.Result</code>来截断后续处理。</li>
<li>如果消息处理事件没有设置<code>Token</code>，则从<code>Authorization: Bearer {jwt-token}</code> 中获取</li>
<li>获取令牌校验参数</li>
<li>校验令牌，给出认证成功/失败结果</li>
</ol>
<p>由于这部分相对简单，这里直接贴出相关源码（具体过程参见我的注释）：<!-- more --></p>
<pre><code class="language-csharp">    protected override async Task&lt;AuthenticateResult&gt; HandleAuthenticateAsync()
    {
        string token = null;
        try
        {
            // 触发收到消息事件
            var messageReceivedContext = new MessageReceivedContext(Context, Scheme, Options);
            await Events.MessageReceived(messageReceivedContext);
            if (messageReceivedContext.Result != null)
            {
                return messageReceivedContext.Result;
            }
            token = messageReceivedContext.Token;


            // 如果消息事件没有为我们设置Token，则去Header中搜寻
            if (string.IsNullOrEmpty(token))
            {
                string authorization = Request.Headers[&quot;Authorization&quot;];
                if (string.IsNullOrEmpty(authorization)) { return AuthenticateResult.NoResult(); }
                if (authorization.StartsWith(&quot;Bearer &quot;, StringComparison.OrdinalIgnoreCase)) { token = authorization.Substring(&quot;Bearer &quot;.Length).Trim(); }
                if (string.IsNullOrEmpty(token)) { return AuthenticateResult.NoResult(); }
            }

            // 获取校相关验参数
            if (_configuration == null &amp;&amp; Options.ConfigurationManager != null)
            {
                _configuration = await Options.ConfigurationManager.GetConfigurationAsync(Context.RequestAborted);
            }
            var validationParameters = Options.TokenValidationParameters.Clone();
            if (_configuration != null)
            {
                var issuers = new[] { _configuration.Issuer };
                validationParameters.ValidIssuers = validationParameters.ValidIssuers?.Concat(issuers) ?? issuers;

                validationParameters.IssuerSigningKeys = validationParameters.IssuerSigningKeys?.Concat(_configuration.SigningKeys)
                    ?? _configuration.SigningKeys;
            }


            // 校验Token
            List&lt;Exception&gt; validationFailures = null;
            SecurityToken validatedToken;
            foreach (var validator in Options.SecurityTokenValidators)
            {
                if (validator.CanReadToken(token))
                {
                    ClaimsPrincipal principal;
                    try
                    {
                        principal = validator.ValidateToken(token, validationParameters, out validatedToken);
                    }
                    catch (Exception ex)
                    {
                        Logger.TokenValidationFailed(ex);

                        // Refresh the configuration for exceptions that may be caused by key rollovers. The user can also request a refresh in the event.
                        if (Options.RefreshOnIssuerKeyNotFound &amp;&amp; Options.ConfigurationManager != null
                            &amp;&amp; ex is SecurityTokenSignatureKeyNotFoundException)
                        {
                            Options.ConfigurationManager.RequestRefresh();
                        }

                        if (validationFailures == null)
                        {
                            validationFailures = new List&lt;Exception&gt;(1);
                        }
                        validationFailures.Add(ex);
                        continue;
                    }

                    Logger.TokenValidationSucceeded();

                    var tokenValidatedContext = new TokenValidatedContext(Context, Scheme, Options)
                    {
                        Principal = principal,
                        SecurityToken = validatedToken
                    };

                    await Events.TokenValidated(tokenValidatedContext);
                    if (tokenValidatedContext.Result != null)
                    {
                        return tokenValidatedContext.Result;
                    }

                    if (Options.SaveToken)
                    {
                        tokenValidatedContext.Properties.StoreTokens(new[]
                        {
                            new AuthenticationToken { Name = &quot;access_token&quot;, Value = token }
                        });
                    }

                    tokenValidatedContext.Success();
                    return tokenValidatedContext.Result;
                }
            }

            if (validationFailures != null)
            {
                var authenticationFailedContext = new AuthenticationFailedContext(Context, Scheme, Options)
                {
                    Exception = (validationFailures.Count == 1) ? validationFailures[0] : new AggregateException(validationFailures)
                };

                await Events.AuthenticationFailed(authenticationFailedContext);
                if (authenticationFailedContext.Result != null)
                {
                    return authenticationFailedContext.Result;
                }

                return AuthenticateResult.Fail(authenticationFailedContext.Exception);
            }

            return AuthenticateResult.Fail(&quot;No SecurityTokenValidator available for token: &quot; + token ?? &quot;[null]&quot;);
        }
        catch (Exception ex)
        {
            Logger.ErrorProcessingMessage(ex);

            var authenticationFailedContext = new AuthenticationFailedContext(Context, Scheme, Options)
            {
                Exception = ex
            };

            await Events.AuthenticationFailed(authenticationFailedContext);
            if (authenticationFailedContext.Result != null)
            {
                return authenticationFailedContext.Result;
            }

            throw;
        }
    }
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/CSharp/ASP.NET Core/Security/Authentication/Authentication — (3.1) 认证处理器的实现之AuthenticationHandler抽象基类.html">
                    Authentication — (3.1) 认证处理器的实现之AuthenticationHandler抽象基类
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        CSharp
                      </a>
                    </li>
                    <li>
                      <a href="">
                        ASP.NET Core
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Security
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Authentication
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#ASP.NET Core">
                    <span class="tag is-info">
                      ASP.NET Core
                    </span>
                  </a>
                  <a href="tags.html#CSharp">
                    <span class="tag is-info">
                      CSharp
                    </span>
                  </a>
                  <a href="tags.html#Authentication">
                    <span class="tag is-info">
                      Authentication
                    </span>
                  </a>
                  <a href="tags.html#源码分析">
                    <span class="tag is-info">
                      源码分析
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2019-08-14
                </p>
              </div>
              <div class="content article-body">
                <p>前文说到，<code>AspNet/HttpAbstractions</code>项目中定义了<code>IAuthenticationHandler</code>接口，负责针对每个请求进行认证处理，包含了初始化、认证、质询、和禁止访问4个功能：</p>
<pre><code class="language-csharp">public interface IAuthenticationHandler
{
    Task InitializeAsync(AuthenticationScheme scheme, HttpContext context);
    Task&lt;AuthenticateResult&gt; AuthenticateAsync();
    Task ChallengeAsync(AuthenticationProperties properties);
    Task ForbidAsync(AuthenticationProperties properties);
}
</code></pre>
<p>在<code>AspNet/Security</code>项目中，提供了一个抽象类<code>AuthenticationHandler&lt;TOptions&gt;</code>作为<code> IAuthenticationHandler</code>的基础实现：</p>
<pre><code class="language-csharp">public abstract class AuthenticationHandler&lt;TOptions&gt; : IAuthenticationHandler 
    where TOptions : AuthenticationSchemeOptions, new()
{
     // ...
}
</code></pre>
<p>其中，初始化只是简单地设置模式、<code>HttpContext</code>，创建事件处理器等：<!-- more --></p>
<pre><code class="language-csharp">    // 初始化，设置scheme，context ，事件等
    public async Task InitializeAsync(AuthenticationScheme scheme, HttpContext context)
    {
        // ...
        
        Scheme = scheme;
        Context = context;

        Options = OptionsMonitor.Get(Scheme.Name) ?? new TOptions();
        Options.Validate(Scheme.Name);

        await InitializeEventsAsync();
        await InitializeHandlerAsync();
    }
</code></pre>
<p>而其余三个关键的接口方法分别负责认证、质询、和禁止，三者的处理逻辑都是先进行<strong>转发检测</strong>，判断是否要转发给其他认证模式。如果需要转发，则转而调用<code>HttpContext</code>上的认证服务处理；否则，就会调用自身的处理认证、处理质询、和处理禁止方法。</p>
<p>转发检测是通过<code>ResolveTarget(scheme)</code>这个函数完成的，该函数非常简单，只是根据当前认证处理器的配置选项，解析需要转发给哪个目标认证模式：</p>
<pre><code class="language-csharp">    protected virtual string ResolveTarget(string scheme)
    {
        var target = scheme ?? Options.ForwardDefaultSelector?.Invoke(Context) ?? Options.ForwardDefault;

        // Prevent self targetting
        return string.Equals(target, Scheme.Name, StringComparison.Ordinal)
            ? null
            : target;
    }
</code></pre>
<p>可以看到获取目标模式的优先级为：</p>
<ol>
<li>如果配置了<code>ForwardDefaultSelector</code>函数，则调用此函数来获取转发模式，</li>
<li>如果结果为空，则尝试用<code>ForwardDefault</code>选项来设置</li>
</ol>
<h3>认证</h3>
<p>如果想把认证过程转发给其他认证模式，则转而调用<code>HttpContext</code>的认证服务进行处理；否则，则使用自己的逻辑进行处理，并返回认证结果。当然，为了避免同一次请求过程中反复计算<code>AuthenticationResult</code>，需要把结果缓存下来，也即调用<code>await HandleAuthenticateOnceAsync();</code>来避免反复计算:</p>
<pre><code class="language-csharp">    public async Task&lt;AuthenticateResult&gt; AuthenticateAsync()
    {
        // target scheme string
        var target = ResolveTarget(Options.ForwardAuthenticate);
        if (target != null)
        {
            return await Context.AuthenticateAsync(target);
        }

        // Calling Authenticate more than once should always return the original value.
        var result = await HandleAuthenticateOnceAsync();
        // ... log
        return result;
    }
</code></pre>
<p><code> HandleAuthenticateOnceAsync()</code>函数只是简单的调用自身的<code>HandleAuthenticateAsync()</code>进行处理，这里的<code>HandleAuthenticateAsync()</code>是一个抽象方法，留待子类实现；在当次请求过程中，第一次认证结束后的认证结果会缓存下来，当次请求过程中如果还有后续认证需求的话，直接从当前缓存中返回认证结果：</p>
<pre><code class="language-csharp">    protected Task&lt;AuthenticateResult&gt; HandleAuthenticateOnceAsync()
    {
        if (_authenticateTask == null)
        {
            _authenticateTask = HandleAuthenticateAsync();
        }

        return _authenticateTask;
    }
    
    protected abstract Task&lt;AuthenticateResult&gt; HandleAuthenticateAsync();
</code></pre>
<h3>质询</h3>
<p>和认证方法类似，质询也是优先判断是否要转发给其他模式质询，如果没有的话，再调用自身的抽象方法<code>HandleChallengeAsync</code>处理质询过程：</p>
<pre><code class="language-csharp">    public async Task ChallengeAsync(AuthenticationProperties properties)
    {
        var target = ResolveTarget(Options.ForwardChallenge);
        if (target != null)
        {
            await Context.ChallengeAsync(target, properties);
            return;
        }

        properties = properties ?? new AuthenticationProperties();
        await HandleChallengeAsync(properties);
        Logger.AuthenticationSchemeChallenged(Scheme.Name);
    }
</code></pre>
<p>这里默认的处理质询过程只是返回一个<code>401</code></p>
<pre><code class="language-csharp">    protected virtual Task HandleChallengeAsync(AuthenticationProperties properties)
    {
        Response.StatusCode = 401;
        return Task.CompletedTask;
    }
</code></pre>
<h3>禁止</h3>
<p>至于禁止方法，同样还是优先判断是否要转发给其他模式禁止。如果不需要，则由<code>HandleForbiddenAsync()</code>方法自身处理禁止过程：</p>
<pre><code class="language-csharp">    public async Task ForbidAsync(AuthenticationProperties properties)
    {
        var target = ResolveTarget(Options.ForwardForbid);
        if (target != null)
        {
            await Context.ForbidAsync(target, properties);
            return;
        }

        properties = properties ?? new AuthenticationProperties();
        await HandleForbiddenAsync(properties);
        Logger.AuthenticationSchemeForbidden(Scheme.Name);
    }
</code></pre>
<p>默认禁止只是返回一个<code>403</code> :</p>
<pre><code class="language-csharp">    protected virtual Task HandleForbiddenAsync(AuthenticationProperties properties)
    {
        Response.StatusCode = 403;
        return Task.CompletedTask;
    }
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/CSharp/ASP.NET Core/Security/Authentication/Authentication — (1) 基本概念.html">
                    Authentication — (1) 基本概念
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        CSharp
                      </a>
                    </li>
                    <li>
                      <a href="">
                        ASP.NET Core
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Security
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Authentication
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#ASP.NET Core">
                    <span class="tag is-info">
                      ASP.NET Core
                    </span>
                  </a>
                  <a href="tags.html#CSharp">
                    <span class="tag is-info">
                      CSharp
                    </span>
                  </a>
                  <a href="tags.html#Authentication">
                    <span class="tag is-info">
                      Authentication
                    </span>
                  </a>
                  <a href="tags.html#源码分析">
                    <span class="tag is-info">
                      源码分析
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2019-08-14
                </p>
              </div>
              <div class="content article-body">
                <p>这部分代码在<code>HttpAbstractions</code>项目中定义，定义在<code>Microsoft.AspNetCore.Authentication</code>命名空间下。</p>
<p>本篇笔记分为两大部分：</p>
<ol>
<li>第一部分主要讲述<strong>认证模式</strong>、<strong>认证处理器</strong>及相应的<strong>认证模式Provider</strong>和<strong>认证处理器Provider</strong></li>
<li>第二部分主要对认证过程中涉及的相关类型进行描述，主要包括<strong>认证属性</strong>、<strong>认证票据</strong>、<strong>认证结果</strong></li>
</ol>
<h3>认证模式</h3>
<p>认证模式类<code>AuthenticationScheme</code>非常简单，顾名思义，它代表了某一种特定的认证模式，其中还包含了对应的认证处理器的类型信息：</p>
<pre><code class="language-csharp">public class AuthenticationScheme
{
    public AuthenticationScheme(string name, string displayName, Type handlerType)
    {
        if (name == null) { /* throw */ }
        if (handlerType == null) { /* throw */ }
        if (!typeof(IAuthenticationHandler).IsAssignableFrom(handlerType)) { /* throw */ }

        Name = name;
        HandlerType = handlerType;
        DisplayName = displayName;
    }

    public string Name { get; }
    public string DisplayName { get; }

    public Type HandlerType { get; }
}
</code></pre>
<p>常见的认证模式有 <code>Cookies</code>、<code>Bearer</code>、<code>OAuth</code>、<code>OpenIdConnect</code>、<code>Google</code>、<code>Microsoft</code>、<code>Facebook</code>等。每种 认证模式都有各自的处理器负责处理用户认证事宜。注意，<strong><code>Scheme</code>中存储的并非是<code>Handler</code>实例，而是<code>Handler</code>的类型！</strong> <!-- more --></p>
<h3>认证处理器相关接口</h3>
<p><code>IAuthenticationHandler</code>接口负责针对每个请求进行认证处理，包含了<strong>初始化</strong>、<strong>认证</strong>、<strong>质询</strong>、和<strong>禁止</strong>访问几个功能：</p>
<pre><code class="language-csharp">public interface IAuthenticationHandler
{
    Task InitializeAsync(AuthenticationScheme scheme, HttpContext context); // 初始化
    Task&lt;AuthenticateResult&gt; AuthenticateAsync();                           // 认证
    Task ChallengeAsync(AuthenticationProperties properties);               // 质询
    Task ForbidAsync(AuthenticationProperties properties);                  // 禁止
}
</code></pre>
<p>除了以上几个通用的功能，还有两个特化的认证处理器接口用于<strong>登入</strong>和<strong>登出</strong>：</p>
<pre><code class="language-csharp">public interface IAuthenticationSignOutHandler : IAuthenticationHandler
{
    Task SignOutAsync(AuthenticationProperties properties);
}

public interface IAuthenticationSignInHandler : IAuthenticationSignOutHandler
{
    Task SignInAsync(ClaimsPrincipal user, AuthenticationProperties properties);
}
</code></pre>
<p>最后，还有一个特化的接口<code>IAuthenticationRequestHandler</code> 用于<strong>中间件级别的请求处理</strong>：</p>
<pre><code class="language-csharp">public interface IAuthenticationRequestHandler : IAuthenticationHandler
{
    Task&lt;bool&gt; HandleRequestAsync();
}
</code></pre>
<p>如果一个<code>IAuthenticationHanlder</code>接口对象可以转换为<code>IAuthenticationRequestHandler</code>接口，则说明该 接口对象否想参与中间件级别的请求处理，其<code>HandlerRequestAsync()</code>方法将用于对请求进行处理；当该方法完成后，如果希望系统停止后续中间件的处理，则返回<code>true</code>，否则返回<code>false</code>。</p>
<h3><code>AuthenticationSchemeProvider</code></h3>
<p><code>IAuthenticationSchemeProvider</code>接口用于</p>
<ul>
<li>枚举当前认证模式</li>
<li>增、删某种认证模式</li>
<li>查找某种认证模式</li>
</ul>
<pre><code class="language-csharp">public interface IAuthenticationSchemeProvider
{
    Task&lt;IEnumerable&lt;AuthenticationScheme&gt;&gt; GetAllSchemesAsync();
    Task&lt;AuthenticationScheme&gt; GetSchemeAsync(string name);
   
    Task&lt;AuthenticationScheme&gt; GetDefaultAuthenticateSchemeAsync();
    Task&lt;AuthenticationScheme&gt; GetDefaultChallengeSchemeAsync();
    Task&lt;AuthenticationScheme&gt; GetDefaultForbidSchemeAsync();
    Task&lt;AuthenticationScheme&gt; GetDefaultSignInSchemeAsync();
    Task&lt;AuthenticationScheme&gt; GetDefaultSignOutSchemeAsync();

    void AddScheme(AuthenticationScheme scheme);
    void RemoveScheme(string name);

    Task&lt;IEnumerable&lt;AuthenticationScheme&gt;&gt; GetRequestHandlerSchemesAsync();
}
</code></pre>
<p>其默认实现为<code>AuthenticationSchemeProvider</code>，由于源码较为简单，此处不再赘述。</p>
<h3><code>AuthenticationHandlerProvider</code></h3>
<p><code>IAuthenticationHandlerProvider</code>用于提供与指定模式名相匹配的认证处理器的实例，其接口定义为：</p>
<pre><code class="language-csharp">public interface IAuthenticationHandlerProvider
{
    Task&lt;IAuthenticationHandler&gt; GetHandlerAsync(HttpContext context, string authenticationScheme);
}
</code></pre>
<p>作为<code>IAuthenticationHandlerProvider</code>接口的默认实现，<code>AuthenticationHandlerProvider</code>包含了一个<code>IAuthenticatioSchemProvider</code>属性，获取相应认证模式处理器的类型，然后根据类型信息创建一个实例并存入缓存：</p>
<pre><code class="language-csharp">namespace Microsoft.AspNetCore.Authentication
{
    public class AuthenticationHandlerProvider : IAuthenticationHandlerProvider
    {
        public AuthenticationHandlerProvider(IAuthenticationSchemeProvider schemes)
        {
            Schemes = schemes;
        }

        public IAuthenticationSchemeProvider Schemes { get; }
        // 创建一个字典作为缓存
        private Dictionary&lt;string, IAuthenticationHandler&gt; _handlerMap = new Dictionary&lt;string, IAuthenticationHandler&gt;(StringComparer.Ordinal);

        public async Task&lt;IAuthenticationHandler&gt; GetHandlerAsync(HttpContext context, string authenticationScheme){
            // 优先从缓存中查询
            if (_handlerMap.ContainsKey(authenticationScheme)){ return _handlerMap[authenticationScheme]; }

            var scheme = await Schemes.GetSchemeAsync(authenticationScheme);
            if (scheme == null){ return null; }
            
            // 创建实例、初始化、存入缓存
            var handler = (context.RequestServices.GetService(scheme.HandlerType) ??
                ActivatorUtilities.CreateInstance(context.RequestServices, scheme.HandlerType))
                as IAuthenticationHandler;
            if (handler != null){
                await handler.InitializeAsync(scheme, context);
                _handlerMap[authenticationScheme] = handler;
            }
            return handler;
        }
    }
}
</code></pre>
<h3>认证属性、认证票据和认证结果</h3>
<h4><code>AuthenticationProperties</code></h4>
<p>认证属性是一个简单的类似于字典一样的对象，用于存取关于认证会话的各项属性。其中，最核心的是两个字典属性：</p>
<ul>
<li><code>Items</code> ： <code>Dictionary&lt;string,string&gt;</code>型字典</li>
<li><code>Parameters</code>：<code>Dictionary&lt;string,object&gt;</code>型字典，用于在handler之间共享对象，不可序列化或者持久化</li>
</ul>
<pre><code class="language-csharp">public class AuthenticationProperties
{
    // ...

    public IDictionary&lt;string, string&gt; Items { get; }

    public IDictionary&lt;string, object&gt; Parameters { get; }
}
</code></pre>
<p>为了方便起见，<code>AuthenticationProperties</code>针对<code>Parameters</code>字典和<code>Items</code>提供了如下的取、存方法</p>
<pre><code class="language-csharp">public class AuthenticationProperties
{
    // ...
    
    public T GetParameter&lt;T&gt;(string key) =&gt; Parameters.TryGetValue(key, out var obj) &amp;&amp; obj is T value ? value : default;

    public void SetParameter&lt;T&gt;(string key, T value) =&gt; Parameters[key] = value;
        
    public string GetString(string key)
    {
        return Items.TryGetValue(key, out string value) ? value : null;
    }

    public void SetString(string key, string value)
    {
        if (value != null) {
            Items[key] = value;
        } else if (Items.ContainsKey(key)) {
            Items.Remove(key);
        }
    }
}       
</code></pre>
<p>而<code>Items</code>虽然只能存储<code>string</code>型值，但是配合<code>ToString()</code>和从字符串解析的功能，还可以对<code>bool</code>、<code>DateTime</code>型数据类型进行存取：</p>
<pre><code class="language-csharp">public class AuthenticationProperties
{
    // ...
    
    protected bool? GetBool(string key) { /* ...*/ }

    protected void SetBool(string key, bool? value) { /* ...*/ }
    
    protected DateTimeOffset? GetDateTimeOffset(string key) { /* ...*/ }

    protected void SetDateTimeOffset(string key, DateTimeOffset? value) { /* ...*/ }
}
</code></pre>
<p>在此基础之上，对一些常用属性及值提供了便利方法：</p>
<pre><code class="language-csharp">{
    internal const string IssuedUtcKey = &quot;.issued&quot;;
    internal const string ExpiresUtcKey = &quot;.expires&quot;;
    internal const string IsPersistentKey = &quot;.persistent&quot;;
    internal const string RedirectUriKey = &quot;.redirect&quot;;
    internal const string RefreshKey = &quot;.refresh&quot;;
    internal const string UtcDateTimeFormat = &quot;r&quot;;

    public bool IsPersistent
    {
        get =&gt; GetString(IsPersistentKey) != null;
        set =&gt; SetString(IsPersistentKey, value ? string.Empty : null);
    }

    /// &lt;summary&gt;
    /// Gets or sets the full path or absolute URI to be used as an http redirect response value.
    /// &lt;/summary&gt;
    public string RedirectUri
    {
        get =&gt; GetString(RedirectUriKey);
        set =&gt; SetString(RedirectUriKey, value);
    }

    /// &lt;summary&gt;
    /// Gets or sets the time at which the authentication ticket was issued.
    /// &lt;/summary&gt;
    public DateTimeOffset? IssuedUtc
    {
        get =&gt; GetDateTimeOffset(IssuedUtcKey);
        set =&gt; SetDateTimeOffset(IssuedUtcKey, value);
    }

    /// &lt;summary&gt;
    /// Gets or sets the time at which the authentication ticket expires.
    /// &lt;/summary&gt;
    public DateTimeOffset? ExpiresUtc
    {
        get =&gt; GetDateTimeOffset(ExpiresUtcKey);
        set =&gt; SetDateTimeOffset(ExpiresUtcKey, value);
    }

    /// &lt;summary&gt;
    /// Gets or sets if refreshing the authentication session should be allowed.
    /// &lt;/summary&gt;
    public bool? AllowRefresh
    {
        get =&gt; GetBool(RefreshKey);
        set =&gt; SetBool(RefreshKey, value);
    }
}
</code></pre>
<h4><code>AuthenticationTicket</code></h4>
<p>认证票据封装了用户身份信息和一些配套的认证属性，如过期信息、是否允许刷新等。</p>
<pre><code class="language-csharp">public class AuthenticationTicket
{

    public AuthenticationTicket(ClaimsPrincipal principal, AuthenticationProperties properties, string authenticationScheme)
    {
        if (principal == null) { /* throw */ }

        AuthenticationScheme = authenticationScheme;
        Principal = principal;
        Properties = properties ?? new AuthenticationProperties();
    }

    public AuthenticationTicket(ClaimsPrincipal principal, string authenticationScheme) 
        : this(principal, properties: null, authenticationScheme: authenticationScheme)
    { }


    public string AuthenticationScheme { get; private set; }

    public ClaimsPrincipal Principal { get; private set; }

    public AuthenticationProperties Properties { get; private set; }
}
</code></pre>
<h4><code>AuthenticationResult</code></h4>
<p>认证结果有三种，分别是：</p>
<ul>
<li>没有结果：暂时无法确定最终认证结果，留待其他认证处理程序处理。</li>
<li>认证成功：需要提供认证票据</li>
<li>认证失败：需要指定失败消息</li>
</ul>
<p><code>AuthenticationResult</code>提供了一个类来封装了以上所有信息：</p>
<pre><code class="language-csharp">public class AuthenticateResult
{
    public AuthenticationTicket Ticket { get; protected set; }    // 认证成功时的票据

    public ClaimsPrincipal Principal =&gt; Ticket?.Principal;        // 认证成功时票据中的主体

    public AuthenticationProperties Properties { get; protected set; } // 认证属性

    public Exception Failure { get; protected set; }               // 认证失败时的失败异常

    public bool None { get; protected set; }                       // 认证是否没有结果
     
    public bool Succeeded =&gt; Ticket != null;                       // 认证是否已经成功
}
</code></pre>
<p><code>AuthenticationResult</code>还提供了三类静态方法来创建认证结果</p>
<pre><code class="language-csharp">public class AuthenticateResult
{
    // ...
    
    
    public static AuthenticateResult NoResult()
    {
        return new AuthenticateResult() { None = true };
    }
    
    public static AuthenticateResult Success(AuthenticationTicket ticket)
    {
        if (ticket == null)
        {
            throw new ArgumentNullException(nameof(ticket));
        }
        return new AuthenticateResult() { Ticket = ticket, Properties = ticket.Properties };
    }

    public static AuthenticateResult Fail(Exception failure)
    {
        return new AuthenticateResult() { Failure = failure };
    }

    public static AuthenticateResult Fail(Exception failure, AuthenticationProperties properties)
    {
        return new AuthenticateResult() { Failure = failure, Properties = properties };
    }

    public static AuthenticateResult Fail(string failureMessage)
        =&gt; Fail(new Exception(failureMessage));

    public static AuthenticateResult Fail(string failureMessage, AuthenticationProperties properties)
        =&gt; Fail(new Exception(failureMessage), properties);
}
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/CSharp/Bot Framework/BotBuilder 源码通读6.html">
                    BotBuilder 源码通读6 —— 对话建模与实现2
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        CSharp
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Bot Framework
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#Bot Framework">
                    <span class="tag is-info">
                      Bot Framework
                    </span>
                  </a>
                  <a href="tags.html#CSharp">
                    <span class="tag is-info">
                      CSharp
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2019-05-30
                </p>
              </div>
              <div class="content article-body">
                <p>上一篇关于<a href="/blog/2019/03/20/WindWhisper/CSharp/Bot%20Framework/BotBuilder%20%E6%BA%90%E7%A0%81%E9%80%9A%E8%AF%BB5/"><code>BotBuilder</code>对话建模</a>的博文中讲述了对话建模的一些基本思想和工作原理。这一篇作为补充，记录几个具体的对话类作用。</p>
<h2><code>Prompt</code></h2>
<p><code>Prompt&lt;T&gt;</code>类对话是最为基础的一类<code>Dialog</code>。这类<code>Dialog</code>无非就是询问用户、提示用户输入，并对用户输入的结果予以检验。比如<code>Prompt&lt;T&gt;::ContinueDialogAsync()</code>方法实现为：</p>
<pre><code class="language-csharp">public override async Task&lt;DialogTurnResult&gt; ContinueDialogAsync(DialogContext dc, CancellationToken cancellationToken = default(CancellationToken))
{
    if (dc == null) { /* throw */ }
    // Don't do anything for non-message activities
    if (dc.Context.Activity.Type != ActivityTypes.Message) { return EndOfTurn; }

    // Perform base recognition
    var instance = dc.ActiveDialog;
    var state = (IDictionary&lt;string, object&gt;)instance.State[PersistedState];
    var options = (PromptOptions)instance.State[PersistedOptions];

    //识别用户输入
    var recognized = await OnRecognizeAsync(dc.Context, state, options, cancellationToken).ConfigureAwait(false);
    // 记录所尝试的次数
    state[AttemptCountKey] = Convert.ToInt32(state[AttemptCountKey]) + 1;

    // 验证是否有效
    // ... set `isValid` by : `_validator(promptContext,cancellationToken)`

    // 结束对话并恢复上一级对话执行
    if (isValid) { return await dc.EndDialogAsync(recognized.Value, cancellationToken).ConfigureAwait(false); }

    if (!dc.Context.Responded) { await OnPromptAsync(dc.Context, state, options, true, cancellationToken).ConfigureAwait(false); }
    return EndOfTurn;
}
</code></pre>
<p>从上面的代码可以看出，<code>Prompt&lt;T&gt;</code>的<code>ContinueDialogAsync()</code>方法需要子类提供<code>OnPromptAsync()</code>方法和<code>OnRecognizeAsync()</code>的实现，以负责提示用户输入、及识别用户输入。：</p>
<pre><code class="language-csharp">protected abstract Task OnPromptAsync(ITurnContext turnContext, IDictionary&lt;string, object&gt; state, PromptOptions options, bool isRetry, CancellationToken cancellationToken = default(CancellationToken));

protected abstract Task&lt;PromptRecognizerResult&lt;T&gt;&gt; OnRecognizeAsync(ITurnContext turnContext, IDictionary&lt;string, object&gt; state, PromptOptions options, CancellationToken cancellationToken = default(CancellationToken));
</code></pre>
<p><code>Prompt&lt;T&gt;</code>有不同的子类实现，最常见的莫过于<code>TextPrompt</code>，它接受一个<code>string</code>类型作为输入。其他常见的<code>Prompt&lt;&gt;</code>子类包括：<code>NumberPrompt&lt;T&gt;</code>、<code>DateTimePrompt</code>、<code>ConfrimPrompt</code>、<code>ChoicePrompt</code>、<code>AttachmentPrompt</code>等。此外，还有一些极个别的对话类，名字中带有<code>Prompt</code>，但并非继承自<code>Prompt&lt;T&gt;</code>，比如<code>OAuthPrompt</code>类，此处不予赘述。<!-- more --></p>
<h2><code>WaterfallDialog</code></h2>
<p><code>WaterfallDialog</code>是一种对瀑布流执行流程的抽象。简单的说，它有若干小步，每个小步都是一个委托类型：</p>
<pre><code class="language-csharp">public delegate Task&lt;DialogTurnResult&gt; WaterfallStep(WaterfallStepContext stepContext, CancellationToken cancellationToken);
</code></pre>
<p>这些小步接受<code>WaterfallStepContext</code>参数，并像一个对话<code>API</code>那样返回一个<code>DialogTurnResult</code>。在<code>WaterfallDialog</code>运行时，这些小步依次执行，直至全部完成。</p>
<p>从实现上说，这些小步会被组织为一个<code>List&lt;WaterfallStep&gt;</code>，然后在状态里保存一个<code>stepIndex</code>的整型变量记录当前是第几步。每当<code>ContinueDialogAsync()</code>/<code>ResumeDialogAsync()</code>执行后，都会触发下一步的运行:</p>
<pre><code class="language-csharp">public override async Task&lt;DialogTurnResult&gt; ContinueDialogAsync(DialogContext dc, CancellationToken cancellationToken = default(CancellationToken))
{
    if (dc == null) { /* throw */ }
    // Don't do anything for non-message activities.
    if (dc.Context.Activity.Type != ActivityTypes.Message) { return Dialog.EndOfTurn; }

    // Run next step with the message text as the result.
    return await ResumeDialogAsync(dc, DialogReason.ContinueCalled, dc.Context.Activity.Text, cancellationToken)
        .ConfigureAwait(false);
}


public override async Task&lt;DialogTurnResult&gt; ResumeDialogAsync(DialogContext dc, DialogReason reason, object result, CancellationToken cancellationToken = default(CancellationToken))
{
    if (dc == null) { /* throw */ }
    // Increment step index and run step
    var state = dc.ActiveDialog.State;
    var index = Convert.ToInt32(state[StepIndex]);
    return await RunStepAsync(dc, index + 1, reason, result, cancellationToken)
        .ConfigureAwait(false);
}
</code></pre>
<h2><code>ComponentDialog</code></h2>
<p><code>ComponentDialog</code>是一个组件对话。顾名思义，这是按照设计模式中的组合模式来设计的对话组件。我们可以把一组对话组合成一个<code>ComponentDialog</code>，这个<code>ComponentDialog</code>本身又继承自<code>Dialog</code>类，故可以将之作为一个整体用于<code>Dialog</code>的相关场景。</p>
<h3><code>AddDialog(dialog)</code></h3>
<p><code>ComponentDialog</code>在内部嵌入了一个<code>DialogSet</code>，通过调用<code>AddDialog(Dialog dialog)</code>方法可以向其中添加子对话。借助于<code>DialogSet</code>，这些子对话之间可以互相调用。</p>
<pre><code class="language-csharp">public ComponentDialog AddDialog(Dialog dialog)
{
    _dialogs.Add(dialog);                         // 把子对话加入对话集
    if (string.IsNullOrEmpty(InitialDialogId))
    {
        InitialDialogId = dialog.Id;              // 设置初始对话ID
    }

    return this;
}
</code></pre>
<p>一种可能的执行流程为:</p>
<ul>
<li>在启动时，<code>BeginDialogAsync(DialogContext outerDc, object opts, CancellationToken ct)</code>会启动当前自身<code>DialogSet</code>中的Id为初始ID的<code>Dialog</code>。如此，对话栈中就被压入了一个的子对话。</li>
<li>当程序收到消息继续执行时，程序无脑执行栈顶对话的<code>ContinueDialogAsync()</code>方法。假设当前栈顶是子对话A，子对话A根据自身需要，可能调用了对话B</li>
<li>当程序收到消息继续执行时，程序无脑执行栈顶B对话的<code>ContinueDialogAsync()</code>方法，假设B对话只是简单询问用户消息并保存在某个状态中，那么B对话在收到消息后<code>ContinueDialogAsync()</code>执行时保存相关消息，结束当前对并返回上一步对话（通过<code>dc.EndDialogAsync(result)</code>结束当前会话并触发上一级对话的<code>ResumeDialogAsync()</code>）</li>
<li>当程序收到消息继续执行(当前栈顶为A对话)，程序无脑执行栈顶A对话的<code>ContinueDialogAsync()</code>方法。A对话的<code>ContinueDialogAsync()</code>发现相关信息均已收集到，通过<code>dc.EndDialogAsync(result)</code>结束会话，如何触发A的上一级会话的<code>Resume</code>。如果栈中再无其他会话，则会直接返回一个状态为<code>DialogTurnStatus.Complete</code>的结果。</li>
</ul>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/Alchemy/machine-learning/机器学习 - 分类技术/KNN.html">
                    机器学习 KNN算法
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        大道
                      </a>
                    </li>
                    <li>
                      <a href="">
                        炼丹
                      </a>
                    </li>
                    <li>
                      <a href="">
                        机器学习
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#炼丹">
                    <span class="tag is-info">
                      炼丹
                    </span>
                  </a>
                  <a href="tags.html#机器学习">
                    <span class="tag is-info">
                      机器学习
                    </span>
                  </a>
                  <a href="tags.html#分类技术">
                    <span class="tag is-info">
                      分类技术
                    </span>
                  </a>
                  <a href="tags.html#KNN">
                    <span class="tag is-info">
                      KNN
                    </span>
                  </a>
                  <a href="tags.html#FSharp">
                    <span class="tag is-info">
                      FSharp
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2019-05-29
                </p>
              </div>
              <div class="content article-body">
                <h2><code>KNN</code>算法的基本思想</h2>
<p>考虑一个平面上有数百个样点，这些样点分属于<code>A</code>类、<code>B</code>类和<code>C</code>类。已知各个点的类别与其坐标存在某种密切的关联，特定类别的点会在某个区域富集。现有一个新的点，已知该点周边最近的<code>$K$</code>个点中，几乎都属于<code>A</code>类，问该点最有可能是哪个类？</p>
<p>常识告诉我们，该点很可能也属于<code>A</code>类。这便是<code>KNN</code>的基本思想——最邻近的<code>$K$</code>个点中，如果其中大部分点都属于某个类别，那么该点就很可能也属于该类。</p>
<h2><code>KNN</code>算法的实现</h2>
<p><code>KNN</code>算法非常简单：</p>
<ol>
<li>计算该点与所有样点之间的距离(这里采用<strong>欧几里得距离</strong>)</li>
<li>找出最近的<code>k</code>个样品</li>
<li>统计这<code>k</code>个样品的类别</li>
</ol>
<p>对于点<code>$\bold x^{(p)}$</code> 和点<code>$\bold x^{(q)}$</code>之间的<strong>欧几里得距离</strong>，其实就是各个<strong>分量之差的平方和</strong>再取平方根。令:</p>
<p><code>$\bold x^{(p)}=(x^{(p)}_1,x^{(p)}_2,x^{(p)}_3,...,x^{(p)}_n)$</code>，
<code>$\bold x^{(q)}=(x^{(q)}_1,x^{(q)}_2,x^{(q)}_3,...,x^{(q)}_n)$</code>,</p>
<p>则<strong>欧几里得距离</strong>可以表示为：</p>
<pre><code class="language-math">%% KaTex
\text{Distance}^2 =\displaystyle \sum_{t=1}^{n} (x^{(p)}_t - x^{(q)}_t)^{2}
</code></pre>
<p>不过，这里我们并不需要取平方根，因为二者呈正相关，我们只需要计算各个分量之差的平方和即可得到最近的<code>$k$</code>个样品点。用代码表示则是：</p>
<pre><code class="language-fsharp">/// Euclidean distance function 
let distance (values1: float list) (values2: float list) = 
    List.sumBy 
        (fun it -&gt; Math.Pow( float( (fst it) - (snd it)), 2.0)) 
        (List.zip values1 values2)
</code></pre>
<p>根据前面描述的算法，可以给出<code>KNN</code>的算法完整实现如下(由于最近在学习<code>F#</code>，所以这里使用<code>F#</code>)：<!-- more --></p>
<pre><code class="language-fsharp">/// Sample Entry
type Entry = { Label: string; Value: float list }

/// KNN algo
let KNN (k: int) (entries: Entry list) (entry: Entry)  = 
    entries 
    |&gt; List.map (fun x -&gt;  (x.Label, distance (x.Value) (entry.Value) ) )
    |&gt; List.sortBy snd
    |&gt; List.take k
    |&gt; List.countBy fst
</code></pre>
<h3>测试</h3>
<p>考虑有一个<code>wdbc.data</code>文件，第一列是人员编号，第二列是当前分类，后面各列是相应的特性分量，则可以通过以下函数加载成一个<code>List&lt;Entry&gt;</code>:</p>
<pre><code class="language-csharp">/// 加载数据集文件，生成 Entry List
let loadValues (fileName: string) : Entry list =
    File.ReadAllLines fileName
    |&gt; Array.skip 1
    |&gt; Array.map (fun line -&gt;
        let items = line.Split(&quot;,&quot;)
        {
            Label = items.[1];
            Value = items
                |&gt; Array.skip 2
                |&gt; Array.map float 
                |&gt; Array.toList
        }
    )
    |&gt; Array.toList
</code></pre>
<p>测试代码：</p>
<pre><code class="language-fsharp">[&lt;EntryPoint&gt;]
let main argv =
    let dir = Directory.GetCurrentDirectory()
    let path = Path.Combine(dir,&quot;wdbc.data&quot; )
    let entries = loadValues path
    let result = KNN 5 (entries|&gt; List.take 50 ) (entries|&gt; List.skip 50 |&gt; List.head)

    printf &quot;%A\r\n&quot; result

    0 // return an integer exit code
</code></pre>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <div class="container">
      <div class="container has-text-centered">
        <a href="posts/page3.html">
          Previous
        </a>
        5 of 32
        <a href="posts/page5.html">
          Next
        </a>
      </div>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
       // 处理形如 <code>$E=mc^2$</code> 形式的公式
 var inlineMathNodes=document.querySelectorAll('code');
 var re=/^\$(.*)\$$/;
 for(var j=0;j<inlineMathNodes.length;j++){
   var result=re.exec(inlineMathNodes.item(j).innerText);
   if(result!==null){
	 katex.render(result[1], inlineMathNodes.item(j));
   }
 }
 function removeNode(node){
   if(node.remove){
	 node.remove();
   }else{
	 return first.parentNode.removeChild(node);
   }
 };

 // 查找所有 pre code.language-math 节点 以备筛出数据公式
 var nodes=document.querySelectorAll("pre code.language-math");
 for(var i=0;i<nodes.length;i++){
   var node=nodes.item(i);
   // 魔术标记所在行 
   try{
	 var lines = node.innerText.split('\n');
	 if((!!lines) && lines.length > 0)
	 {
	   var first = lines[0];
	   if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
		 var views = "";
		 // 逐行渲染
		 for(var k=1; k <lines.length; k++){
			 var f=lines[k];
			 views += katex.renderToString(f);
		 }
		 // 消除父级嵌套 
		 try{
		   node.innerHTML=views;
		 }catch(e){
		   // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
		   console.log('IE9 sucks',e);
		   $(tr).html(node.innerHTML);
		 }
	   }
	 }
   }
   catch(err){
	 console.log(err)
   }
 }
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>