<!DOCTYPE html><html>
  <head>
    <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie/"/>
    <script>
      document.addEventListener('DOMContentLoaded', () => {

	// Get all "navbar-burger" elements
	const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);
  
	// Check if there are any navbar burgers
	if ($navbarBurgers.length > 0) {
  
	  // Add a click event on each of them
	  $navbarBurgers.forEach( el => {
		el.addEventListener('click', () => {
  
		  // Get the target from the "data-target" attribute
		  const target = el.dataset.target;
		  const $target = document.getElementById(target);
  
		  // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
		  el.classList.toggle('is-active');
		  $target.classList.toggle('is-active');
  
		});
	  });
	}
  });
    </script>
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/languages/fsharp.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item is-active" href="">
            Home
          </a>
          <a class="navbar-item" href="tags.html">
            Tags
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/CSharp/ASP.NET Core/Security/Authorization/Authorization — (0) 基础概念 Policy的组合与构建.html">
                    Authorization — (0) 基础概念 Policy的组合与构建
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        CSharp
                      </a>
                    </li>
                    <li>
                      <a href="">
                        ASP.NET Core
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Security
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Authorization
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#ASP.NET Core">
                    <span class="tag is-info">
                      ASP.NET Core
                    </span>
                  </a>
                  <a href="tags.html#Authorization">
                    <span class="tag is-info">
                      Authorization
                    </span>
                  </a>
                  <a href="tags.html#CSharp">
                    <span class="tag is-info">
                      CSharp
                    </span>
                  </a>
                  <a href="tags.html#源码分析">
                    <span class="tag is-info">
                      源码分析
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2019-08-20
                </p>
              </div>
              <div class="content article-body">
                <p><code>ASP.NET Core</code>中，<code>Authorization</code>和<code>Authentication</code>机制有很大的相似之处：</p>
<ol>
<li>一个<code>WebApp</code>中，可以有多种<code>AuthenticationScheme</code>；类似的，也可以指定多种<code>AuthorizationPolicy</code>。</li>
<li><code>Authentication</code>通过<code>AuthentionOptions</code>来配置认证行为；类似的，<code>Authorization</code>通过<code>AuthorizationOptions</code>来配置授权行为。</li>
<li><code>AuthenticationOptions</code>提供<code>AddScheme(name,func)</code>方法来注册认证模式，并提供通过<code>AuthenticationBuilder</code>来构建<code>AuthenticationOptions</code>；而<code>AuthorizationOptions</code>提供<code>AddPolicy(name,func)</code>方法来添加授权策略，<code>AuthorizationBuilder</code> 则负责多个<code>Requirements</code>/<code>Policy</code>的组合，从而构建出最终的<code>AuthorizationOptions</code>。</li>
<li>认证处理器<code>AuthenticationHandler&lt;TSchemeOptions&gt;</code>依据某种具体模式选项进行认证；而授权处理器<code>AuthorizationHandler&lt;TRequirement&gt;</code>则依据某种具体的<code>TRequirement</code>进行授权。</li>
<li><code>Authentication</code>提供了一个中间件来自动认证；<code>Authorization</code>也提供了一个<code>MVC</code> <code>Filter</code>来授权，在3.0之后，甚至还添加了一个<code>AuthorizationMiddleware</code>来做授权工作。</li>
</ol>
<p>当然，在细节上，二者的实现还有很大的不同。比如<code>Authorization</code>并没有向<code>Authentication</code>那样，提供一个方法自动为用户注册自定义的<code>AuthorizationHandler&lt;TRequirement&gt;</code>（需要开发者手工注册）。这些具体的细节会后续几篇源码分析笔记中讲述。</p>
<h3><code>Policy</code> 和 <code>Requirement</code></h3>
<p><code>Requirement</code>只是表达“要求”这个概念的一个空接口：</p>
<pre><code class="language-csharp">public interface IAuthorizationRequirement { }
</code></pre>
<p>一个授权<code>Policy</code>由多条要求组成：</p>
<pre><code class="language-csharp">public class AuthorizationPolicy
{
    public AuthorizationPolicy(IEnumerable&lt;IAuthorizationRequirement&gt; requirements, IEnumerable&lt;string&gt; authenticationSchemes)
    {
        if (requirements == null) { /* throw */ }
        if (authenticationSchemes == null){ /* throw */ }
        if (requirements.Count() == 0){ /* throw */ }
        
        Requirements = new List&lt;IAuthorizationRequirement&gt;(requirements).AsReadOnly();
        AuthenticationSchemes = new List&lt;string&gt;(authenticationSchemes).AsReadOnly();
    }

    public IReadOnlyList&lt;IAuthorizationRequirement&gt; Requirements { get; }

    public IReadOnlyList&lt;string&gt; AuthenticationSchemes { get; }
}
</code></pre>
<!-- more -->
<h2><code>AuthorizationPolicyBuilder</code></h2>
<p><code>AuthorizationPolicyBuilder</code>的核心是两个<code>Requirement</code>列表和<code>AuthenticationSchemes</code>列表两个字段：</p>
<pre><code class="language-csharp">public class AuthorizationPolicyBuilder
{
    public IList&lt;IAuthorizationRequirement&gt; Requirements { get; set; } = new List&lt;IAuthorizationRequirement&gt;();
    public IList&lt;string&gt; AuthenticationSchemes { get; set; } = new List&lt;string&gt;();
    
    // ...
    
    public AuthorizationPolicy Build()
    {
        return new AuthorizationPolicy(Requirements, AuthenticationSchemes.Distinct());
    }
}
</code></pre>
<p>可以看到<code>Build()</code>方法非常简单，只是简单用自身的<code>Requirements</code>和<code>AuthenticationSchemes</code>创建一个新的<code>AuthenticationPolicy</code>。<code>Policy</code>的构建过程，本质上对认证模式、Requirement、Policy的组合过程。<code>Builder</code>为组合这些字段提供了一系列<code>RequireXyz()</code>辅助方法。</p>
<h3>RequireXyz()等系列方法</h3>
<p><code>AuthorizationPolicyBuilder</code>还提供了一系列添加<code>Requirement</code>的辅助方法：</p>
<ul>
<li><code>RequireClaim()</code>系列</li>
<li><code>RequireRole()</code>系列</li>
<li><code>RequireUserName()</code></li>
<li><code>RequireAuthenticatedUser()</code></li>
<li><code>RequireAssertion()</code>系列</li>
</ul>
<h4><code>RequireClaim()</code>系列：</h4>
<pre><code class="language-csharp">public class AuthorizationPolicyBuilder
{
    // ...
    
    public AuthorizationPolicyBuilder RequireClaim(string claimType, params string[] allowedValues)
    {
        if (claimType == null){ /*  throw  */ }
        return RequireClaim(claimType, (IEnumerable&lt;string&gt;)allowedValues);
    }

    public AuthorizationPolicyBuilder RequireClaim(string claimType, IEnumerable&lt;string&gt; allowedValues)
    {
        if (claimType == null){ /*  throw  */ }
        Requirements.Add(new ClaimsAuthorizationRequirement(claimType, allowedValues));
        return this;
    }

    public AuthorizationPolicyBuilder RequireClaim(string claimType)
    {
        if (claimType == null){ /*  throw  */ }
        Requirements.Add(new ClaimsAuthorizationRequirement(claimType, allowedValues: null));
        return this;
    }
    
    // ...
}
</code></pre>
<h4><code>RequireRole()</code>系列</h4>
<pre><code class="language-csharp">public class AuthorizationPolicyBuilder
{
    //  ...
    public AuthorizationPolicyBuilder RequireRole(params string[] roles)
    {
        if (roles == null){ /*  throw  */ }
        return RequireRole((IEnumerable&lt;string&gt;)roles);
    }

    public AuthorizationPolicyBuilder RequireRole(IEnumerable&lt;string&gt; roles)
    {
        if (roles == null){ /*  throw  */ }
        Requirements.Add(new RolesAuthorizationRequirement(roles));
        return this;
    }
</code></pre>
<h4><code>NameAuthorizationRequirement</code>和<code>DenyAnonymousAuthorizationRequirement</code></h4>
<pre><code class="language-csharp">    public AuthorizationPolicyBuilder RequireUserName(string userName)
    {
        if (userName == null){ /*  throw  */ }
        Requirements.Add(new NameAuthorizationRequirement(userName));
        return this;
    }

    public AuthorizationPolicyBuilder RequireAuthenticatedUser()
    {
        Requirements.Add(new DenyAnonymousAuthorizationRequirement());
        return this;
    }

}
</code></pre>
<h4><code>AssertionRequirement</code>系列</h4>
<pre><code class="language-csharp">    public AuthorizationPolicyBuilder RequireAssertion(Func&lt;AuthorizationHandlerContext, bool&gt; handler)
    {
        if (handler == null){ /*  throw  */ }
        Requirements.Add(new AssertionRequirement(handler));
        return this;
    }
    
    public AuthorizationPolicyBuilder RequireAssertion(Func&lt;AuthorizationHandlerContext, Task&lt;bool&gt;&gt; handler)
    {
        if (handler == null){ /*  throw  */ }
        Requirements.Add(new AssertionRequirement(handler));
        return this;
    }
</code></pre>
<h3>认证模式，Requirement，和Policy的组合</h3>
<p><code>AuthorizationPolicyBuilder</code>提供了三个帮助方法来向这两个列表字段中添加新的认证模式、<code>Requirement</code>、和<code>Policy</code></p>
<pre><code class="language-csharp">public class AuthorizationPolicyBuilder
{
    // ...
    
    public AuthorizationPolicyBuilder AddAuthenticationSchemes(params string[] schemes)
    {
        foreach (var authType in schemes){
            AuthenticationSchemes.Add(authType);
        }
        return this;
    }

    public AuthorizationPolicyBuilder AddRequirements(params IAuthorizationRequirement[] requirements)
    {
        foreach (var req in requirements){
            Requirements.Add(req);
        }
        return this;
    }

    public AuthorizationPolicyBuilder Combine(AuthorizationPolicy policy)
    {
        if (policy == null) { /*  throw  */ }
        AddAuthenticationSchemes(policy.AuthenticationSchemes.ToArray());
        AddRequirements(policy.Requirements.ToArray());
        return this;
    }
    // ...
}
</code></pre>
<h3>AuthorizationPolicy 类自身的三个辅助方法</h3>
<p>此外，在<code>AuthorizationPolicyBuilder</code>的基础上，<code>AuthorizationPolicy</code>还提供了两个静态的<code>Combine()</code>帮助方法，用于组合一组<code>Policy</code>：</p>
<pre><code class="language-csharp">public static AuthorizationPolicy Combine(IEnumerable&lt;AuthorizationPolicy&gt; policies)
{
    if (policies == null){ /* throw */ }
    var builder = new AuthorizationPolicyBuilder();
    foreach (var policy in policies){
        builder.Combine(policy);
    }
    return builder.Build();
}

public static AuthorizationPolicy Combine(params AuthorizationPolicy[] policies)
{
    if (policies == null){ /* throw */ }
    return Combine((IEnumerable&lt;AuthorizationPolicy&gt;)policies);
}
</code></pre>
<p>最后，<code>AuthorizatinoPolicy</code>还提供了一个<code>CombineAsync(policyProvider, authorizeData)</code>方法从<code>PolicyProvider</code>中动态生成<code>Policy</code>：</p>
<pre><code class="language-csharp">public static async Task&lt;AuthorizationPolicy&gt; CombineAsync(IAuthorizationPolicyProvider policyProvider, IEnumerable&lt;IAuthorizeData&gt; authorizeData)
{
    if (policyProvider == null){ /* throw */ }
    if (authorizeData == null) { /* throw */ }

    // Avoid allocating enumerator if the data is known to be empty
    var skipEnumeratingData = false;
    if (authorizeData is IList&lt;IAuthorizeData&gt; dataList)
    {
        skipEnumeratingData = dataList.Count == 0;
    }

    AuthorizationPolicyBuilder policyBuilder = null;
    // ...

    return policyBuilder?.Build();
}
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/CSharp/ASP.NET Core/Security/Authentication/Authentication — (5) 如何自定义认证处理器.html">
                    Authentication — (5) 如何自定义认证处理器
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        CSharp
                      </a>
                    </li>
                    <li>
                      <a href="">
                        ASP.NET Core
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Security
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Authentication
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#ASP.NET Core">
                    <span class="tag is-info">
                      ASP.NET Core
                    </span>
                  </a>
                  <a href="tags.html#Authentication">
                    <span class="tag is-info">
                      Authentication
                    </span>
                  </a>
                  <a href="tags.html#CSharp">
                    <span class="tag is-info">
                      CSharp
                    </span>
                  </a>
                  <a href="tags.html#源码分析">
                    <span class="tag is-info">
                      源码分析
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2019-08-15
                </p>
              </div>
              <div class="content article-body">
                <p>设想有这样一个场景，我们开发了一个<code>SaaS</code>服务，正如微软在暴露<code>Azure</code>的某些服务那样，我们要求开发者提供相应的订阅（<code>SubScriptionKey</code>）才能访问我们的资源。我们约定，开发者需要在<code>HTTP</code>请求中添加如下形式的报头：</p>
<pre><code>Authorization: subscription-key {KEY}
</code></pre>
<p>此外，服务提供商还会定期公布一些供新用户试用的订阅，使用这些试用订阅也能通过认证。</p>
<p>为了巩固前几篇源码分析笔记的相关知识，我们通过自定义一个新的认证处理器来解决这个问题。</p>
<h2>自定义认证处理器</h2>
<p>首先，我们新建一个类来表示与此认证相关的配置项：</p>
<pre><code class="language-csharp">public class SubsKeyAuthNSchemeOptions : AuthenticationSchemeOptions
{
    public string SubscriptionKeyPrefix { get; set; } = &quot;subscription-key&quot;;
    public string TrialKey { get; set; } = &quot;42 is the answer&quot;;
}
</code></pre>
<p>认证处理器需要首先从报头中提取<code>Token</code>（也即订阅的<code>Key</code>）；然后判断当前Key是否为试用的订阅，然后从数据库中检索该Key是否有效；如果有效，则生成认证成功凭证、认证票据，最后返回认证成功结果。</p>
<p>下面给出认证处理器的完整实现：<!-- more --></p>
<pre><code class="language-csharp">public class SubsKeyAuthNHandler : AuthenticationHandler&lt;SubsKeyAuthNSchemeOptions&gt;
{
    public SubsKeyAuthNHandler(IOptionsMonitor&lt;SubsKeyAuthNSchemeOptions&gt; options, ILoggerFactory logger, UrlEncoder encoder, ISystemClock clock)
        : base(options, logger, encoder, clock)
    {
    }
    // 一段虚构的用于校验Key的代码
    private Task&lt;bool&gt; ValidateSubscriptionKeyAsync(string key)
    {
        Func&lt;string,bool&gt; validateKeyAgainstDb = (skey)=&gt; {
            // ... check this subscription key
            return false;
        };
        var result = key == this.Options.TrialKey || validateKeyAgainstDb(key) ;
        return Task.FromResult(result);
    }

    protected override async Task&lt;AuthenticateResult&gt; HandleAuthenticateAsync()
    {
        // 获取Key
        string key = null;
        string authorization = Request.Headers[&quot;Authorization&quot;];
        if (string.IsNullOrEmpty(authorization)) {
            return AuthenticateResult.NoResult();
        }
        if (authorization.StartsWith(this.Options.SubscriptionKeyPrefix, StringComparison.OrdinalIgnoreCase)) {
            key = authorization.Substring(this.Options.SubscriptionKeyPrefix.Length).Trim();
        }
        if (string.IsNullOrEmpty(key)) { return AuthenticateResult.NoResult(); }

        // 校验Key
        var res =await this.ValidateSubscriptionKeyAsync(key);
        if (!res) {
            return AuthenticateResult.Fail($&quot;token {this.Options.SubscriptionKeyPrefix} not match&quot;);
        } else {
            var id=new ClaimsIdentity( 
                new Claim[] { new Claim(&quot;Key&quot;, key) },  // not safe , just as an example , should custom claims on your own
                Scheme.Name 
            );
            ClaimsPrincipal principal=new ClaimsPrincipal( id);
            var ticket = new AuthenticationTicket(principal, new AuthenticationProperties(), Scheme.Name);
            return AuthenticateResult.Success(ticket);
        }
    }

    protected override Task HandleChallengeAsync(AuthenticationProperties properties)
    {
        Response.StatusCode = 401;
        var message = &quot;tell me your token&quot;;
        Response.Body.Write(Encoding.UTF8.GetBytes(message));
        return Task.CompletedTask;
    }

    protected override Task HandleForbiddenAsync(AuthenticationProperties properties)
    {
        Response.StatusCode = 403;
        var message = &quot;you have no rights&quot;;
        Response.Body.Write(Encoding.UTF8.GetBytes(message));
        return Task.CompletedTask;
    }
}
</code></pre>
<p>为了后续可以方便地表述这种认证模式，我们不妨定义两个常量字符串：</p>
<pre><code class="language-csharp">public class SubsKeyAuthNDefaults {
    public const string Scheme = &quot;SubscriptionKeyAuthenticationScheme&quot;;
    public const string DisplayName= &quot;Subscription Key Authentication Scheme&quot;;
}
</code></pre>
<h2>配置认证</h2>
<p>在<code>Startup.cs</code>的配置认证服务，为了让我们的程序稍显复杂一点，我故意把默认的认证模式改成了<code>JwtBearer</code>；另外我还重写了默认的<code>TrialKey</code>:</p>
<pre><code class="language-csharp">services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =&gt; {
        options.TokenValidationParameters = new TokenValidationParameters{ /* ... */ };
        options.ForwardAuthenticate = SubsKeyAuthNDefaults.Scheme;
    })
    .AddScheme&lt;SubsKeyAuthNSchemeOptions, SubsKeyAuthNHandler&gt;(
        SubsKeyAuthNDefaults.Scheme, 
        SubsKeyAuthNDefaults.DisplayName, 
        opts =&gt; {
            opts.TrialKey = &quot;42 is not the answer&quot;;
        }
    );
</code></pre>
<h2>测试</h2>
<p>最后，新建一个<code>API</code>用于测试我们的代码，其中<code>Get</code>方法要求<code>JwtBearer</code>认证，而<code>Post</code>方法需要进行<code>SubsKeyAuthNDefaults.Scheme</code>认证。</p>
<pre><code class="language-csharp">[Route(&quot;api/[controller]&quot;)]
[ApiController]
public class ValuesController : ControllerBase
{

    [Authorize(AuthenticationSchemes =JwtBearerDefaults.AuthenticationScheme)]
    [HttpGet(&quot;{id}&quot;)]
    public ActionResult&lt;string&gt; Get(int id)
    {
        return &quot;value&quot;;
    }

    [Authorize(AuthenticationSchemes = SubsKeyAuthNDefaults.Scheme)]
    [HttpPost]
    public string Post([FromBody] string value)
    {
        return value;
    }
}
</code></pre>
<h4>测试 JwtBearer 转发认证</h4>
<p>我们分别提交错误的Key、默认的Key和自定义的Key进行测试：</p>
<pre><code>### 返回 401
GET https://localhost:5001/api/values/5 HTTP/1.1
Authorization: subscription-key Houston, we have had a problem


### 返回 401
GET https://localhost:5001/api/values/5 HTTP/1.1
Authorization: subscription-key 42 is the answer

### 返回 200
GET https://localhost:5001/api/values/5 HTTP/1.1
Authorization: subscription-key 42 is not the answer
</code></pre>
<h4>测试 SubsKey 认证</h4>
<ol>
<li>测试 POST方法 + SubsKey 认证（提交错误的Key）</li>
</ol>
<pre><code>POST https://localhost:5001/api/values HTTP/1.1
Authorization: subscription-key Houston, we have had a problem
Content-Type: application/json

&quot;Hello, World&quot;
</code></pre>
<p>以上的请求会返回 <code>401</code> + &quot;tell me your token&quot; ：</p>
<pre><code>HTTP/1.1 401 Unauthorized
Connection: close
Server: Kestrel
Transfer-Encoding: chunked

tell me your token
</code></pre>
<ol start="2">
<li>测试 POST方法 + SubsKey 认证 （提交正确的Key）</li>
</ol>
<pre><code>POST https://localhost:5001/api/values HTTP/1.1
Authorization: subscription-key 42 is not the answer
Content-Type: application/json

&quot;It works&quot;
</code></pre>
<p>以上的请求会返回 <code>200</code>  + &quot;It works&quot;:</p>
<pre><code>HTTP/1.1 200 OK
Connection: close
Date: Thu, 15 Aug 2019 03:06:33 GMT
Content-Type: text/plain; charset=utf-8
Server: Kestrel
Transfer-Encoding: chunked

It works
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/CSharp/ASP.NET Core/Security/Authentication/Authentication — (1) 基本概念.html">
                    Authentication — (1) 基本概念
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        CSharp
                      </a>
                    </li>
                    <li>
                      <a href="">
                        ASP.NET Core
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Security
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Authentication
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#ASP.NET Core">
                    <span class="tag is-info">
                      ASP.NET Core
                    </span>
                  </a>
                  <a href="tags.html#CSharp">
                    <span class="tag is-info">
                      CSharp
                    </span>
                  </a>
                  <a href="tags.html#Authentication">
                    <span class="tag is-info">
                      Authentication
                    </span>
                  </a>
                  <a href="tags.html#源码分析">
                    <span class="tag is-info">
                      源码分析
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2019-08-14
                </p>
              </div>
              <div class="content article-body">
                <p>这部分代码在<code>HttpAbstractions</code>项目中定义，定义在<code>Microsoft.AspNetCore.Authentication</code>命名空间下。</p>
<p>本篇笔记分为两大部分：</p>
<ol>
<li>第一部分主要讲述<strong>认证模式</strong>、<strong>认证处理器</strong>及相应的<strong>认证模式Provider</strong>和<strong>认证处理器Provider</strong></li>
<li>第二部分主要对认证过程中涉及的相关类型进行描述，主要包括<strong>认证属性</strong>、<strong>认证票据</strong>、<strong>认证结果</strong></li>
</ol>
<h3>认证模式</h3>
<p>认证模式类<code>AuthenticationScheme</code>非常简单，顾名思义，它代表了某一种特定的认证模式，其中还包含了对应的认证处理器的类型信息：</p>
<pre><code class="language-csharp">public class AuthenticationScheme
{
    public AuthenticationScheme(string name, string displayName, Type handlerType)
    {
        if (name == null) { /* throw */ }
        if (handlerType == null) { /* throw */ }
        if (!typeof(IAuthenticationHandler).IsAssignableFrom(handlerType)) { /* throw */ }

        Name = name;
        HandlerType = handlerType;
        DisplayName = displayName;
    }

    public string Name { get; }
    public string DisplayName { get; }

    public Type HandlerType { get; }
}
</code></pre>
<p>常见的认证模式有 <code>Cookies</code>、<code>Bearer</code>、<code>OAuth</code>、<code>OpenIdConnect</code>、<code>Google</code>、<code>Microsoft</code>、<code>Facebook</code>等。每种 认证模式都有各自的处理器负责处理用户认证事宜。注意，<strong><code>Scheme</code>中存储的并非是<code>Handler</code>实例，而是<code>Handler</code>的类型！</strong> <!-- more --></p>
<h3>认证处理器相关接口</h3>
<p><code>IAuthenticationHandler</code>接口负责针对每个请求进行认证处理，包含了<strong>初始化</strong>、<strong>认证</strong>、<strong>质询</strong>、和<strong>禁止</strong>访问几个功能：</p>
<pre><code class="language-csharp">public interface IAuthenticationHandler
{
    Task InitializeAsync(AuthenticationScheme scheme, HttpContext context); // 初始化
    Task&lt;AuthenticateResult&gt; AuthenticateAsync();                           // 认证
    Task ChallengeAsync(AuthenticationProperties properties);               // 质询
    Task ForbidAsync(AuthenticationProperties properties);                  // 禁止
}
</code></pre>
<p>除了以上几个通用的功能，还有两个特化的认证处理器接口用于<strong>登入</strong>和<strong>登出</strong>：</p>
<pre><code class="language-csharp">public interface IAuthenticationSignOutHandler : IAuthenticationHandler
{
    Task SignOutAsync(AuthenticationProperties properties);
}

public interface IAuthenticationSignInHandler : IAuthenticationSignOutHandler
{
    Task SignInAsync(ClaimsPrincipal user, AuthenticationProperties properties);
}
</code></pre>
<p>最后，还有一个特化的接口<code>IAuthenticationRequestHandler</code> 用于<strong>中间件级别的请求处理</strong>：</p>
<pre><code class="language-csharp">public interface IAuthenticationRequestHandler : IAuthenticationHandler
{
    Task&lt;bool&gt; HandleRequestAsync();
}
</code></pre>
<p>如果一个<code>IAuthenticationHanlder</code>接口对象可以转换为<code>IAuthenticationRequestHandler</code>接口，则说明该 接口对象否想参与中间件级别的请求处理，其<code>HandlerRequestAsync()</code>方法将用于对请求进行处理；当该方法完成后，如果希望系统停止后续中间件的处理，则返回<code>true</code>，否则返回<code>false</code>。</p>
<h3><code>AuthenticationSchemeProvider</code></h3>
<p><code>IAuthenticationSchemeProvider</code>接口用于</p>
<ul>
<li>枚举当前认证模式</li>
<li>增、删某种认证模式</li>
<li>查找某种认证模式</li>
</ul>
<pre><code class="language-csharp">public interface IAuthenticationSchemeProvider
{
    Task&lt;IEnumerable&lt;AuthenticationScheme&gt;&gt; GetAllSchemesAsync();
    Task&lt;AuthenticationScheme&gt; GetSchemeAsync(string name);
   
    Task&lt;AuthenticationScheme&gt; GetDefaultAuthenticateSchemeAsync();
    Task&lt;AuthenticationScheme&gt; GetDefaultChallengeSchemeAsync();
    Task&lt;AuthenticationScheme&gt; GetDefaultForbidSchemeAsync();
    Task&lt;AuthenticationScheme&gt; GetDefaultSignInSchemeAsync();
    Task&lt;AuthenticationScheme&gt; GetDefaultSignOutSchemeAsync();

    void AddScheme(AuthenticationScheme scheme);
    void RemoveScheme(string name);

    Task&lt;IEnumerable&lt;AuthenticationScheme&gt;&gt; GetRequestHandlerSchemesAsync();
}
</code></pre>
<p>其默认实现为<code>AuthenticationSchemeProvider</code>，由于源码较为简单，此处不再赘述。</p>
<h3><code>AuthenticationHandlerProvider</code></h3>
<p><code>IAuthenticationHandlerProvider</code>用于提供与指定模式名相匹配的认证处理器的实例，其接口定义为：</p>
<pre><code class="language-csharp">public interface IAuthenticationHandlerProvider
{
    Task&lt;IAuthenticationHandler&gt; GetHandlerAsync(HttpContext context, string authenticationScheme);
}
</code></pre>
<p>作为<code>IAuthenticationHandlerProvider</code>接口的默认实现，<code>AuthenticationHandlerProvider</code>包含了一个<code>IAuthenticatioSchemProvider</code>属性，获取相应认证模式处理器的类型，然后根据类型信息创建一个实例并存入缓存：</p>
<pre><code class="language-csharp">namespace Microsoft.AspNetCore.Authentication
{
    public class AuthenticationHandlerProvider : IAuthenticationHandlerProvider
    {
        public AuthenticationHandlerProvider(IAuthenticationSchemeProvider schemes)
        {
            Schemes = schemes;
        }

        public IAuthenticationSchemeProvider Schemes { get; }
        // 创建一个字典作为缓存
        private Dictionary&lt;string, IAuthenticationHandler&gt; _handlerMap = new Dictionary&lt;string, IAuthenticationHandler&gt;(StringComparer.Ordinal);

        public async Task&lt;IAuthenticationHandler&gt; GetHandlerAsync(HttpContext context, string authenticationScheme){
            // 优先从缓存中查询
            if (_handlerMap.ContainsKey(authenticationScheme)){ return _handlerMap[authenticationScheme]; }

            var scheme = await Schemes.GetSchemeAsync(authenticationScheme);
            if (scheme == null){ return null; }
            
            // 创建实例、初始化、存入缓存
            var handler = (context.RequestServices.GetService(scheme.HandlerType) ??
                ActivatorUtilities.CreateInstance(context.RequestServices, scheme.HandlerType))
                as IAuthenticationHandler;
            if (handler != null){
                await handler.InitializeAsync(scheme, context);
                _handlerMap[authenticationScheme] = handler;
            }
            return handler;
        }
    }
}
</code></pre>
<h3>认证属性、认证票据和认证结果</h3>
<h4><code>AuthenticationProperties</code></h4>
<p>认证属性是一个简单的类似于字典一样的对象，用于存取关于认证会话的各项属性。其中，最核心的是两个字典属性：</p>
<ul>
<li><code>Items</code> ： <code>Dictionary&lt;string,string&gt;</code>型字典</li>
<li><code>Parameters</code>：<code>Dictionary&lt;string,object&gt;</code>型字典，用于在handler之间共享对象，不可序列化或者持久化</li>
</ul>
<pre><code class="language-csharp">public class AuthenticationProperties
{
    // ...

    public IDictionary&lt;string, string&gt; Items { get; }

    public IDictionary&lt;string, object&gt; Parameters { get; }
}
</code></pre>
<p>为了方便起见，<code>AuthenticationProperties</code>针对<code>Parameters</code>字典和<code>Items</code>提供了如下的取、存方法</p>
<pre><code class="language-csharp">public class AuthenticationProperties
{
    // ...
    
    public T GetParameter&lt;T&gt;(string key) =&gt; Parameters.TryGetValue(key, out var obj) &amp;&amp; obj is T value ? value : default;

    public void SetParameter&lt;T&gt;(string key, T value) =&gt; Parameters[key] = value;
        
    public string GetString(string key)
    {
        return Items.TryGetValue(key, out string value) ? value : null;
    }

    public void SetString(string key, string value)
    {
        if (value != null) {
            Items[key] = value;
        } else if (Items.ContainsKey(key)) {
            Items.Remove(key);
        }
    }
}       
</code></pre>
<p>而<code>Items</code>虽然只能存储<code>string</code>型值，但是配合<code>ToString()</code>和从字符串解析的功能，还可以对<code>bool</code>、<code>DateTime</code>型数据类型进行存取：</p>
<pre><code class="language-csharp">public class AuthenticationProperties
{
    // ...
    
    protected bool? GetBool(string key) { /* ...*/ }

    protected void SetBool(string key, bool? value) { /* ...*/ }
    
    protected DateTimeOffset? GetDateTimeOffset(string key) { /* ...*/ }

    protected void SetDateTimeOffset(string key, DateTimeOffset? value) { /* ...*/ }
}
</code></pre>
<p>在此基础之上，对一些常用属性及值提供了便利方法：</p>
<pre><code class="language-csharp">{
    internal const string IssuedUtcKey = &quot;.issued&quot;;
    internal const string ExpiresUtcKey = &quot;.expires&quot;;
    internal const string IsPersistentKey = &quot;.persistent&quot;;
    internal const string RedirectUriKey = &quot;.redirect&quot;;
    internal const string RefreshKey = &quot;.refresh&quot;;
    internal const string UtcDateTimeFormat = &quot;r&quot;;

    public bool IsPersistent
    {
        get =&gt; GetString(IsPersistentKey) != null;
        set =&gt; SetString(IsPersistentKey, value ? string.Empty : null);
    }

    /// &lt;summary&gt;
    /// Gets or sets the full path or absolute URI to be used as an http redirect response value.
    /// &lt;/summary&gt;
    public string RedirectUri
    {
        get =&gt; GetString(RedirectUriKey);
        set =&gt; SetString(RedirectUriKey, value);
    }

    /// &lt;summary&gt;
    /// Gets or sets the time at which the authentication ticket was issued.
    /// &lt;/summary&gt;
    public DateTimeOffset? IssuedUtc
    {
        get =&gt; GetDateTimeOffset(IssuedUtcKey);
        set =&gt; SetDateTimeOffset(IssuedUtcKey, value);
    }

    /// &lt;summary&gt;
    /// Gets or sets the time at which the authentication ticket expires.
    /// &lt;/summary&gt;
    public DateTimeOffset? ExpiresUtc
    {
        get =&gt; GetDateTimeOffset(ExpiresUtcKey);
        set =&gt; SetDateTimeOffset(ExpiresUtcKey, value);
    }

    /// &lt;summary&gt;
    /// Gets or sets if refreshing the authentication session should be allowed.
    /// &lt;/summary&gt;
    public bool? AllowRefresh
    {
        get =&gt; GetBool(RefreshKey);
        set =&gt; SetBool(RefreshKey, value);
    }
}
</code></pre>
<h4><code>AuthenticationTicket</code></h4>
<p>认证票据封装了用户身份信息和一些配套的认证属性，如过期信息、是否允许刷新等。</p>
<pre><code class="language-csharp">public class AuthenticationTicket
{

    public AuthenticationTicket(ClaimsPrincipal principal, AuthenticationProperties properties, string authenticationScheme)
    {
        if (principal == null) { /* throw */ }

        AuthenticationScheme = authenticationScheme;
        Principal = principal;
        Properties = properties ?? new AuthenticationProperties();
    }

    public AuthenticationTicket(ClaimsPrincipal principal, string authenticationScheme) 
        : this(principal, properties: null, authenticationScheme: authenticationScheme)
    { }


    public string AuthenticationScheme { get; private set; }

    public ClaimsPrincipal Principal { get; private set; }

    public AuthenticationProperties Properties { get; private set; }
}
</code></pre>
<h4><code>AuthenticationResult</code></h4>
<p>认证结果有三种，分别是：</p>
<ul>
<li>没有结果：暂时无法确定最终认证结果，留待其他认证处理程序处理。</li>
<li>认证成功：需要提供认证票据</li>
<li>认证失败：需要指定失败消息</li>
</ul>
<p><code>AuthenticationResult</code>提供了一个类来封装了以上所有信息：</p>
<pre><code class="language-csharp">public class AuthenticateResult
{
    public AuthenticationTicket Ticket { get; protected set; }    // 认证成功时的票据

    public ClaimsPrincipal Principal =&gt; Ticket?.Principal;        // 认证成功时票据中的主体

    public AuthenticationProperties Properties { get; protected set; } // 认证属性

    public Exception Failure { get; protected set; }               // 认证失败时的失败异常

    public bool None { get; protected set; }                       // 认证是否没有结果
     
    public bool Succeeded =&gt; Ticket != null;                       // 认证是否已经成功
}
</code></pre>
<p><code>AuthenticationResult</code>还提供了三类静态方法来创建认证结果</p>
<pre><code class="language-csharp">public class AuthenticateResult
{
    // ...
    
    
    public static AuthenticateResult NoResult()
    {
        return new AuthenticateResult() { None = true };
    }
    
    public static AuthenticateResult Success(AuthenticationTicket ticket)
    {
        if (ticket == null)
        {
            throw new ArgumentNullException(nameof(ticket));
        }
        return new AuthenticateResult() { Ticket = ticket, Properties = ticket.Properties };
    }

    public static AuthenticateResult Fail(Exception failure)
    {
        return new AuthenticateResult() { Failure = failure };
    }

    public static AuthenticateResult Fail(Exception failure, AuthenticationProperties properties)
    {
        return new AuthenticateResult() { Failure = failure, Properties = properties };
    }

    public static AuthenticateResult Fail(string failureMessage)
        =&gt; Fail(new Exception(failureMessage));

    public static AuthenticateResult Fail(string failureMessage, AuthenticationProperties properties)
        =&gt; Fail(new Exception(failureMessage), properties);
}
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/CSharp/ASP.NET Core/Security/Authentication/Authentication — (3.2) 认证处理器的实现之JwtBearerHandler.html">
                    Authentication — (3.2) 认证处理器的实现之JwtBearerHandler
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        CSharp
                      </a>
                    </li>
                    <li>
                      <a href="">
                        ASP.NET Core
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Security
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Authentication
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#ASP.NET Core">
                    <span class="tag is-info">
                      ASP.NET Core
                    </span>
                  </a>
                  <a href="tags.html#CSharp">
                    <span class="tag is-info">
                      CSharp
                    </span>
                  </a>
                  <a href="tags.html#Authentication">
                    <span class="tag is-info">
                      Authentication
                    </span>
                  </a>
                  <a href="tags.html#源码分析">
                    <span class="tag is-info">
                      源码分析
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2019-08-14
                </p>
              </div>
              <div class="content article-body">
                <p>仅就认证处理器的工作机理而言，<code>JwtBearer</code>认证模式是最为简单的一种认证。所以，我们选择<code>JwtBearer</code>认证处理器作为本系列源码分析中关于认证处理器第一个具体实现的来讲述。</p>
<p><code>HandleAuthenticateAsync()</code>的基本逻辑是:</p>
<ol>
<li>触发接收到消息事件，事件处理程序通常可以设置新的<code>token</code>——这在使用<code>WebSocket</code>/<code>SignalR</code>认证中尤其有用，因为难以传递<code>Authorization: Bearer {token}</code>报头。事件处理程序甚至可以直接设置<code>messageReceivedContext.Result</code>来截断后续处理。</li>
<li>如果消息处理事件没有设置<code>Token</code>，则从<code>Authorization: Bearer {jwt-token}</code> 中获取</li>
<li>获取令牌校验参数</li>
<li>校验令牌，给出认证成功/失败结果</li>
</ol>
<p>由于这部分相对简单，这里直接贴出相关源码（具体过程参见我的注释）：<!-- more --></p>
<pre><code class="language-csharp">    protected override async Task&lt;AuthenticateResult&gt; HandleAuthenticateAsync()
    {
        string token = null;
        try
        {
            // 触发收到消息事件
            var messageReceivedContext = new MessageReceivedContext(Context, Scheme, Options);
            await Events.MessageReceived(messageReceivedContext);
            if (messageReceivedContext.Result != null)
            {
                return messageReceivedContext.Result;
            }
            token = messageReceivedContext.Token;


            // 如果消息事件没有为我们设置Token，则去Header中搜寻
            if (string.IsNullOrEmpty(token))
            {
                string authorization = Request.Headers[&quot;Authorization&quot;];
                if (string.IsNullOrEmpty(authorization)) { return AuthenticateResult.NoResult(); }
                if (authorization.StartsWith(&quot;Bearer &quot;, StringComparison.OrdinalIgnoreCase)) { token = authorization.Substring(&quot;Bearer &quot;.Length).Trim(); }
                if (string.IsNullOrEmpty(token)) { return AuthenticateResult.NoResult(); }
            }

            // 获取校相关验参数
            if (_configuration == null &amp;&amp; Options.ConfigurationManager != null)
            {
                _configuration = await Options.ConfigurationManager.GetConfigurationAsync(Context.RequestAborted);
            }
            var validationParameters = Options.TokenValidationParameters.Clone();
            if (_configuration != null)
            {
                var issuers = new[] { _configuration.Issuer };
                validationParameters.ValidIssuers = validationParameters.ValidIssuers?.Concat(issuers) ?? issuers;

                validationParameters.IssuerSigningKeys = validationParameters.IssuerSigningKeys?.Concat(_configuration.SigningKeys)
                    ?? _configuration.SigningKeys;
            }


            // 校验Token
            List&lt;Exception&gt; validationFailures = null;
            SecurityToken validatedToken;
            foreach (var validator in Options.SecurityTokenValidators)
            {
                if (validator.CanReadToken(token))
                {
                    ClaimsPrincipal principal;
                    try
                    {
                        principal = validator.ValidateToken(token, validationParameters, out validatedToken);
                    }
                    catch (Exception ex)
                    {
                        Logger.TokenValidationFailed(ex);

                        // Refresh the configuration for exceptions that may be caused by key rollovers. The user can also request a refresh in the event.
                        if (Options.RefreshOnIssuerKeyNotFound &amp;&amp; Options.ConfigurationManager != null
                            &amp;&amp; ex is SecurityTokenSignatureKeyNotFoundException)
                        {
                            Options.ConfigurationManager.RequestRefresh();
                        }

                        if (validationFailures == null)
                        {
                            validationFailures = new List&lt;Exception&gt;(1);
                        }
                        validationFailures.Add(ex);
                        continue;
                    }

                    Logger.TokenValidationSucceeded();

                    var tokenValidatedContext = new TokenValidatedContext(Context, Scheme, Options)
                    {
                        Principal = principal,
                        SecurityToken = validatedToken
                    };

                    await Events.TokenValidated(tokenValidatedContext);
                    if (tokenValidatedContext.Result != null)
                    {
                        return tokenValidatedContext.Result;
                    }

                    if (Options.SaveToken)
                    {
                        tokenValidatedContext.Properties.StoreTokens(new[]
                        {
                            new AuthenticationToken { Name = &quot;access_token&quot;, Value = token }
                        });
                    }

                    tokenValidatedContext.Success();
                    return tokenValidatedContext.Result;
                }
            }

            if (validationFailures != null)
            {
                var authenticationFailedContext = new AuthenticationFailedContext(Context, Scheme, Options)
                {
                    Exception = (validationFailures.Count == 1) ? validationFailures[0] : new AggregateException(validationFailures)
                };

                await Events.AuthenticationFailed(authenticationFailedContext);
                if (authenticationFailedContext.Result != null)
                {
                    return authenticationFailedContext.Result;
                }

                return AuthenticateResult.Fail(authenticationFailedContext.Exception);
            }

            return AuthenticateResult.Fail(&quot;No SecurityTokenValidator available for token: &quot; + token ?? &quot;[null]&quot;);
        }
        catch (Exception ex)
        {
            Logger.ErrorProcessingMessage(ex);

            var authenticationFailedContext = new AuthenticationFailedContext(Context, Scheme, Options)
            {
                Exception = ex
            };

            await Events.AuthenticationFailed(authenticationFailedContext);
            if (authenticationFailedContext.Result != null)
            {
                return authenticationFailedContext.Result;
            }

            throw;
        }
    }
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/CSharp/ASP.NET Core/Security/Authentication/Authentication — (0) 从Authentication中间件说起.html">
                    Authentication — (0) 从Authentication中间件说起
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        CSharp
                      </a>
                    </li>
                    <li>
                      <a href="">
                        ASP.NET Core
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Security
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Authentication
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="tags.html#ASP.NET Core">
                    <span class="tag is-info">
                      ASP.NET Core
                    </span>
                  </a>
                  <a href="tags.html#Authentication">
                    <span class="tag is-info">
                      Authentication
                    </span>
                  </a>
                  <a href="tags.html#CSharp">
                    <span class="tag is-info">
                      CSharp
                    </span>
                  </a>
                  <a href="tags.html#源码分析">
                    <span class="tag is-info">
                      源码分析
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2019-08-14
                </p>
              </div>
              <div class="content article-body">
                <p><code>ASP.NET Core</code>认证相关的代码比较分散，主要涉及三个项目仓库：</p>
<ol>
<li><a href="https://github.com/aspnet/AspNetCore/tree/master/src/Http/Http.Abstractions">HTTP Abstractions</a>项目，即以前的<a href="https://github.com/aspnet/HttpAbstractions">aspnet/HttpAbstractions</a>仓库。在这个仓库中，包含了一些与认证相关的高层接口和与框架安全相关的核心概念。</li>
<li><a href="https://github.com/aspnet/AspNetCore/tree/master/src/Security">Security</a>项目，即之前的<a href="https://github.com/aspnet/Security">aspnet/Security</a>仓库。这个仓库中定义了与认证相关的一些基本实现，并内置了一些常见的认证模式、认证处理器。</li>
<li><a href="https://github.com/aspnet/AspNetCore/tree/master/src/Identity">Identity</a>项目，即之前的<a href="https://github.com/aspnet/Identity">aspnet/Identity</a>。这个仓库是<code>ASP.NET Core Identity</code>框架的实现。本系列的笔记不会对其做过多的源码分析，这里只作为一种认证模式介绍。</li>
</ol>
<p>去年8月份，我在阅读<code>ASP.NET Core</code>认证相关的源码后，陆陆续续在有道云笔记中记录了8篇笔记(系列)：</p>
<ol start="0">
<li>Authentication — (0) 从Authentication中间件说起</li>
<li>Authentication — (1) 基本概念.md</li>
<li>Authentication — (2) 认证服务及其对HttpContext的认证扩展方法</li>
<li>Authentication — (3.1) 认证处理器的实现之AuthenticationHandler抽象基类</li>
<li>Authentication — (3.2) 认证处理器的实现之JwtBearerHandler</li>
<li>Authentication — (3.3) 认证处理器的实现之RemoteAuthenticationHandler</li>
<li>Authentication — (4) Authentication服务的配置与构建</li>
<li>Authentication — (5) 如何自定义认证处理器</li>
</ol>
<p>（一点题外话：<em>最近这大半年，我几乎都只在有道云上记录笔记(PC端+App+网页版)。不过最近我在修改笔记的过程中发现，有道云笔记网页版经常会发生笔记相互覆盖的情况。最恼火的是，一旦修改了标题，连历史记录也一并丢失了！这种情况已经出现我身上数次了。基于此，我以后记笔记的策略是：有道云做初稿，随时记录想法；整理完成后提交公众号发布，由于公众号有良好的CDN网络，供平时阅读和温习；最后使用个人网站作为终极备份</em>）</p>
<p>随着<code>ASP.NET Core</code>的发展，之前的三个仓库在去年已经被存档，目前新的项目都位于<code>ASP.NET Core</code>中心仓库下。为了表述方便，这个系列的源码分析文章对老仓库和新项目位置不做过多区分。</p>
<p>中间件<code>AuthenticationMiddleware</code>是理解<code>ASP.NET Core</code>认证的入口，尽管搞懂这块需要很多基本知识，作为总纲式的知识，我还是选择把它作为第一篇讲述。<!-- more -->
随后的两篇笔记分别讲述了一些与认证相关的基础类与接口，以及在其基础之上形成的认证服务类。这两篇笔记只是讲述各个类在认证过程中扮演的角色，内容枯燥乏味，犹如流水账一般。但是这块知识是阅读后续第三部分实现的基本前提。
这个系列笔记的第三部分主要讲述各种认证处理器的实现。这部分是与认证相关的源码分析的核心。
第四部分则记录<code>Authentication</code>服务配置与构建的背后原理。
作为收尾，最后一篇笔记以如何自定义一个认证处理器结束这个系列的源码分析。</p>
<p>我会在下一篇笔记讲述认证处理器的基本概念，并在后续的数篇笔记中解释认证处理器是如何工作的。这篇源码笔记的目的是分析<strong>认证过程是如何和一个HTTP请求联系起来的</strong>。</p>
<h2>认证中间件</h2>
<p>要想得到正确的<code>Context.User</code>，必须先注册相关认证服务，然后在合适的位置启用认证中间件：</p>
<pre><code>app.UseAuthentication();  // 必须启用于相关中间件之前
// ...
app.UseMvc(routes =&gt;{
    ...
});
</code></pre>
<p>对于每一个请求, <code>AuthenticationMiddleware</code>中间件都会尝试对当前用户进行认证，这里的认证工作主要通过认证处理器（<code>AuthenticationHandler</code>)来进行。</p>
<p>中间件<a href="https://github.com/aspnet/Security/blob/26d27d871b7992022c082dc207e3d126e1d9d278/src/Microsoft.AspNetCore.Authentication/AuthenticationMiddleware.cs#L11-L63"><code>AuthenticationMiddleware</code></a> 的核心源码为：</p>
<pre><code class="language-csharp">public async Task Invoke(HttpContext context)
{
    context.Features.Set&lt;IAuthenticationFeature&gt;(new AuthenticationFeature
    {
        OriginalPath = context.Request.Path,
        OriginalPathBase = context.Request.PathBase
    });

    // Give any IAuthenticationRequestHandler schemes a chance to handle the request
    var handlers = context.RequestServices.GetRequiredService&lt;IAuthenticationHandlerProvider&gt;();
    foreach (var scheme in await Schemes.GetRequestHandlerSchemesAsync())
    {
        var handler = await handlers.GetHandlerAsync(context, scheme.Name) as IAuthenticationRequestHandler;
        if (handler != null &amp;&amp; await handler.HandleRequestAsync())
        {
            return;
        }
    }

    var defaultAuthenticate = await Schemes.GetDefaultAuthenticateSchemeAsync();
    if (defaultAuthenticate != null)
    {
        var result = await context.AuthenticateAsync(defaultAuthenticate.Name);
        if (result?.Principal != null)
        {
            context.User = result.Principal;
        }
    }

    await _next(context);
}
</code></pre>
<p>这段中间件源码的基本逻辑非常简单：首先遍历所有中间件级别的认证模式，并逐一尝试把相应的认证处理器转换成<code>IAuthenticationRequestHandler</code>接口，然后调用其<code>HandleRequestAsync()</code>方法(如果返回<code>true</code>，则表示当前需要中断后续所有中间件的请求处理)。如果之前的中间件级别的处理并未截断后续处理，则尝试使用默认的认证模式对用户进行认证。</p>
<p>所谓中间件级别的认证，是指可以中断后续请求处理过程的认证。比如对于一些<code>OAuth2.0</code>的认证模式，需要根据当前是否是远程授权成功后的回调请求来中断后续的中间件处理。这些细节都会在后续几篇源码分析笔记中详细阐述，下一篇主要介绍与认证处理器相关的几个基础类。</p>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <div class="container">
      <div class="container has-text-centered">
        <a href="posts/page2.html">
          Previous
        </a>
        4 of 32
        <a href="posts/page4.html">
          Next
        </a>
      </div>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
       // 处理形如 <code>$E=mc^2$</code> 形式的公式
 var inlineMathNodes=document.querySelectorAll('code');
 var re=/^\$(.*)\$$/;
 for(var j=0;j<inlineMathNodes.length;j++){
   var result=re.exec(inlineMathNodes.item(j).innerText);
   if(result!==null){
	 katex.render(result[1], inlineMathNodes.item(j));
   }
 }
 function removeNode(node){
   if(node.remove){
	 node.remove();
   }else{
	 return first.parentNode.removeChild(node);
   }
 };

 // 查找所有 pre code.language-math 节点 以备筛出数据公式
 var nodes=document.querySelectorAll("pre code.language-math");
 for(var i=0;i<nodes.length;i++){
   var node=nodes.item(i);
   // 魔术标记所在行 
   try{
	 var lines = node.innerText.split('\n');
	 if((!!lines) && lines.length > 0)
	 {
	   var first = lines[0];
	   if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
		 var views = "";
		 // 逐行渲染
		 for(var k=1; k <lines.length; k++){
			 var f=lines[k];
			 views += katex.renderToString(f);
		 }
		 // 消除父级嵌套 
		 try{
		   node.innerHTML=views;
		 }catch(e){
		   // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
		   console.log('IE9 sucks',e);
		   $(tr).html(node.innerHTML);
		 }
	   }
	 }
   }
   catch(err){
	 console.log(err)
   }
 }
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>