<!DOCTYPE html><html>
  <head>
    <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie/"/>
    <script>
      document.addEventListener('DOMContentLoaded', () => {

	// Get all "navbar-burger" elements
	const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);
  
	// Check if there are any navbar burgers
	if ($navbarBurgers.length > 0) {
  
	  // Add a click event on each of them
	  $navbarBurgers.forEach( el => {
		el.addEventListener('click', () => {
  
		  // Get the target from the "data-target" attribute
		  const target = el.dataset.target;
		  const $target = document.getElementById(target);
  
		  // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
		  el.classList.toggle('is-active');
		  $target.classList.toggle('is-active');
  
		});
	  });
	}
  });
    </script>
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item is-active" href="">
            Home
          </a>
          <a class="navbar-item" href="tags.html">
            Tags
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/CSharp/ASP.NET Core/Security/Authentication/Authentication — (5) 如何自定义认证处理器.html">
                    Authentication — (5) 如何自定义认证处理器
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        CSharp
                      </a>
                    </li>
                    <li>
                      <a href="">
                        ASP.NET Core
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Security
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Authentication
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="/tags.html#ASP.NET Core">
                    <span class="tag is-info">
                      ASP.NET Core
                    </span>
                  </a>
                  <a href="/tags.html#Authentication">
                    <span class="tag is-info">
                      Authentication
                    </span>
                  </a>
                  <a href="/tags.html#CSharp">
                    <span class="tag is-info">
                      CSharp
                    </span>
                  </a>
                  <a href="/tags.html#源码分析">
                    <span class="tag is-info">
                      源码分析
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2019-08-15
                </p>
              </div>
              <div class="content article-body">
                <p>设想有这样一个场景，我们开发了一个<code>SaaS</code>服务，正如微软在暴露<code>Azure</code>的某些服务那样，我们要求开发者提供相应的订阅（<code>SubScriptionKey</code>）才能访问我们的资源。我们约定，开发者需要在<code>HTTP</code>请求中添加如下形式的报头：</p>
<pre><code>Authorization: subscription-key {KEY}
</code></pre>
<p>此外，服务提供商还会定期公布一些供新用户试用的订阅，使用这些试用订阅也能通过认证。</p>
<p>为了巩固前几篇源码分析笔记的相关知识，我们通过自定义一个新的认证处理器来解决这个问题。</p>
<h2>自定义认证处理器</h2>
<p>首先，我们新建一个类来表示与此认证相关的配置项：</p>
<pre><code class="language-csharp">public class SubsKeyAuthNSchemeOptions : AuthenticationSchemeOptions
{
    public string SubscriptionKeyPrefix { get; set; } = &quot;subscription-key&quot;;
    public string TrialKey { get; set; } = &quot;42 is the answer&quot;;
}
</code></pre>
<p>认证处理器需要首先从报头中提取<code>Token</code>（也即订阅的<code>Key</code>）；然后判断当前Key是否为试用的订阅，然后从数据库中检索该Key是否有效；如果有效，则生成认证成功凭证、认证票据，最后返回认证成功结果。</p>
<p>下面给出认证处理器的完整实现：<!-- more --></p>
<pre><code class="language-csharp">public class SubsKeyAuthNHandler : AuthenticationHandler&lt;SubsKeyAuthNSchemeOptions&gt;
{
    public SubsKeyAuthNHandler(IOptionsMonitor&lt;SubsKeyAuthNSchemeOptions&gt; options, ILoggerFactory logger, UrlEncoder encoder, ISystemClock clock)
        : base(options, logger, encoder, clock)
    {
    }
    // 一段虚构的用于校验Key的代码
    private Task&lt;bool&gt; ValidateSubscriptionKeyAsync(string key)
    {
        Func&lt;string,bool&gt; validateKeyAgainstDb = (skey)=&gt; {
            // ... check this subscription key
            return false;
        };
        var result = key == this.Options.TrialKey || validateKeyAgainstDb(key) ;
        return Task.FromResult(result);
    }

    protected override async Task&lt;AuthenticateResult&gt; HandleAuthenticateAsync()
    {
        // 获取Key
        string key = null;
        string authorization = Request.Headers[&quot;Authorization&quot;];
        if (string.IsNullOrEmpty(authorization)) {
            return AuthenticateResult.NoResult();
        }
        if (authorization.StartsWith(this.Options.SubscriptionKeyPrefix, StringComparison.OrdinalIgnoreCase)) {
            key = authorization.Substring(this.Options.SubscriptionKeyPrefix.Length).Trim();
        }
        if (string.IsNullOrEmpty(key)) { return AuthenticateResult.NoResult(); }

        // 校验Key
        var res =await this.ValidateSubscriptionKeyAsync(key);
        if (!res) {
            return AuthenticateResult.Fail($&quot;token {this.Options.SubscriptionKeyPrefix} not match&quot;);
        } else {
            var id=new ClaimsIdentity( 
                new Claim[] { new Claim(&quot;Key&quot;, key) },  // not safe , just as an example , should custom claims on your own
                Scheme.Name 
            );
            ClaimsPrincipal principal=new ClaimsPrincipal( id);
            var ticket = new AuthenticationTicket(principal, new AuthenticationProperties(), Scheme.Name);
            return AuthenticateResult.Success(ticket);
        }
    }

    protected override Task HandleChallengeAsync(AuthenticationProperties properties)
    {
        Response.StatusCode = 401;
        var message = &quot;tell me your token&quot;;
        Response.Body.Write(Encoding.UTF8.GetBytes(message));
        return Task.CompletedTask;
    }

    protected override Task HandleForbiddenAsync(AuthenticationProperties properties)
    {
        Response.StatusCode = 403;
        var message = &quot;you have no rights&quot;;
        Response.Body.Write(Encoding.UTF8.GetBytes(message));
        return Task.CompletedTask;
    }
}
</code></pre>
<p>为了后续可以方便地表述这种认证模式，我们不妨定义两个常量字符串：</p>
<pre><code class="language-csharp">public class SubsKeyAuthNDefaults {
    public const string Scheme = &quot;SubscriptionKeyAuthenticationScheme&quot;;
    public const string DisplayName= &quot;Subscription Key Authentication Scheme&quot;;
}
</code></pre>
<h2>配置认证</h2>
<p>在<code>Startup.cs</code>的配置认证服务，为了让我们的程序稍显复杂一点，我故意把默认的认证模式改成了<code>JwtBearer</code>；另外我还重写了默认的<code>TrialKey</code>:</p>
<pre><code class="language-csharp">services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =&gt; {
        options.TokenValidationParameters = new TokenValidationParameters{ /* ... */ };
        options.ForwardAuthenticate = SubsKeyAuthNDefaults.Scheme;
    })
    .AddScheme&lt;SubsKeyAuthNSchemeOptions, SubsKeyAuthNHandler&gt;(
        SubsKeyAuthNDefaults.Scheme, 
        SubsKeyAuthNDefaults.DisplayName, 
        opts =&gt; {
            opts.TrialKey = &quot;42 is not the answer&quot;;
        }
    );
</code></pre>
<h2>测试</h2>
<p>最后，新建一个<code>API</code>用于测试我们的代码，其中<code>Get</code>方法要求<code>JwtBearer</code>认证，而<code>Post</code>方法需要进行<code>SubsKeyAuthNDefaults.Scheme</code>认证。</p>
<pre><code class="language-csharp">[Route(&quot;api/[controller]&quot;)]
[ApiController]
public class ValuesController : ControllerBase
{

    [Authorize(AuthenticationSchemes =JwtBearerDefaults.AuthenticationScheme)]
    [HttpGet(&quot;{id}&quot;)]
    public ActionResult&lt;string&gt; Get(int id)
    {
        return &quot;value&quot;;
    }

    [Authorize(AuthenticationSchemes = SubsKeyAuthNDefaults.Scheme)]
    [HttpPost]
    public string Post([FromBody] string value)
    {
        return value;
    }
}
</code></pre>
<h4>测试 JwtBearer 转发认证</h4>
<p>我们分别提交错误的Key、默认的Key和自定义的Key进行测试：</p>
<pre><code>### 返回 401
GET https://localhost:5001/api/values/5 HTTP/1.1
Authorization: subscription-key Houston, we have had a problem


### 返回 401
GET https://localhost:5001/api/values/5 HTTP/1.1
Authorization: subscription-key 42 is the answer

### 返回 200
GET https://localhost:5001/api/values/5 HTTP/1.1
Authorization: subscription-key 42 is not the answer
</code></pre>
<h4>测试 SubsKey 认证</h4>
<ol>
<li>测试 POST方法 + SubsKey 认证（提交错误的Key）</li>
</ol>
<pre><code>POST https://localhost:5001/api/values HTTP/1.1
Authorization: subscription-key Houston, we have had a problem
Content-Type: application/json

&quot;Hello, World&quot;
</code></pre>
<p>以上的请求会返回 <code>401</code> + &quot;tell me your token&quot; ：</p>
<pre><code>HTTP/1.1 401 Unauthorized
Connection: close
Server: Kestrel
Transfer-Encoding: chunked

tell me your token
</code></pre>
<ol start="2">
<li>测试 POST方法 + SubsKey 认证 （提交正确的Key）</li>
</ol>
<pre><code>POST https://localhost:5001/api/values HTTP/1.1
Authorization: subscription-key 42 is not the answer
Content-Type: application/json

&quot;It works&quot;
</code></pre>
<p>以上的请求会返回 <code>200</code>  + &quot;It works&quot;:</p>
<pre><code>HTTP/1.1 200 OK
Connection: close
Date: Thu, 15 Aug 2019 03:06:33 GMT
Content-Type: text/plain; charset=utf-8
Server: Kestrel
Transfer-Encoding: chunked

It works
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/CSharp/ASP.NET Core/Security/Authentication/Authentication — (4) Authentication服务的配置与构建.html">
                    Authentication — (4) Authentication服务的配置与构建
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        CSharp
                      </a>
                    </li>
                    <li>
                      <a href="">
                        ASP.NET Core
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Security
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Authentication
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="/tags.html#ASP.NET Core">
                    <span class="tag is-info">
                      ASP.NET Core
                    </span>
                  </a>
                  <a href="/tags.html#Authentication">
                    <span class="tag is-info">
                      Authentication
                    </span>
                  </a>
                  <a href="/tags.html#CSharp">
                    <span class="tag is-info">
                      CSharp
                    </span>
                  </a>
                  <a href="/tags.html#源码分析">
                    <span class="tag is-info">
                      源码分析
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2019-08-14
                </p>
              </div>
              <div class="content article-body">
                <h2>世界观</h2>
<p><code>ASP.NET Core</code>可以配置多种认证，让各个认证模式协同工作。这种配置主要体现在两个方面:</p>
<ol>
<li>需要对<code>DI</code>容器中的 <strong><code>AuthenticationOptions</code></strong> 进行设置: 其中包含了每一种认证模式对应的<code>&lt;scheme&gt;-&lt;handlerType&gt;</code>的映射关系、以及默认的相关scheme名等信息。</li>
<li>需要把各个<code>scheme</code>对应的 <strong><code>handler</code>类</strong> <strong>作为服务</strong>注册 到<code>DI</code>容器中。</li>
</ol>
<h3><code>AuthenticationBuilder</code></h3>
<p>事实上，<code>ASP.NET Core</code>暴露了一个<code>AuthenticationBuilder</code>来帮助开发者对认证进行设置。由于认证除了简单地<code>new</code>一个<code>AuthenticationBuilder</code>实例之外，还需要注册一些其他服务（比如编码解码功能等），<code>ASP.NET Core</code>为<code>IServiceCollection</code>提供了一个<code>AddAuthentication()</code>扩展方法，封装了上述过程，调用后返回一个<code>AuthenticationBuilder</code>实例：</p>
<pre><code class="language-csharp">public static AuthenticationBuilder AddAuthentication(this IServiceCollection services)
{
    if (services == null)
    {
        throw new ArgumentNullException(nameof(services));
    }

    services.AddAuthenticationCore();
    services.AddDataProtection();
    services.AddWebEncoders();
    services.TryAddSingleton&lt;ISystemClock, SystemClock&gt;();
    return new AuthenticationBuilder(services);
}
</code></pre>
<p>除了<code>.AddAuthentication()</code>这种核心方式，还有两种重载形式：<!-- more --></p>
<pre><code class="language-csharp">public static AuthenticationBuilder AddAuthentication(this IServiceCollection services, Action&lt;AuthenticationOptions&gt; configureOptions) {
    if (services == null) { throw ...; }
    if (configureOptions == null){ throw ...; }

    var builder = services.AddAuthentication();
    services.Configure(configureOptions);
    return builder;
}

public static AuthenticationBuilder AddAuthentication(this IServiceCollection services, string defaultScheme)
    =&gt; services.AddAuthentication(o =&gt; o.DefaultScheme = defaultScheme);
</code></pre>
<p>可以看到，这两种重载只是在<code>.AddAuthentication()</code>这个方法基础之上再添加一点配置功能，仅此而已。最终<code>.AddAuthentication()</code>都返回一个<code>AuthenticationBuilder</code>实例，用于后续的链式配置。</p>
<h4><code>AuthenticationBuilder</code>的核心方法</h4>
<p><code>AuthenticationBuilder</code>是用于配置认证服务的一个类，该类暴露一个核心方法 <strong><code>AddScheme&lt;TOptions, THandler&gt;(schemeName, displayName, configureAction)</code></strong> 。在内部，该方法会调用一个私有方法<code>AddSchemeHelper&lt;TOptions, THandler&gt;(schemeName, displayName, configureOptionsAction)</code>来完成前文所述的两个工作细节：</p>
<ol>
<li>配置全局的<code>AuthenticationOptions</code>（向其中添加<code>&lt;schemeName&gt;-&lt;handlerType&gt;</code>的映射关系，调用传入的委托配置选项），</li>
<li>然后再把相应的<code>Handler</code>注册到<code>DI</code>容器。</li>
</ol>
<p><code>AddSchemeHelper&lt;TOptions, THandler&gt;(schemeName, displayName, configureOptionsAction)</code>的实现为：</p>
<pre><code class="language-csharp">private AuthenticationBuilder AddSchemeHelper&lt;TOptions, THandler&gt;(string authenticationScheme, string displayName, Action&lt;TOptions&gt; configureOptions)
    where TOptions : AuthenticationSchemeOptions, new()
    where THandler : class, IAuthenticationHandler
{
    // 设置AuthenticationOptions中的 scheme-handler 映射关系
    Services.Configure&lt;AuthenticationOptions&gt;(o =&gt;
    {
        o.AddScheme(authenticationScheme, scheme =&gt; {
            scheme.HandlerType = typeof(THandler);
            scheme.DisplayName = displayName;
        });
    });
    // 配置TOptions钩子
    if (configureOptions != null)
    {
        Services.Configure(authenticationScheme, configureOptions);
    }
    // 添加TOptions 
    Services.AddOptions&lt;TOptions&gt;(authenticationScheme).Validate(o =&gt; {
        o.Validate(authenticationScheme);
        return true;
    });
    // 注册handler服务
    Services.AddTransient&lt;THandler&gt;();
    return this;
}
</code></pre>
<p>这里的<code>TOptions</code>是特定的某种认证模式下的配置，如<code>JwtBearerOptions</code>、<code>CookieAuthenticationOptions</code>等。这个具体的<code>TOptions</code>会在认证时被对应的<code>THanlder</code>使用。</p>
<p>在此基础上，<code>AuthenticationBuilder</code>又提供了一系列<code>AddScheme&lt;TOptions, THandler&gt;(...)</code>方法供开发者注册相应认证<code>scheme</code>及<code>handler</code>。<code>AddScheme&lt;TOptions, THandler&gt;(...)</code>最简单的形式是对<code>AddSchemeHelper</code>的转发调用:</p>
<pre><code class="language-csharp">public virtual AuthenticationBuilder AddScheme&lt;TOptions, THandler&gt;(string authenticationScheme, string displayName, Action&lt;TOptions&gt; configureOptions)
    where TOptions : AuthenticationSchemeOptions, new()
    where THandler : AuthenticationHandler&lt;TOptions&gt;
    =&gt; AddSchemeHelper&lt;TOptions, THandler&gt;(authenticationScheme, displayName, configureOptions);
</code></pre>
<h4>特定认证模式的配置</h4>
<p>各个不同的认证模式往往会<strong>提供一些具体的扩展方法来简化特定的认证模式配置</strong>，比如 <strong><code>AddCookie()</code></strong> 的源码实现为：</p>
<pre><code class="language-csharp">public static AuthenticationBuilder AddCookie(this AuthenticationBuilder builder, string authenticationScheme, string displayName, Action&lt;CookieAuthenticationOptions&gt; configureOptions)
{
    builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;IPostConfigureOptions&lt;CookieAuthenticationOptions&gt;, PostConfigureCookieAuthenticationOptions&gt;());
    builder.Services.AddOptions&lt;CookieAuthenticationOptions&gt;(authenticationScheme).Validate(o =&gt; o.Cookie.Expiration == null, &quot;Cookie.Expiration is ignored, use ExpireTimeSpan instead.&quot;);
    return builder.AddScheme&lt;CookieAuthenticationOptions, CookieAuthenticationHandler&gt;(authenticationScheme, displayName, configureOptions);
}
</code></pre>
<p>这使得开发者可以通过以下方式配置<code>Cookie</code>认证：</p>
<pre><code class="language-csharp">services.AddAuthentication(options =&gt;{
    ...
})
.AddCookie(IdentityConstants.ApplicationScheme, o =&gt;
{
    o.LoginPath = new PathString(&quot;/Account/Login&quot;);
    o.Events = new CookieAuthenticationEvents
    {
        OnValidatePrincipal = SecurityStampValidator.ValidatePrincipalAsync
    };
})
.AddCookie(IdentityConstants.ExternalScheme, o =&gt;
{
    o.Cookie.Name = IdentityConstants.ExternalScheme;
    o.ExpireTimeSpan = TimeSpan.FromMinutes(5);
})
.AddCookie(IdentityConstants.TwoFactorRememberMeScheme, o =&gt;
{
    o.Cookie.Name = IdentityConstants.TwoFactorRememberMeScheme;
    o.Events = new CookieAuthenticationEvents
    {
        OnValidatePrincipal = SecurityStampValidator.ValidateAsync&lt;ITwoFactorSecurityStampValidator&gt;
    };
})
.AddCookie(IdentityConstants.TwoFactorUserIdScheme, o =&gt;
{
    o.Cookie.Name = IdentityConstants.TwoFactorUserIdScheme;
    o.ExpireTimeSpan = TimeSpan.FromMinutes(5);
});
</code></pre>
<p>（其实，这段代码摘自官方<code>AddIdentity&lt;TUser, TRole&gt;(setupAction)</code>项目）</p>
<p>再比如<code>JwtBearer</code>模式提供了<code>AddJwtBearer()</code>扩展方法来简化其认证服务的配置：</p>
<pre><code class="language-csharp">public static AuthenticationBuilder AddJwtBearer(this AuthenticationBuilder builder, string authenticationScheme, string displayName, Action&lt;JwtBearerOptions&gt; configureOptions)
{
    builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;IPostConfigureOptions&lt;JwtBearerOptions&gt;, JwtBearerPostConfigureOptions&gt;());
    return builder.AddScheme&lt;JwtBearerOptions, JwtBearerHandler&gt;(authenticationScheme, displayName, configureOptions);
}
</code></pre>
<h3>如何使用:</h3>
<pre><code class="language-csharp">services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =&gt;
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            // validate the server that created that token
            ValidateIssuer = true,
            // ensure that the recipient of the token is authorized to receive it
            ValidateAudience = true,
            // check that the token is not expired and that the signing key of the issuer is valid
            ValidateLifetime = true,
            // verify that the key used to sign the incoming token is part of a list of trusted keys
            ValidateIssuerSigningKey = true,
            ValidIssuer = issuer,
            ValidAudience = issuer,
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(key))
        };
    });
</code></pre>
<pre><code class="language-csharp">service.AddAuthentication(...)
    .AddJwtBearer(options =&gt;
        // ...
        options.Events = new JwtBearerEvents
        {
            OnMessageReceived = ctx =&gt;
            {
                // replace &quot;token&quot; with whatever your param name is
                if (ctx.Request.Method.Equals(&quot;GET&quot;) &amp;&amp; ctx.Request.Query.ContainsKey(&quot;token&quot;))
                    ctx.Token = ctx.Request.Query[&quot;token&quot;];
                return Task.CompletedTask;
            }
        };
    });
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/CSharp/ASP.NET Core/Security/Authentication/Authentication — (0) 从Authentication中间件说起.html">
                    Authentication — (0) 从Authentication中间件说起
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        CSharp
                      </a>
                    </li>
                    <li>
                      <a href="">
                        ASP.NET Core
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Security
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Authentication
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="/tags.html#ASP.NET Core">
                    <span class="tag is-info">
                      ASP.NET Core
                    </span>
                  </a>
                  <a href="/tags.html#Authentication">
                    <span class="tag is-info">
                      Authentication
                    </span>
                  </a>
                  <a href="/tags.html#CSharp">
                    <span class="tag is-info">
                      CSharp
                    </span>
                  </a>
                  <a href="/tags.html#源码分析">
                    <span class="tag is-info">
                      源码分析
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2019-08-14
                </p>
              </div>
              <div class="content article-body">
                <p><code>ASP.NET Core</code>认证相关的代码比较分散，主要涉及三个项目仓库：</p>
<ol>
<li><a href="https://github.com/aspnet/AspNetCore/tree/master/src/Http/Http.Abstractions">HTTP Abstractions</a>项目，即以前的<a href="https://github.com/aspnet/HttpAbstractions">aspnet/HttpAbstractions</a>仓库。在这个仓库中，包含了一些与认证相关的高层接口和与框架安全相关的核心概念。</li>
<li><a href="https://github.com/aspnet/AspNetCore/tree/master/src/Security">Security</a>项目，即之前的<a href="https://github.com/aspnet/Security">aspnet/Security</a>仓库。这个仓库中定义了与认证相关的一些基本实现，并内置了一些常见的认证模式、认证处理器。</li>
<li><a href="https://github.com/aspnet/AspNetCore/tree/master/src/Identity">Identity</a>项目，即之前的<a href="https://github.com/aspnet/Identity">aspnet/Identity</a>。这个仓库是<code>ASP.NET Core Identity</code>框架的实现。本系列的笔记不会对其做过多的源码分析，这里只作为一种认证模式介绍。</li>
</ol>
<p>去年8月份，我在阅读<code>ASP.NET Core</code>认证相关的源码后，陆陆续续在有道云笔记中记录了8篇笔记(系列)：</p>
<ol start="0">
<li>Authentication — (0) 从Authentication中间件说起</li>
<li>Authentication — (1) 基本概念.md</li>
<li>Authentication — (2) 认证服务及其对HttpContext的认证扩展方法</li>
<li>Authentication — (3.1) 认证处理器的实现之AuthenticationHandler抽象基类</li>
<li>Authentication — (3.2) 认证处理器的实现之JwtBearerHandler</li>
<li>Authentication — (3.3) 认证处理器的实现之RemoteAuthenticationHandler</li>
<li>Authentication — (4) Authentication服务的配置与构建</li>
<li>Authentication — (5) 如何自定义认证处理器</li>
</ol>
<p>（一点题外话：<em>最近这大半年，我几乎都只在有道云上记录笔记(PC端+App+网页版)。不过最近我在修改笔记的过程中发现，有道云笔记网页版经常会发生笔记相互覆盖的情况。最恼火的是，一旦修改了标题，连历史记录也一并丢失了！这种情况已经出现我身上数次了。基于此，我以后记笔记的策略是：有道云做初稿，随时记录想法；整理完成后提交公众号发布，由于公众号有良好的CDN网络，供平时阅读和温习；最后使用个人网站作为终极备份</em>）</p>
<p>随着<code>ASP.NET Core</code>的发展，之前的三个仓库在去年已经被存档，目前新的项目都位于<code>ASP.NET Core</code>中心仓库下。为了表述方便，这个系列的源码分析文章对老仓库和新项目位置不做过多区分。</p>
<p>中间件<code>AuthenticationMiddleware</code>是理解<code>ASP.NET Core</code>认证的入口，尽管搞懂这块需要很多基本知识，作为总纲式的知识，我还是选择把它作为第一篇讲述。<!-- more -->
随后的两篇笔记分别讲述了一些与认证相关的基础类与接口，以及在其基础之上形成的认证服务类。这两篇笔记只是讲述各个类在认证过程中扮演的角色，内容枯燥乏味，犹如流水账一般。但是这块知识是阅读后续第三部分实现的基本前提。
这个系列笔记的第三部分主要讲述各种认证处理器的实现。这部分是与认证相关的源码分析的核心。
第四部分则记录<code>Authentication</code>服务配置与构建的背后原理。
作为收尾，最后一篇笔记以如何自定义一个认证处理器结束这个系列的源码分析。</p>
<p>我会在下一篇笔记讲述认证处理器的基本概念，并在后续的数篇笔记中解释认证处理器是如何工作的。这篇源码笔记的目的是分析<strong>认证过程是如何和一个HTTP请求联系起来的</strong>。</p>
<h2>认证中间件</h2>
<p>要想得到正确的<code>Context.User</code>，必须先注册相关认证服务，然后在合适的位置启用认证中间件：</p>
<pre><code>app.UseAuthentication();  // 必须启用于相关中间件之前
// ...
app.UseMvc(routes =&gt;{
    ...
});
</code></pre>
<p>对于每一个请求, <code>AuthenticationMiddleware</code>中间件都会尝试对当前用户进行认证，这里的认证工作主要通过认证处理器（<code>AuthenticationHandler</code>)来进行。</p>
<p>中间件<a href="https://github.com/aspnet/Security/blob/26d27d871b7992022c082dc207e3d126e1d9d278/src/Microsoft.AspNetCore.Authentication/AuthenticationMiddleware.cs#L11-L63"><code>AuthenticationMiddleware</code></a> 的核心源码为：</p>
<pre><code class="language-csharp">public async Task Invoke(HttpContext context)
{
    context.Features.Set&lt;IAuthenticationFeature&gt;(new AuthenticationFeature
    {
        OriginalPath = context.Request.Path,
        OriginalPathBase = context.Request.PathBase
    });

    // Give any IAuthenticationRequestHandler schemes a chance to handle the request
    var handlers = context.RequestServices.GetRequiredService&lt;IAuthenticationHandlerProvider&gt;();
    foreach (var scheme in await Schemes.GetRequestHandlerSchemesAsync())
    {
        var handler = await handlers.GetHandlerAsync(context, scheme.Name) as IAuthenticationRequestHandler;
        if (handler != null &amp;&amp; await handler.HandleRequestAsync())
        {
            return;
        }
    }

    var defaultAuthenticate = await Schemes.GetDefaultAuthenticateSchemeAsync();
    if (defaultAuthenticate != null)
    {
        var result = await context.AuthenticateAsync(defaultAuthenticate.Name);
        if (result?.Principal != null)
        {
            context.User = result.Principal;
        }
    }

    await _next(context);
}
</code></pre>
<p>这段中间件源码的基本逻辑非常简单：首先遍历所有中间件级别的认证模式，并逐一尝试把相应的认证处理器转换成<code>IAuthenticationRequestHandler</code>接口，然后调用其<code>HandleRequestAsync()</code>方法(如果返回<code>true</code>，则表示当前需要中断后续所有中间件的请求处理)。如果之前的中间件级别的处理并未截断后续处理，则尝试使用默认的认证模式对用户进行认证。</p>
<p>所谓中间件级别的认证，是指可以中断后续请求处理过程的认证。比如对于一些<code>OAuth2.0</code>的认证模式，需要根据当前是否是远程授权成功后的回调请求来中断后续的中间件处理。这些细节都会在后续几篇源码分析笔记中详细阐述，下一篇主要介绍与认证处理器相关的几个基础类。</p>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/CSharp/ASP.NET Core/Security/Authentication/Authentication — (2) 认证服务及其对HttpContext的认证扩展方法.html">
                    Authentication — (2) 认证服务及其对HttpContext的认证扩展方法
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        CSharp
                      </a>
                    </li>
                    <li>
                      <a href="">
                        ASP.NET Core
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Security
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Authentication
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="/tags.html#ASP.NET Core">
                    <span class="tag is-info">
                      ASP.NET Core
                    </span>
                  </a>
                  <a href="/tags.html#CSharp">
                    <span class="tag is-info">
                      CSharp
                    </span>
                  </a>
                  <a href="/tags.html#Authentication">
                    <span class="tag is-info">
                      Authentication
                    </span>
                  </a>
                  <a href="/tags.html#源码分析">
                    <span class="tag is-info">
                      源码分析
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2019-08-14
                </p>
              </div>
              <div class="content article-body">
                <p>此部分代码位于<code>aspnet/HttpAbstractions</code>项目中，命名空间为 <code>Microsoft.AspNetCore.Authentication</code> 。</p>
<p>认证服务及以其为基础对<code>HttpContext</code>的扩展方法是所有认证过程的核心：</p>
<ul>
<li>对于默认的认证模式，是直接转发调用<code>HttpContext.Authenticate()</code>扩展方法</li>
<li>对于自定义的认证请求处理，需要手工在<code>HandleRequestAsync()</code>函数中，自行使用<code>Context.SignInSync(signInScheme,principal,properties)</code>进行登入</li>
</ul>
<h2>认证服务接口</h2>
<p><code>IAuthentictionService</code>接口规定认证、质询、禁止、登入、登出共五个功能：</p>
<pre><code class="language-csharp">public interface IAuthenticationService
{
    Task&lt;AuthenticateResult&gt; AuthenticateAsync(HttpContext context, string scheme);

    Task ChallengeAsync(HttpContext context, string scheme, AuthenticationProperties properties);

    Task ForbidAsync(HttpContext context, string scheme, AuthenticationProperties properties);

    Task SignInAsync(HttpContext context, string scheme, ClaimsPrincipal principal, AuthenticationProperties properties);

    Task SignOutAsync(HttpContext context, string scheme, AuthenticationProperties properties);
}
</code></pre>
<p>而其默认实现<code>AuthenticationService</code>中包含了两个重要字段，即当前的认证模式集<code>Schemes</code>和认证处理器集<code>Handlers</code>(后面会单独讲解<code>IClaimsTransformation Transform</code>)： <!-- more --></p>
<pre><code class="language-csharp">public class AuthenticationService : IAuthenticationService
{
    public AuthenticationService(IAuthenticationSchemeProvider schemes, IAuthenticationHandlerProvider handlers, IClaimsTransformation transform)
    {
        Schemes = schemes;
        Handlers = handlers;
        Transform = transform;
    }

    public IAuthenticationSchemeProvider Schemes { get; }
    public IAuthenticationHandlerProvider Handlers { get; }
    public IClaimsTransformation Transform { get; }
    // ...
}
</code></pre>
<p>这些认证服务接口相关方法的实现比较类似，基本都是转发调用相应认证处理器的相应方法。</p>
<h4>AuthenticateAsync</h4>
<p>比如，<code>AuthenticationAsync(context,scheme)</code>方法会选择合适的认证处理器进行认证：</p>
<pre><code class="language-csharp">public virtual async Task&lt;AuthenticateResult&gt; AuthenticateAsync(HttpContext context, string scheme)
{
    if (scheme == null)
    {
        var defaultScheme = await Schemes.GetDefaultAuthenticateSchemeAsync();
        scheme = defaultScheme?.Name;
        if (scheme == null) { /* throw */ }
    }

    var handler = await Handlers.GetHandlerAsync(context, scheme);
    if (handler == null) { /* throw */ }

    var result = await handler.AuthenticateAsync();
    if (result != null &amp;&amp; result.Succeeded)
    {
        var transformed = await Transform.TransformAsync(result.Principal);
        return AuthenticateResult.Success(new AuthenticationTicket(transformed, result.Properties, result.Ticket.AuthenticationScheme));
    }
    return result;
}
</code></pre>
<p>这里<code>AuthenticationAsync(context,scheme)</code>的处理步骤为：</p>
<ol>
<li>如果<code>scheme</code>未指定，就选择默认的认证模式</li>
<li>根据<code>scheme</code>获取相对应的认证处理器<code>handler</code></li>
<li>调用<code>handler</code>进行认证</li>
</ol>
<p>值得注意的是，如果认证成功，还会通过所注入的<code>IClaimsTransformation</code>服务对结果的<code>Principal</code>进行转换。这里有一个有意思的使用场景：第三方生成的<code>JWT</code>令牌格式并不一定满足<code>ASP.NET Core</code>默认的格式（参见<a href="https://stackoverflow.com/questions/56352055/cant-get-asp-net-core-2-2-to-validate-my-jwt/56354885#56354885">SO回答</a>）。</p>
<p>比如，根据<a href="https://github.com/dotnet/corefx/blob/a10890f4ffe0fadf090c922578ba0e606ebdd16c/src/System.Security.Claims/src/System/Security/Claims/ClaimTypes.cs#L27">dotnet/corefx</a>,<code>ClaimTypes.Role</code>的字符串键名为<code>http://schemas.microsoft.com/ws/2008/06/identity/claims/role</code>,这要求我们传入JWT 以之来配置<code>Role</code>:</p>
<pre><code class="language-json">{
  &quot;nbf&quot;: ...,
  &quot;exp&quot;: ...,
  &quot;iss&quot;: ...,
  &quot;aud&quot;: ...,
   ...,
  &quot;http://schemas.microsoft.com/ws/2008/06/identity/claims/role&quot;: [
    &quot;offline_access&quot;,
    &quot;...other roles&quot;
  ],
}
</code></pre>
<p>但是有时候第三方可能用以下方式配置JWT的Role：</p>
<pre><code class="language-json">&quot;realm_access&quot;:{  
  &quot;roles&quot;:[  
     &quot;offline_access&quot;,
     &quot;uma_authorization&quot;
  ]
},
</code></pre>
<p>这时候我们就可以注入一个自定义的<code>IClaimsTransformation</code>，实现<code>Principal</code>的转换：</p>
<pre><code>services.AddTransient&lt;IClaimsTransformation, ClaimsTransformer&gt;();
</code></pre>
<h4>SignInAsync</h4>
<p>登入与认证类似：也是先检测指定的模式，如果为空则选择默认的登入模式；随后，利用<code>scheme</code>获取相应的认证处理器，转换为<code>IAuthenticationSignInHandler</code>接口对象，最后再用转换出的<code>IAuthenticationSignInHandler</code>对象对<code>principal</code>进行登入。</p>
<pre><code class="language-csharp">public virtual async Task SignInAsync(HttpContext context, string scheme, ClaimsPrincipal principal, AuthenticationProperties properties)
{
    if (principal == null) { /* throw */ }

    if (scheme == null)
    {
        var defaultScheme = await Schemes.GetDefaultSignInSchemeAsync();
        scheme = defaultScheme?.Name;
        if (scheme == null) { /* throw */ }
    }

    var handler = await Handlers.GetHandlerAsync(context, scheme);
    if (handler == null) { /* throw */ }

    var signInHandler = handler as IAuthenticationSignInHandler;
    if (signInHandler == null) { /* throw */ }

    await signInHandler.SignInAsync(principal, properties);
}
</code></pre>
<h2><code>HttpContext</code>的认证扩展方法</h2>
<p>以认证服务为基础，<code>ASP.NET Core</code>为<code>HttpContext</code>添加了一系列扩展方法：</p>
<pre><code class="language-csharp">public static class AuthenticationHttpContextExtensions
{
    public static Task&lt;AuthenticateResult&gt; AuthenticateAsync(this HttpContext context, string scheme) =&gt;
        context.RequestServices.GetRequiredService&lt;IAuthenticationService&gt;().AuthenticateAsync(context, scheme);

    public static Task ChallengeAsync(this HttpContext context, string scheme, AuthenticationProperties properties) =&gt;
        context.RequestServices.GetRequiredService&lt;IAuthenticationService&gt;().ChallengeAsync(context, scheme, properties);

    public static Task ForbidAsync(this HttpContext context, string scheme, AuthenticationProperties properties) =&gt;
        context.RequestServices.GetRequiredService&lt;IAuthenticationService&gt;().ForbidAsync(context, scheme, properties);

    public static Task SignInAsync(this HttpContext context, string scheme, ClaimsPrincipal principal, AuthenticationProperties properties) =&gt;
        context.RequestServices.GetRequiredService&lt;IAuthenticationService&gt;().SignInAsync(context, scheme, principal, properties);

    public static Task SignOutAsync(this HttpContext context, string scheme, AuthenticationProperties properties) =&gt;
        context.RequestServices.GetRequiredService&lt;IAuthenticationService&gt;().SignOutAsync(context, scheme, properties);


    public static Task&lt;string&gt; GetTokenAsync(this HttpContext context, string scheme, string tokenName) =&gt;
        context.RequestServices.GetRequiredService&lt;IAuthenticationService&gt;().GetTokenAsync(context, scheme, tokenName);

    public static Task&lt;string&gt; GetTokenAsync(this HttpContext context, string tokenName) =&gt;
        context.RequestServices.GetRequiredService&lt;IAuthenticationService&gt;().GetTokenAsync(context, tokenName);
}
</code></pre>
<p>这些方法都是简单地转而调用认证服务的相关方法。至此，我们可以通过<code>HttpContext</code>自动调用当前认证服务的相关方法。</p>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/CSharp/ASP.NET Core/Security/Authentication/Authentication — (3.3) 认证处理器的实现之RemoteAuthenticationHandler.html">
                    Authentication — (3.3) 认证处理器的实现之RemoteAuthenticationHandler
                  </a>
                </p>
                <nav class="breadcrumb">
                  <ul>
                    <li>
                      <a href="">
                        风语
                      </a>
                    </li>
                    <li>
                      <a href="">
                        CSharp
                      </a>
                    </li>
                    <li>
                      <a href="">
                        ASP.NET Core
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Security
                      </a>
                    </li>
                    <li>
                      <a href="">
                        Authentication
                      </a>
                    </li>
                  </ul>
                </nav>
                <p class="post-tags">
                  <a href="/tags.html#ASP.NET Core">
                    <span class="tag is-info">
                      ASP.NET Core
                    </span>
                  </a>
                  <a href="/tags.html#CSharp">
                    <span class="tag is-info">
                      CSharp
                    </span>
                  </a>
                  <a href="/tags.html#Authentication">
                    <span class="tag is-info">
                      Authentication
                    </span>
                  </a>
                  <a href="/tags.html#源码分析">
                    <span class="tag is-info">
                      源码分析
                    </span>
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2019-08-14
                </p>
              </div>
              <div class="content article-body">
                <p>设想我们要写一个支持<code>OAuth2.0</code>的认证处理器，它支持使用<code>Google</code>、<code>Microsoft</code>、<code>Facebook</code>等账号登陆。由于它们共用一套认证逻辑<code>OAuth2.0</code>，所以我们不希望为每一个网站都写一遍处理认证的方法，而是希望针对每个网站的一些特性部分进行简单填充。一个合理的方式是让处理认证的方法接受一个如何登陆的字符串（比如<code>Google</code>），然后通过认证服务去自动调用对应具体的认证处理器（比如<code>GoogleHandler</code>）。
更一般的，除了<code>OAuth</code>,<code>OIDC</code>也是一种常见的远程认证方式。</p>
<p>为了抽象这种利用远程服务器进行认证的方式，<code>ASP.NET Core</code>提供了<code>RemoteAuthenticationHandler&lt;TOptions&gt;</code>抽象类。该类继承自<code>AuthenticationHandler&lt;TOptions&gt;</code>抽象基类，并且实现了<code>IAuthenticationRequestHandler</code>接口：</p>
<pre><code class="language-csharp">public abstract class RemoteAuthenticationHandler&lt;TOptions&gt; : AuthenticationHandler&lt;TOptions&gt;, IAuthenticationRequestHandler
    where TOptions : RemoteAuthenticationOptions, new()
{
    protected string SignInScheme =&gt; Options.SignInScheme;
    
    protected new RemoteAuthenticationEvents Events
    {
        get { return (RemoteAuthenticationEvents)base.Events; }
        set { base.Events = value; }
    }
    
    // ...
}
</code></pre>
<p>由于在继承自<code>AuthenticationHandler&lt;TOptions&gt;</code>的同时，还实现了<code>IAuthenticationRequestHandler</code>接口，这个<code>RemoteAuthenticationHandler&lt;TOptions&gt;</code>类就有两套处理认证的机制。一套是<code>AuthenticationHandler&lt;TOptions&gt;</code>的认证、质询、禁止等方法；另一套是<code>IAuthenticationRequestHandler</code>的接口方法<code>HandleRequestAsync()</code>用于直接对请求进行中间件级别的处理，并中断后续请求处理过程。<!-- more --></p>
<p>需要特别指出的是，<code>RemoteAuthenticationHandler</code>中有一个受保护的 <strong><code>SignInScheme</code></strong> 属性。其用途为：</p>
<ol>
<li>当用户认证成功时，使用该<code>SignInScheme</code>将用户<strong>登入</strong></li>
<li>当需要认证用户时，只需查看当前用户在该<code>SignInScheme</code>下是否已经登陆</li>
<li>当用户被判定登陆失败提示<code>Forbidden</code>时，调用认证服务转而调用<code>SignInScheme</code>模式对应的认证处理器方法。</li>
</ol>
<h3><code>AuthenticationHandler&lt;TOptions&gt;</code>系的方法</h3>
<p>这一系列的方法包括处理认证、处理质询、处理禁止、处理登入、和处理登出几个方法。其中，处理禁止的方法最为简单，只是简单转而调用<code>SignInScheme</code>对应的处理器方法：</p>
<pre><code class="language-csharp">protected override Task HandleForbiddenAsync(AuthenticationProperties properties)=&gt; Context.ForbidAsync(SignInScheme);
</code></pre>
<p>而其处理认证的方法也只是复用<code>SigninScheme</code>模式进行认证：</p>
<pre><code class="language-csharp">protected override async Task&lt;AuthenticateResult&gt; HandleAuthenticateAsync()
{
    var result = await Context.AuthenticateAsync(SignInScheme);
    if (result != null)
    {
        if (result.Failure != null) {  return result; }

        // The SignInScheme may be shared with multiple providers, make sure this provider issued the identity.
        string authenticatedScheme;
        var ticket = result.Ticket;
        if (ticket != null &amp;&amp; ticket.Principal != null &amp;&amp; ticket.Properties != null
            &amp;&amp; ticket.Properties.Items.TryGetValue(AuthSchemeKey, out authenticatedScheme)
            &amp;&amp; string.Equals(Scheme.Name, authenticatedScheme, StringComparison.Ordinal))
        {
            return AuthenticateResult.Success(new AuthenticationTicket(ticket.Principal,
                ticket.Properties, Scheme.Name));
        }

        return AuthenticateResult.Fail(&quot;Not authenticated&quot;);
    }

    return AuthenticateResult.Fail(&quot;Remote authentication does not directly support AuthenticateAsync&quot;);
}
</code></pre>
<p>其他几个方法均类似，故不复赘述。</p>
<h3><code>IAuthenticationRequestHandler</code>系的接口方法</h3>
<p>在开始这部分内容之前，先要了解下这个类的一个辅助方法：<code>ShouldHandleRequestAsync()</code>。我们知道，远程认证结束后，远程服务器需要把用户重定向到本服务器的某个地址（称之为<strong>回调地址</strong>）。该方法的工作原理便是判断当前路径是否为配置好的<strong>回调地址</strong>，如果是，则意味着当前请求是远程服务器认证结束后重定向来的<strong>回调请求</strong>，需要拦截处理。</p>
<pre><code class="language-csharp">public virtual Task&lt;bool&gt; ShouldHandleRequestAsync() =&gt; Task.FromResult(Options.CallbackPath == Request.Path);
</code></pre>
<p>作为<code>IAuthenticationRequestHandler</code>接口的核心方法，<code>HandleRequestAsync()</code>方法基本思路是，<strong>判断当前路径是否为预配返回地址，如果不是，则意味着当前请求并不适合用<code>IAuthenticationRequestHandler</code>接口处理，直接返回<code>false</code>；否则，意味着当前的请求是由远程认证服务器认证结束后重定向来的请求，应当确认用户身份，触发相关事件钩子，最终在登入用户之后，中断后续的请求处理过程(<code>return true</code>)</strong>。</p>
<pre><code class="language-csharp">public virtual async Task&lt;bool&gt; HandleRequestAsync()
{
    if (!await ShouldHandleRequestAsync())
    {
        return false;
    }
    
    // ...
    
    var authResult = await HandleRemoteAuthenticateAsync();
    // check authResult... 
    
    // create a ticketContext if authResult succeeds 
    // ... await Events.TicketReceived(ticketContext);
    
    await Context.SignInAsync(SignInScheme, ticketContext.Principal, ticketContext.Properties);

    // Default redirect path is the base path
    if (string.IsNullOrEmpty(ticketContext.ReturnUri))
    {
        ticketContext.ReturnUri = &quot;/&quot;;
    }

    Response.Redirect(ticketContext.ReturnUri);
    return true;
}
</code></pre>
<p>这里<code>HandleRemoteAuthenticateAsync()</code>是一个抽象方法，留待不同的子类提供实现。</p>
<h2><code>RemoteAuthenticationHandler</code> 流程概述</h2>
<p>总结而言，<code>RemoteAuthenticationHandler</code>的完整调用流程可以</p>
<p>以<code>GoogleHandler</code>为例，</p>
<ol>
<li>用户访问某个页面，点击“使用Google登陆”按钮，申请使用Google账号提交，浏览器发送请求到<code>https://your-server/Identity/Account/ExternalLogin?returnUrl=%2F</code>:</li>
<li><code>ASP.NET Core</code> 相关登陆页面将之重定向至<code>Google</code>授权页面</li>
</ol>
<pre><code>https://accounts.google.com/o/oauth2/v2/auth?
    response_type=code
    &amp;client_id=xxx
    &amp;scope=openid%20profile%20email
    &amp;redirect_uri=https%3A%2F%2Fyour-server%2Fsignin-google
    &amp;state=xxx
</code></pre>
<ol start="3">
<li><code>Google</code>认证用户完成以后，将用户重定向至<code>ASP.NET Core</code> 的指定URL（携带<code>code</code>等参数），该URL通常是：<code>/sigin-google</code>:</li>
</ol>
<pre><code> https://your-server/signin-google?
    state=xxx
    &amp;code=yyy
    &amp;scope=zzz
    &amp;authuser=0
    &amp;session_state=abc
    &amp;prompt=none
</code></pre>
<ol start="4">
<li>浏览器访问上述URL，中间件<code>AuthenticationMiddleware</code>会调用<code>GetRequestHandlerSchemesAsync()</code>方法获取所有的<code>RequestHandlerSchemes</code>，然后逐一尝试将该认证处理器转换<code>AuthenticationRequestHandler</code>，如果成功，则调用其<code>HandleRequestAsync()</code>方法。<code>GoogleHandler::HandleRequestAsync()</code>方法继承自<code>RemoteAuthenticationHandler</code>，会先调用<code>ShouldHandleRequestAsync()</code>进行判断是否需要处理请求。默认情况下，该方法只是检测<code>Options.CallbackPath</code>和 <code>Request.Path</code>是否相等而已。如果不等，说明当前认证处理器不应当处理当前请求相等；否则，比如这里等于<code>signin-google</code>，则会进行远程认证处理(不同的远程认证模式，其处理方式也不同，比如，<code>OAuth2.0</code>中常见的方式是用<code>code</code>换取<code>token</code>)，处理认证完成之后，倘若认证成功，则再将用户<code>SigninAsync()</code>之。</li>
</ol>
<p>参见SO上的回答:
https://stackoverflow.com/questions/52980581/how-signin-google-in-asp-net-core-authentication-is-linked-to-the-google-handler/52984793#52984793</p>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <div class="container">
      <div class="container has-text-centered">
        <a href="posts/page2.html">
          Previous
        </a>
        4 of 32
        <a href="posts/page4.html">
          Next
        </a>
      </div>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
       // 处理形如 <code>$E=mc^2$</code> 形式的公式
 var inlineMathNodes=document.querySelectorAll('code');
 var re=/^\$(.*)\$$/;
 for(var j=0;j<inlineMathNodes.length;j++){
   var result=re.exec(inlineMathNodes.item(j).innerText);
   if(result!==null){
	 katex.render(result[1], inlineMathNodes.item(j));
   }
 }
 function removeNode(node){
   if(node.remove){
	 node.remove();
   }else{
	 return first.parentNode.removeChild(node);
   }
 };

 // 查找所有 pre code.language-math 节点 以备筛出数据公式
 var nodes=document.querySelectorAll("pre code.language-math");
 for(var i=0;i<nodes.length;i++){
   var node=nodes.item(i);
   // 魔术标记所在行 
   try{
	 var lines = node.innerText.split('\n');
	 if((!!lines) && lines.length > 0)
	 {
	   var first = lines[0];
	   if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
		 var views = "";
		 // 逐行渲染
		 for(var k=1; k <lines.length; k++){
			 var f=lines[k];
			 views += katex.renderToString(f);
		 }
		 // 消除父级嵌套 
		 try{
		   node.innerHTML=views;
		 }catch(e){
		   // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
		   console.log('IE9 sucks',e);
		   $(tr).html(node.innerHTML);
		 }
	   }
	 }
   }
   catch(err){
	 console.log(err)
   }
 }
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>