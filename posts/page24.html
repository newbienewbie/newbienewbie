<!DOCTYPE html><html>
  <head>
    <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie/"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item is-active" href="">
            Home
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/Java/spring/Spring-WebMvc流程分析综述1：基于XML的配置方式.html">
                    Spring WebMvc流程分析综述1：基于XML的配置方式
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2016-10-18
                </p>
              </div>
              <div class="content article-body">
                <p>Spring WebMvc 启动流程是怎么样的？</p>
<h2>从DispatcherServlet说起</h2>
<p>首先，在标准部署描述符<code>web.xml</code>文件中，有类似如下的一段<code>Servlet</code>配置：</p>
<pre><code class="language-XML">&lt;servlet&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<p>声明所有以<code>*.htm</code>结尾的url-pattern都交给<code>org.springframework.web.servlet.DispatcherServlet</code>类去处理，这个类扮演着前端控制器(Front Controller)的角色，
默认情况下会去加载与<code>sevlet-name</code>元素相关的一个配置文件（应用上下文配置文件），其路径名规则为：</p>
<p><code>WEB-INF/${servlet-name}-servlet.xml</code></p>
<p>比如，这里指定的<code>sevlet-name</code>元素名为<code>dispatcher</code>，则会默认去加载<code>web/WEB-INF/dispatcher-servlet.xml</code>文件。
这是一种<code>约定优于配置</code>的做法，当然，我们也可以手工指定<code>DispatcherServlet</code>配置文件：</p>
<pre><code class="language-XML">&lt;servlet&gt;
    &lt;description&gt;spring mvc servlet&lt;/description&gt;
    &lt;servlet-name&gt;springMvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;description&gt;spring mvc 配置文件&lt;/description&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
</code></pre>
<p><code>DispatcherServlet</code>的相关配置文件还可以是JavaConfig形式：</p>
<pre><code class="language-XML">&lt;servlet&gt;
    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt; 
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt; 
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value&gt;
    &lt;/init-param&gt; 
    &lt;init-param&gt; 
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; 
        &lt;param-value&gt;com.habuma.spitter.config.WebConfigConfig&lt;/param-value&gt;
    &lt;/init-param&gt; 
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
</code></pre>
<p><code>DsipatcherServlet</code>配置文件是一个Spring应用上下文配置文件，XML结构类似于：</p>
<pre><code class="language-XML">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!-- was: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; --&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd
    http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&quot;&gt;

    &lt;bean class=&quot;org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping&quot;/&gt;
    &lt;!--
    Most controllers will use the ControllerClassNameHandlerMapping above, but
    for the index controller we are using ParameterizableViewController, so we must
    define an explicit mapping for it.
    --&gt;
    &lt;bean id=&quot;urlMapping&quot; class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;
        &lt;property name=&quot;mappings&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;index.htm&quot;&gt;indexController&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;viewResolver&quot;
        class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
        p:prefix=&quot;/WEB-INF/jsp/&quot;
        p:suffix=&quot;.jsp&quot; /&gt;

    &lt;!-- The index controller. --&gt;
    &lt;bean name=&quot;indexController&quot;
        class=&quot;org.springframework.web.servlet.mvc.ParameterizableViewController&quot;
        p:viewName=&quot;index&quot; /&gt;
&lt;/beans&gt;
</code></pre>
<p>当<code>DispatcherServlet</code>接到一个匹配<code>*.htm</code>形式的请求（比如这里配置的<code>index.htm</code>）时，就会知道对应的<code>控制器Bean</code>的名称（比如，这里配置的<code>indexControll</code>），
再通过IoC获取相应的<code>控制器Bean</code>。</p>
<p>当然，这种把</p>
<ul>
<li><code>路径-控制器Bean</code>映射关系的声明</li>
<li>控制器Bean的声明</li>
</ul>
<p>写到XML文件中的方式很啰嗦，也不够直观，Spring支持：</p>
<ul>
<li>通过<code>@Controller</code>注解声明Bean</li>
<li>通过<code>@RequestMapping</code>注解来配置这种映射关系。</li>
</ul>
<p>控制器在完成相应的业务逻辑后，设置Model参数，返回视图的逻辑名；通过IoC获取视图解析器；
再由视图解析器完成从逻辑视图名转到View视图对象的转换，
最后由View对象的render()方法进行渲染到response。</p>
<h2>ContextLoaderListener</h2>
<p>由于<code>前端控制器</code>所加载的配置文件是只是<code>{$dispatcherServletConfigName}</code>的文件，对于其他配置文件的加载怎么办?
这可以用<code>Servlet监听器</code>实现。</p>
<h3>标准的 ServletContext</h3>
<h4>ServletContext 简介</h4>
<p>根据标准，一个Host下可以部署多个Web Application，Web Application 都有一个<code>ServletContext</code>接口对象：</p>
<p>每一个<code>Context</code>都可以配置自己独立的资源，比如数据源资源。在具体项目目录的META-INF/，创建<code>context.xml</code>即可：</p>
<pre><code class="language-XML">&lt;?xml version='1.0' encoding='utf-8'?&gt;

&lt;Context docBase=&quot;demods&quot; path=&quot;/demods&quot; reloadable=&quot;true&quot;&gt;
    &lt;Resource name=&quot;jdbc/EmployeeDB&quot;
        auth=&quot;Container&quot;
        type=&quot;javax.sql.DataSource&quot;
        username=&quot;dbusername&quot;
        password=&quot;dbpassword&quot;
        driverClassName=&quot;org.hsql.jdbcDriver&quot;
        url=&quot;jdbc:HypersonicSQL:database&quot;
        maxActive=&quot;8&quot;
        maxIdle=&quot;4&quot;
    /&gt;
&lt;/Context&gt;
</code></pre>
<p><code>Servlet</code>可以用之与<code>Servlet容器</code>通信，例如：</p>
<ul>
<li>得到文件的MIME类型</li>
<li>转发请求</li>
<li>向日志文件写入日志消息。</li>
</ul>
<p><code>ServletContext</code>的具体表现就是Web服务器中一个已知路径的根。比如<code>http://localhost:8080/demo/</code>，这里demo便是。</p>
<h4>ServletContext 参数</h4>
<p>在<code>web.xml</code>文件中，还可以指定若干<context-param>元素来配置<code>ServletContext</code>的参数</p>
<pre><code class="language-XML">&lt;context-param&gt;
    &lt;param-name&gt;url&lt;/param-name&gt;
    &lt;param-value&gt;jdbc:microsoft:sqlserver://localhost:1433;databse=snptest&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre>
<p>如此，即可在<code>Servlet</code>中，通过</p>
<pre><code class="language-Java">getServletContext().getInitParameter(&quot;paramName&quot;);
</code></pre>
<p>来获取之。</p>
<p>总之，如名字暗示的那样，<code>ServletContext</code>代表了<code>Servlet</code>的运行上下文环境。</p>
<h4>ServletContext 的事件与监听器</h4>
<p>与<code>ServletContext</code>相关的事件主要有两个：</p>
<ul>
<li><code>生命周期</code>:<code>ServletContext</code>初始化、销毁，监听器为<code>ServletContextListener</code></li>
<li><code>属性改变</code>:<code>ServletContext</code>的属性被增加、删除或者替换时发生，监听器为<code>ServletContextAttributeListener</code></li>
</ul>
<p>其中，<code>ServletContextListener</code>接口如下:</p>
<pre><code class="language-Java">public interface ServletContextListener extends EventListener {

    /**
     * Receives notification that the web application initialization
     * process is starting.
     *
     * &lt;p&gt;All ServletContextListeners are notified of context
     * initialization before any filters or servlets in the web
     * application are initialized.
     *
     * @param sce the ServletContextEvent containing the ServletContext
     * that is being initialized
     */
    public void contextInitialized(ServletContextEvent sce);

    /**
     * Receives notification that the ServletContext is about to be
     * shut down.
     *
     * &lt;p&gt;All servlets and filters will have been destroyed before any
     * ServletContextListeners are notified of context
     * destruction.
     *
     * @param sce the ServletContextEvent containing the ServletContext
     * that is being destroyed
     */
    public void contextDestroyed(ServletContextEvent sce);
}
</code></pre>
<h3>Spring 的 ContextLoaderListener</h3>
<p>Spring 加载其他配置文件是通过在<code>web.xml</code>中注册<code>ServletContextListener</code>实现的。</p>
<pre><code class="language-XML">&lt;listener&gt;
    &lt;listener-class&gt;
        org.springframework.web.context.ContextLoaderListener
    &lt;/listener-class&gt;
&lt;/listener&gt;

</code></pre>
<p>Spring 提供的<code>ContextLoaderListener</code>是标准接口<code>javax.servlet.ServletContextListener</code>的一个实现。
用于加载其他配置文件到Spring应用上下文中。默认情况下，这个监听器会加载<code>WEB-INF/applicationContext.xml</code>配置文件。也可以手工指定这个配置文件名：</p>
<pre><code class="language-XML">&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;
        /WEB-INF/spitter-security.xml
        classpath:service-context.xml
        classpath:persistence-context.xml
        classpath:dataSource-context.xml
    &lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre>
<h2>小结</h2>
<p>Spring WebMvc 启动流程主要是通过标准的<code>web.xml</code>部署描述符完成。</p>
<ul>
<li>指定一切请求交由调度器<code>DipatcherServlet</code>根据相关配置（默认是<code>WEB-INF/${servlet-name}-servlet.xml</code>）处理。</li>
<li>通过<code>ServletContext</code>监听器<code>ContextLoaderListener</code>加载上下文配置文件（默认是<code>WEB-INF/applicationContext.xml</code>）。</li>
</ul>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/ECMAScript/misc/一种配合Express-React使用UEditor的方案.html">
                    一种配合Express+React使用UEditor的方案(1)
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2016-10-15
                </p>
              </div>
              <div class="content article-body">
                <p>这是一种配合Express+React使用UEditor的方案的第(1)篇。</p>
<p><a href="http://ueditor.baidu.com/website/index.html">UEditor</a>是由百度推出的一款所见即所得富文本web编辑器，开源，基于MIT协议。</p>
<p>笔者十分喜欢这款产品，并在一个实际改造项目(基于<code>ASP.NET</code>)中替换原来老旧的<code>FCKEditor</code>，收到了很不错的效果。
虽说大家对百度近些年来某些商业行为的口碑不太好，但是不得不说，他们工程师的技术造诣仍旧是我等低级码农学习之典范。</p>
<p>本文只讲在<code>JavaScript</code>的前、后端应用中使用<code>UEditor</code>遇到的两个问题及解决方案：</p>
<ol>
<li>后端方面：官方网站上只给出了<code>.NET</code>、<code>Java</code>、<code>PHP</code>的后端示例，并未提供<code>Node.js</code>版，目前官网、和npm上有几款相关包，可惜功能都有欠缺。以<a href="https://github.com/netpi/ueditor/">netpi/ueditor</a>为例，并不像官方提供的<code>.NET</code>、<code>PHP</code>、<code>Java</code>的后台示例那样支持自配置功能。</li>
<li>前端方面：<code>React</code> 现在大红大紫，如何使用 <code>React</code> 包装一个 <code>UEditor</code> 元素来使用？ 如何避免<code>SPA</code>应用中的多次加载 <code>UEditor</code> 的坑？</li>
</ol>
<p>于是笔者写了两个包解决这两个问题。</p>
<h2>为 UEditor 编写 Express 支持</h2>
<p><code>UEditor</code>这块产品本身是一个纯前端项目，每次与后端交互，都会向一个控制器发起请求，并在<code>action</code>参数中附上动作名。笔者编写了一个npm包<code>express-ueditor</code>来实现相关功能。</p>
<h3>相关地址：</h3>
<ul>
<li><a href="https://www.npmjs.com/package/express-ueditor">npm安装主页</a></li>
<li><a href="https://github.com/newbienewbie/express-ueditor">GitHub源码</a></li>
</ul>
<h3>安装与测试</h3>
<pre><code>&gt; # 安装
&gt; npm install
&gt; # 测试
&gt; npm run test
</code></pre>
<h3>使用方法</h3>
<p>使用方法非常简单，只需要简单记住以下3条规则即可：</p>
<ol>
<li><code>UEditor</code>类是<code>express-ueditor</code>各功能的统一出入口，</li>
<li>可以在实例化<code>UEditor</code>的时候提供自定义选项：</li>
</ol>
<pre><code class="language-JavaScript">const ueditor=new UEditor({
    // 支持官方提供的其他语言Demo的所有自定义配置
    // ...如果不提供，则使用默认参数
});
</code></pre>
<ol start="3">
<li>各组件以高阶函数的形式提供，比如config(),upload(actionStr)分别返回一个中间件函数。可参考的demo如下：</li>
</ol>
<pre><code class="language-JavaScript">const app=express();
const router=express.Router();

const ueditor=new UEditor({
    videoMaxSize:5*1014*1024*1024,  
});

router.post(&quot;/image&quot;,ueditor.upload(&quot;uploadimage&quot;));
router.post(&quot;/video&quot;,ueditor.upload(&quot;uploadvideo&quot;));;

app.use(router);
</code></pre>
<h2>React 包装 UEditor</h2>
<p>目前官方给予的前端使用方式：</p>
<ol>
<li>直接引入UEditor的前端配置文件<code>ueditor.config.js</code></li>
<li>直接引入相关脚本文件<code>ueditor.all.js</code>，</li>
<li>编写自定义JavaScript完成UEditor的生成。</li>
</ol>
<p><a href="http://fex.baidu.com/ueditor">相关代码</a>为:</p>
<pre><code class="language-HTML">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;ueditor demo&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;!-- 加载编辑器的容器 --&gt;
    &lt;script id=&quot;container&quot; name=&quot;content&quot; type=&quot;text/plain&quot;&gt;
        这里写你的初始化内容
    &lt;/script&gt;
    &lt;!-- 配置文件 --&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;ueditor.config.js&quot;&gt;&lt;/script&gt;
    &lt;!-- 编辑器源码文件 --&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;ueditor.all.js&quot;&gt;&lt;/script&gt;
    &lt;!-- 实例化编辑器 --&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var ue = UE.getEditor('container');
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>有一个不方便的地方在于，目前<code>UEditor</code>并不支持<code>npm</code>安装。
如果要简单的包装为一个React组件<code>UEditor</code>，还需要预先在页面中手工引入<code>ueditor.config.js</code>、<code>ueditor.config.js</code>。
如果是传统的多页面应用问题倒不严重，因为只有在访问特定页面的时候在会加载。
单若是开发单页面应用，就比较麻烦了：</p>
<ol>
<li>对于特定角色的用户，SPA的功能可能只有一部分被使用，如何确保只在用户执行了某个操作的时候才加载这两个脚本文件？</li>
<li>SPA在用户切换到其他功能后再切换回来时，因为UE.getEditor()已经有现成实例，无法重新获取编辑器。</li>
</ol>
<p>针对问题1，解决方案是：</p>
<ol>
<li>每当组件加载前，都判断相应的脚本<code>Script</code>是否存在，如果不存在，创建之。</li>
<li>每当组件加载完，尝试获取编辑器<code>UE.getEditor()</code>，如果无法获取，则稍后再试，如此往复。</li>
</ol>
<p>针对问题2，解决方案是：</p>
<p>每次组件卸载前，都触发一次<code>UE.delEditor()</code>来删除编辑器。</p>
<p>笔者已经将之封装为到UI组件<code>simple-react-ui</code>中。</p>
<h3>相关地址</h3>
<p><a href="https://www.npmjs.com/package/simple-react-ui">npm安装主页</a>
<a href="https://github.com/newbienewbie/simple-react-ui">GitHub源码</a></p>
<h3>安装</h3>
<pre><code>npm install simple-react-ui --save
</code></pre>
<h3>使用</h3>
<ul>
<li>把UEditor相应的文件包放置在浏览器端可以访问的URL路径下，比如，<code>/static</code></li>
<li>引入 simple-react-ui 的 UEditor 组件，提供相应的属性</li>
</ul>
<pre><code class="language-JavaScript">import React from 'react';
import UEditor from 'simple-react-ui/dist/ueditor';

const Add=React.createClass({

    render:function () {

        return (&lt;div className=&quot;col-sm-9 col-sm-offset-3 col-md-8 col-md-offset-2 main&quot;&gt;
            &lt;form action=&quot;&quot; method='post' className=&quot;container&quot; &gt;
                &lt;input name='title'/&gt;
                &lt;UEditor id=&quot;ueditorContainer&quot; name=&quot;content&quot; 
                    width={800} height={500} 
                    uconfigSrc='/static/ueditor/ueditor.config.js'
                    ueditorSrc='/static/ueditor/ueditor.all.min.js'
                /&gt;
                &lt;input className=&quot;btn btn-warning&quot; type='submit' name=&quot;提交&quot; value='提交'/&gt;
            &lt;/form&gt;
        &lt;/div&gt;);
    }
});


export default Add;
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/ECMAScript/misc/Express-Hexo建站实践.html">
                    Express-Hexo建站实践
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2016-10-14
                </p>
              </div>
              <div class="content article-body">
                <p>之前的域名<a href="xuanpinmen.com">玄牝门</a>过期了，而且我也不打算再续。</p>
<h2>WordPress 和 有道云笔记</h2>
<p>当时用的是WordPress，尽管使用插件可以使之从 GitHub 同步 Markdown 笔记，但是还是觉得不够方便：</p>
<ol>
<li>插件对 Markdown 语法支持不够完备，从 GitHub 拉取后还要手工调整下局部不兼容问题。</li>
<li>代码高亮得自己配，还有乱七八糟的代码自折行问题；需要自己添加钩子修改CSS。</li>
<li>在线编辑器不能使用<code>VIM</code>模式，打字没有手感。</li>
<li>无法全程使用键盘，不够Geek。</li>
</ol>
<p>于是一直使用自己最趁手的编辑器（<code>Vim</code>、<code>VSCode</code>）+有道云笔记作为替代方案。
{% asset_img &quot;youdaonote.png&quot; &quot;有道云笔记&quot; %}</p>
<p>这两日又觉得有个域名还是蛮方便的，于是又重新萌发了搞个网站的想法。</p>
<h2>Express + Hexo</h2>
<p>搞网站，极速开发，语言选择，当然是通吃百家饭的 JavaScript 。</p>
<h3>技术栈</h3>
<p>既然追求极速、Geek，当然既要利用现有的轮子，又要充分定制:</p>
<ul>
<li><code>Hexo</code> 是成熟的记笔记方案，但是 <code>hexo server</code> 的可定制化程度不高；</li>
<li>HTML在线编辑器：使用笔者之前编写的<code>express-ueditor</code>和<code>simple-react-ui</code>下的ueditor，可以极速搭建一个HTML在线编辑器，但是对 Markdown 支持得多敲代码。</li>
<li>在HTML在线编辑器的基础上使用Markdown纯文本：图片相对路径设置、皮肤、插件等功能都得自己实现。</li>
</ul>
<p>采用的方案如下：</p>
<ol>
<li>记笔记采用 <code>Hexo</code> ，纯静态化为前端文件；</li>
<li>为了可以随时添加其他功能，采用 <code>Express</code> 作为基础框架。</li>
<li>最起码提供两分支，一套<code>blog</code>分支管理笔记文件，一套<code>master</code>分支管理网站源码。</li>
</ol>
<h3>代码</h3>
<p>代码本身极其简单，具体实现不复赘言。笔者已经将其做成了适用于<code>Openshift</code>的一个<a href="https://github.com/newbienewbie/Express-Hexo">通用型应用</a>。</p>
<p>Openshift v2 提供了一个可以运行 Node.JS Latest <a href="https://openshift.redhat.com/app/console/application_type/quickstart!243">Host方案</a>，</p>
<p>{% asset_img &quot;Create-a-New-Application.png&quot; &quot;利用代码仓库创建博客网站&quot; %}</p>
<p>在 Source Code 字段，填写<code>源码地址</code>、<code>分支</code>，经过半分钟左右，即可生成网站。如果导入的是<code>blog</code>分支，则会直接完成网站文章的导入。</p>
<h3>工作流</h3>
<p>完整工作流如下：</p>
<ol>
<li>利用最趁手的编辑器<code>VSCode</code>记笔记、调试、预览、提交</li>
<li>推送 <code>commit</code> 到 <code>github</code>作为备份</li>
<li>推送 <code>commit</code> 到展示网站</li>
<li>部署后自动触发钩子，对<code>Hexo</code>笔记进行静态化</li>
<li>网站对外采用<code>Express</code>展示静态化的<code>blog</code></li>
</ol>
<p>{% asset_img &quot;express-hexo-vscode-git-browser.png&quot; &quot;工作流&quot; %}</p>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Misc/When I am Stupid/HTTP_RAW_POST_DATA.html">
                    开发微信接口时遇到的HTTP_RAW_POST_DATA
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2015-09-24
                </p>
              </div>
              <div class="content article-body">
                <p>在微信开发中，需要对POST过来的<code>HTTP_RAW_POST_DATA</code>进行解密，
为了避免重复造轮子，我使用了Symfony/HttpFoundataion组件中的Request类,然后不动脑子的写出了类似这样的代码：</p>
<pre><code class="language-PHP">
//...
$httpRawPostData=$event-&gt;getRequest()
    -&gt;request
    -&gt;get('HTTP_RAW_POST_DATA','');

//对$httpRawPostData解密并查找相应的路由
//...

</code></pre>
<p>试了好几遍，都是以找不到相应路由的异常结束。</p>
<p>然后我才意识到，我真是个蠢货。</p>
<p>微信服务器发送到我的服务器上的<code>HTTP_RAW_POST_DATA</code>本身就是最原始的数据，上面的写法实际上需要微信服务器POST这样的请求：</p>
<pre><code>HTTP_RAW_POST_DATA={加密后的数据}
</code></pre>
<p>所以正确的代码应该是：</p>
<pre><code class="language-PHP">//...
$httpRawPostData=$event-&gt;getRequest()
    -&gt;getContent();
//对$httpRawPostData进行解密
//...
</code></pre>
<p>What a stupid mistake.</p>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/PHP/Misc/Pimple.html">
                    Pimple
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2015-09-19
                </p>
              </div>
              <div class="content article-body">
                <h2>Why Pimple</h2>
<p>最近在倒腾WordPress，在github选择了一个四百多关注的微信框架项目，结果发现bug不断，好不容易通读源码后改好了BUG又发现扩展性太差，
而且各类之间代码耦合严重，于是打算动手写一个自己的微框架(重复造轮子)，想实现这样的目标：</p>
<ol>
<li>独立于任何框架、整站程序</li>
<li>不要依赖于外部PHP扩展，可以运行在低端空间之上。</li>
<li>良好的组织性</li>
<li>良好的可扩展性</li>
</ol>
<p>不可避免的遇到了依赖注入问题，起初想直接用Symfony/DependencyInjection组件，但是写着写着就发现这个组件太啰嗦了。
于是决定学习以下著名的Pimpler容器。</p>
<p>不得不说这玩意儿实在是小巧精致！</p>
<h2>Pimple用法</h2>
<p>下面翻译自官方文档：</p>
<p>创建一个容器：</p>
<pre><code class="language-PHP">use Pimple\Container;

$container = new Container();
</code></pre>
<p>和众多其他的DI容器一样，Pimple主要管理两类数据：<code>服务</code>和<code>参数</code>。</p>
<h3>定义Services</h3>
<p>服务是通过可以返回一个实例对象的匿名函数来定义的：</p>
<pre><code class="language-PHP">// define some services
$container['session_storage'] = function ($c) {
    return new SessionStorage('SESSION_ID');
};

$container['session'] = function ($c) {
    return new Session($c['session_storage']);
};
</code></pre>
<p>注意此匿名函数可以访问当前容器对象实例,允许对其他<code>服务</code>或者<code>参赛</code>进行引用。
对象只有当你需要获取它们的时候才被创建，定义的顺序是无关紧要的。</p>
<p>使用已定义的服务同样非常简单：</p>
<pre><code class="language-PHP">// get the session object
$session = $container['session'];

// the above call is roughly equivalent to the following code:
// $storage = new SessionStorage('SESSION_ID');
// $session = new Session($storage);
</code></pre>
<h3>定义工厂服务</h3>
<p>默认情况下，你每一次获取<code>服务</code>,Pimple返回它的同一个实例。如果你想要它每次返回不同的实例,用<code>factory()</code>方法包装你的匿名函数即可：</p>
<pre><code class="language-PHP">$container['session'] = $container-&gt;factory(function ($c) {
    return new Session($c['session_storage']);
});
</code></pre>
<p>这样，每一次调用 <code>$container['session']</code>都会返回一个新的session实例。</p>
<h3>定义参数</h3>
<p>定义一个<code>参数</code>，可以轻松从外部配置我们的容器，还可以存储全局变量。</p>
<pre><code class="language-PHP">// define some parameters
$container['cookie_name'] = 'SESSION_ID';
$container['session_storage_class'] = 'SessionStorage';
</code></pre>
<p>如果你像下面这样改变<code>session_storage</code>服务的定义 :</p>
<pre><code class="language-PHP">$container['session_storage'] = function ($c) {
    return new $c['session_storage_class']($c['cookie_name']);
};
</code></pre>
<p>就可以通过覆写<code>session_storage</code>的参数(而不是重新定义服务)轻松改变cookie name。</p>
<h3>Protecting Parameters</h3>
<p>由于Pimple把匿名函数视作服务定义，你需要用<code>protect()</code>包装你的匿名函数以把他们存储为<code>parameters</code>:：</p>
<pre><code class="language-PHP">$container['random_func'] = $container-&gt;protect(function () {
    return rand();
});
</code></pre>
<h3>修改Services</h3>
<p>有一些情况下，你也许想在一个服务定义完成之后再进行修改。这可以用<code>extend</code>实现。</p>
<pre><code>$container['session_storage'] = function ($c) {
    return new $c['session_storage_class']($c['cookie_name']);
};

$container-&gt;extend('session_storage', function ($storage, $c) {
    $storage-&gt;...();

    return $storage;
});
</code></pre>
<p>The first argument is the name of the service to extend, the second a function that gets access to the object instance and the container.</p>
<h3>Extending a Container¶</h3>
<p>If you use the same libraries over and over, you might want to reuse some services from one project to the next one;
package your services into a provider by implementing Pimple\ServiceProviderInterface:</p>
<pre><code class="language-PHP">use Pimple\Container;

class FooProvider implements Pimple\ServiceProviderInterface
{
    public function register(Container $pimple)
    {
        // register some services and parameters
        // on $pimple
    }
}
</code></pre>
<p>Then, register the provider on a Container:</p>
<pre><code class="language-PHP">$pimple-&gt;register(new FooProvider());
</code></pre>
<h3>获取服务创建函数</h3>
<p>When you access an object, Pimple automatically calls the anonymous function that you defined,
which creates the service object for you.
If you want to get raw access to this function, you can use the raw() method:</p>
<pre><code class="language-PHP">
$container['session'] = function ($c) {
    return new Session($c['session_storage']);
};

$sessionFunction = $container-&gt;raw('session');
</code></pre>
<h2>Pimple的核心原理</h2>
<p>其实就是类数组操作而已。</p>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <div class="container">
      <div class="container has-text-centered">
        <a href="posts/page23.html">
          Previous
        </a>
        25 of 32
        <a href="posts/page25.html">
          Next
        </a>
      </div>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
      
 // 处理形如 <code>$E=mc^2$</code> 形式的公式
  var inlineMathNodes=document.querySelectorAll('code');
  var re=/^\$(.*)\$$/;
  for(var j=0;j<inlineMathNodes.length;j++){
    var result=re.exec(inlineMathNodes.item(j).innerText);
    if(result!==null){
      katex.render(result[1], inlineMathNodes.item(j));
    }
  }
  function removeNode(node){
    if(node.remove){
      node.remove();
    }else{
      return first.parentNode.removeChild(node);
    }
  };

  // 查找所有 pre code.language-math 节点 以备筛出数据公式
  var nodes=document.querySelectorAll("pre code.language-math");
  for(var i=0;i<nodes.length;i++){
    var node=nodes.item(i);
    // 魔术标记所在行 
    try{
      var lines = node.innerText.split('\n');
      if((!!lines) && lines.length > 0)
      {
        var first = lines[0];
        if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
          var views = "";
          // 逐行渲染
          for(var k=1; k <lines.length; k++){
              var f=lines[k];
              views += katex.renderToString(f);
          }
          // 消除父级嵌套 
          try{
            node.innerHTML=views;
          }catch(e){
            // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
            console.log('IE9 sucks',e);
            $(tr).html(node.innerHTML);
          }
        }
      }
    }
    catch(err){
      console.log(err)
    }
  }
    
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>