<!DOCTYPE html><html>
  <head>

        <script type="text/javascript">
          var wsUri = "ws://localhost:8080/websocket";
      function init()
      {
        websocket = new WebSocket(wsUri);
        websocket.onclose = function(evt) { onClose(evt) };
      }
      function onClose(evt)
      {
        console.log('closing');
        websocket.close();
        document.location.reload();
      }
      window.addEventListener("load", init, false);
      </script>
            <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item" href="">
            Home
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/Compiler/自制编程语言/crowbar源码阅读笔记(5).html">
                    crowbar源码阅读笔记(5):表达式求值
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-08-20
                </p>
              </div>
              <div class="content article-body">
                <p>这是《自制编程语言》一书中的脚本语言<code>crowbar</code>的源码阅读笔记(5):表达式求值。表达式求值的实现代码主要存放于文件<code>eval.c</code>中。</p>
<h2>表达式求值算法的总体框架</h2>
<p>根据表达式的类型的不同，执行不同的求值算法，然后返回一个<code>CRB_Value</code>类型。</p>
<pre><code class="language-c">static CRB_Value eval_expression(CRB_Interpreter *inter, LocalEnvironment *env, Expression *expr)
{
    CRB_Value   v;
    switch (expr-&gt;type) {
    case BOOLEAN_EXPRESSION:
        v = eval_boolean_expression(expr-&gt;u.boolean_value);
        break;
    case INT_EXPRESSION:
        v = eval_int_expression(expr-&gt;u.int_value);
        break;
    case DOUBLE_EXPRESSION:
        v = eval_double_expression(expr-&gt;u.double_value);
        break;
    case STRING_EXPRESSION:
        v = eval_string_expression(inter, expr-&gt;u.string_value);
        break;
    case IDENTIFIER_EXPRESSION:
        v = eval_identifier_expression(inter, env, expr);
        break;
    case ASSIGN_EXPRESSION:
        v = eval_assign_expression(inter, env, expr-&gt;u.assign_expression.variable, expr-&gt;u.assign_expression.operand);
        break;
    case ADD_EXPRESSION:        /* FALLTHRU */
    case SUB_EXPRESSION:        /* FALLTHRU */
    case MUL_EXPRESSION:        /* FALLTHRU */
    case DIV_EXPRESSION:        /* FALLTHRU */
    case MOD_EXPRESSION:        /* FALLTHRU */
    case EQ_EXPRESSION: /* FALLTHRU */
    case NE_EXPRESSION: /* FALLTHRU */
    case GT_EXPRESSION: /* FALLTHRU */
    case GE_EXPRESSION: /* FALLTHRU */
    case LT_EXPRESSION: /* FALLTHRU */
    case LE_EXPRESSION:
        v = crb_eval_binary_expression(inter, env, expr-&gt;type, expr-&gt;u.binary_expression.left, expr-&gt;u.binary_expression.right);
        break;
    case LOGICAL_AND_EXPRESSION:/* FALLTHRU */
    case LOGICAL_OR_EXPRESSION:
        v = eval_logical_and_or_expression(inter, env, expr-&gt;type, expr-&gt;u.binary_expression.left, expr-&gt;u.binary_expression.right);
        break;
    case MINUS_EXPRESSION:
        v = crb_eval_minus_expression(inter, env, expr-&gt;u.minus_expression);
        break;
    case FUNCTION_CALL_EXPRESSION:
        v = eval_function_call_expression(inter, env, expr);
        break;
    case NULL_EXPRESSION:
        v = eval_null_expression();
        break;
    case EXPRESSION_TYPE_COUNT_PLUS_1:  /* FALLTHRU */
    default:
        DBG_panic((&quot;bad case. type..%d\n&quot;, expr-&gt;type));
    }
    return v;
}
</code></pre>
<p>以整型表达式为例，创建一个<code>CRB_Value</code>变量，然后设置其<code>type</code>，填充<code>u</code>成员的<code>int_value</code>字段为指定值：</p>
<!-- more -->
<pre><code class="language-c">static CRB_Value eval_int_expression(int int_value)
{
    CRB_Value   v;

    v.type = CRB_INT_VALUE;
    v.u.int_value = int_value;

    return v;
}
</code></pre>
<p>布尔型表达式求值也是类似的，创建一个<code>CRB_Value</code>变量，然后设置其<code>type</code>，填充<code>u</code>成员的<code>boolean_value</code>字段为指定<code>CRB_Boolean</code>值：</p>
<pre><code class="language-c">static CRB_Value eval_boolean_expression(CRB_Boolean boolean_value)
{
    CRB_Value   v;
    v.type = CRB_BOOLEAN_VALUE;
    v.u.boolean_value = boolean_value;
    return v;
}
</code></pre>
<p>类似的还有浮点型表达式求值、字符串型表达式求值。</p>
<h2>标识符表达式求值</h2>
<pre><code class="language-c">static CRB_Value eval_identifier_expression(CRB_Interpreter *inter, LocalEnvironment *env, Expression *expr)
{
    CRB_Value   v;
    Variable    *vp;

    vp = crb_search_local_variable(env, expr-&gt;u.identifier);
    if (vp != NULL) {
        v = vp-&gt;value;
    } else {
        vp = search_global_variable_from_env(inter, env, expr-&gt;u.identifier);
        if (vp != NULL) {
            v = vp-&gt;value;
        } else {
            crb_runtime_error(expr-&gt;line_number, VARIABLE_NOT_FOUND_ERR,
                              STRING_MESSAGE_ARGUMENT,
                              &quot;name&quot;, expr-&gt;u.identifier,
                              MESSAGE_ARGUMENT_END);
        }
    }
    refer_if_string(&amp;v);

    return v;
}
</code></pre>
<h2>赋值表达式求值</h2>
<p>赋值表达式求值非常简单：</p>
<ul>
<li>先求出等号右部的表达式的值</li>
<li>尝试搜寻指定标识符对应的变量，找不到就在指定环境中创建一个变量。</li>
<li>然后将等号左边的变量值修改为计算出来的值。</li>
</ul>
<pre><code class="language-c">static CRB_Value eval_assign_expression(CRB_Interpreter *inter, LocalEnvironment *env, char *identifier, Expression *expression)
{
    CRB_Value   v;
    Variable    *left;

    v = eval_expression(inter, env, expression);

    left = crb_search_local_variable(env, identifier);
    if (left == NULL) {
        left = search_global_variable_from_env(inter, env, identifier);
    }
    if (left != NULL) {
        release_if_string(&amp;left-&gt;value);
        left-&gt;value = v;
        refer_if_string(&amp;v);
    } else {
        if (env != NULL) {
            crb_add_local_variable(env, identifier, &amp;v);
        } else {
            CRB_add_global_variable(inter, identifier, &amp;v);
        }
        refer_if_string(&amp;v);
    }

    return v;
}
</code></pre>
<h2><code>BinaryExpression</code> 求值</h2>
<p>根据参与运算的<code>left</code>和<code>right</code>类型，又可以分为布尔型、整型、浮点型、字符串型等</p>
<h3>布尔型 <code>BinaryExpression</code></h3>
<p>它的求值方法非常简单，即根据左右表达式是否相等来返回结果：</p>
<pre><code class="language-c">static CRB_Boolean eval_binary_boolean(CRB_Interpreter *inter, ExpressionType operator, CRB_Boolean left, CRB_Boolean right, int line_number)
{
    CRB_Boolean result;

    if (operator == EQ_EXPRESSION) {
        result = left == right;
    } else if (operator == NE_EXPRESSION) {
        result = left != right;
    } else {
        char *op_str = crb_get_operator_string(operator);
        crb_runtime_error(line_number, NOT_BOOLEAN_OPERATOR_ERR, STRING_MESSAGE_ARGUMENT, &quot;operator&quot;, op_str, MESSAGE_ARGUMENT_END);
    }

    return result;
}
</code></pre>
<h3>逻辑<code>BinaryExpression</code>表达式求值</h3>
<p>逻辑表达式总体来说采用的是递归法求解：</p>
<ul>
<li>先递归求解出<code>left_value</code>，根据运算符的不同，判断是否触发短路，是则不再进一步求解</li>
<li>否则，再递归求解出<code>right_value</code></li>
<li>然后根据<code>left_value</code>和<code>right_value</code>求解出最终的值。</li>
</ul>
<pre><code class="language-c">static CRB_Value eval_logical_and_or_expression(CRB_Interpreter *inter, LocalEnvironment *env, ExpressionType operator, Expression *left, Expression *right)
{
    CRB_Value   left_val;
    CRB_Value   right_val;
    CRB_Value   result;
    result.type = CRB_BOOLEAN_VALUE;

    /* left_value 求解 */
    left_val = eval_expression(inter, env, left);

    if (left_val.type != CRB_BOOLEAN_VALUE) { crb_runtime_error(left-&gt;line_number, NOT_BOOLEAN_TYPE_ERR, MESSAGE_ARGUMENT_END); }

    /* 测试是否触发短路逻辑 */
    if (operator == LOGICAL_AND_EXPRESSION) {
        if (!left_val.u.boolean_value) { result.u.boolean_value = CRB_FALSE; return result; }
    } 
    else if (operator == LOGICAL_OR_EXPRESSION) {
        if (left_val.u.boolean_value) { result.u.boolean_value = CRB_TRUE; return result; }
    }
    else {
        DBG_panic((&quot;bad operator..%d\n&quot;, operator));
    }

    /* right_value 求解 */
    right_val = eval_expression(inter, env, right);
    if (right_val.type != CRB_BOOLEAN_VALUE) {
        crb_runtime_error(right-&gt;line_number, NOT_BOOLEAN_TYPE_ERR, MESSAGE_ARGUMENT_END); 
    }

    result.u.boolean_value = right_val.u.boolean_value;
    return result;
}
</code></pre>
<h3>整型 <code>BinaryExpression</code> 求值</h3>
<p>整型表达式的左右表达式均为整型。其求值结果可能是整型，也可能是布尔型。比如：</p>
<ul>
<li><code>3+4</code>这个表达式的结果为整型</li>
<li><code>3&gt;4</code>这个表达式的结果为布尔假值。</li>
</ul>
<p>求值的时候，需要针对每种情况区别对待：</p>
<ul>
<li>当运算符为 <strong>数学运算符</strong>，比如<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>，求值结果整型</li>
<li>当运算符为 <strong>比较运算符</strong>，比如<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>==</code>、<code>!=</code>，求值结果为布尔值。</li>
</ul>
<pre><code class="language-c">static void eval_binary_int(CRB_Interpreter *inter, ExpressionType operator, int left, int right, CRB_Value *result, int line_number) 
{
    if (dkc_is_math_operator(operator)) { result-&gt;type = CRB_INT_VALUE; } 
    else if (dkc_is_compare_operator(operator)) { result-&gt;type = CRB_BOOLEAN_VALUE; } 
    else { DBG_panic((&quot;operator..%d\n&quot;, operator)); }

    switch (operator) {
    case BOOLEAN_EXPRESSION:    /* FALLTHRU */
    case INT_EXPRESSION:        /* FALLTHRU */
    case DOUBLE_EXPRESSION:     /* FALLTHRU */
    case STRING_EXPRESSION:     /* FALLTHRU */
    case IDENTIFIER_EXPRESSION: /* FALLTHRU */
    case ASSIGN_EXPRESSION:
        DBG_panic((&quot;bad case...%d&quot;, operator));
        break;
    case ADD_EXPRESSION:
        result-&gt;u.int_value = left + right;
        break;
    case SUB_EXPRESSION:
        result-&gt;u.int_value = left - right;
        break;
    case MUL_EXPRESSION:
        result-&gt;u.int_value = left * right;
        break;
    case DIV_EXPRESSION:
        result-&gt;u.int_value = left / right;
        break;
    case MOD_EXPRESSION:
        result-&gt;u.int_value = left % right;
        break;
    case LOGICAL_AND_EXPRESSION:        /* FALLTHRU */
    case LOGICAL_OR_EXPRESSION:
        DBG_panic((&quot;bad case...%d&quot;, operator));
        break;
    case EQ_EXPRESSION:
        result-&gt;u.boolean_value = left == right;
        break;
    case NE_EXPRESSION:
        result-&gt;u.boolean_value = left != right;
        break;
    case GT_EXPRESSION:
        result-&gt;u.boolean_value = left &gt; right;
        break;
    case GE_EXPRESSION:
        result-&gt;u.boolean_value = left &gt;= right;
        break;
    case LT_EXPRESSION:
        result-&gt;u.boolean_value = left &lt; right;
        break;
    case LE_EXPRESSION:
        result-&gt;u.boolean_value = left &lt;= right;
        break;
    case MINUS_EXPRESSION:              /* FALLTHRU */
    case FUNCTION_CALL_EXPRESSION:      /* FALLTHRU */
    case NULL_EXPRESSION:               /* FALLTHRU */
    case EXPRESSION_TYPE_COUNT_PLUS_1:  /* FALLTHRU */
    default:
        DBG_panic((&quot;bad case...%d&quot;, operator));
    }
}
</code></pre>
<h3>浮点型 <code>BinaryExpression</code> 求值</h3>
<p>浮点型 <code>BinaryExpression</code> 与整型 <code>BinaryExpression</code> 求值过程类似，根据运算符的类型，要按浮点型和布尔型区别对待。</p>
<pre><code class="language-c">static void eval_binary_double(CRB_Interpreter *inter, ExpressionType operator, double left, double right, CRB_Value *result, int line_number) 
{
    if (dkc_is_math_operator(operator)) { result-&gt;type = CRB_DOUBLE_VALUE; } 
    else if (dkc_is_compare_operator(operator)) { result-&gt;type = CRB_BOOLEAN_VALUE; }
    else { DBG_panic((&quot;operator..%d\n&quot;, operator)); }

    switch (operator) {
    case BOOLEAN_EXPRESSION:    /* FALLTHRU */
    case INT_EXPRESSION:        /* FALLTHRU */
    case DOUBLE_EXPRESSION:     /* FALLTHRU */
    case STRING_EXPRESSION:     /* FALLTHRU */
    case IDENTIFIER_EXPRESSION: /* FALLTHRU */
    case ASSIGN_EXPRESSION:
        DBG_panic((&quot;bad case...%d&quot;, operator));
        break;
    case ADD_EXPRESSION:
        result-&gt;u.double_value = left + right;
        break;
    case SUB_EXPRESSION:
        result-&gt;u.double_value = left - right;
        break;
    case MUL_EXPRESSION:
        result-&gt;u.double_value = left * right;
        break;
    case DIV_EXPRESSION:
        result-&gt;u.double_value = left / right;
        break;
    case MOD_EXPRESSION:
        result-&gt;u.double_value = fmod(left, right);
        break;
    case LOGICAL_AND_EXPRESSION:        /* FALLTHRU */
    case LOGICAL_OR_EXPRESSION:
        DBG_panic((&quot;bad case...%d&quot;, operator));
        break;
    case EQ_EXPRESSION:
        result-&gt;u.int_value = left == right;
        break;
    case NE_EXPRESSION:
        result-&gt;u.int_value = left != right;
        break;
    case GT_EXPRESSION:
        result-&gt;u.int_value = left &gt; right;
        break;
    case GE_EXPRESSION:
        result-&gt;u.int_value = left &gt;= right;
        break;
    case LT_EXPRESSION:
        result-&gt;u.int_value = left &lt; right;
        break;
    case LE_EXPRESSION:
        result-&gt;u.int_value = left &lt;= right;
        break;
    case MINUS_EXPRESSION:              /* FALLTHRU */
    case FUNCTION_CALL_EXPRESSION:      /* FALLTHRU */
    case NULL_EXPRESSION:               /* FALLTHRU */
    case EXPRESSION_TYPE_COUNT_PLUS_1:  /* FALLTHRU */
    default:
        DBG_panic((&quot;bad default...%d&quot;, operator));
    }
}
</code></pre>
<h3>通用<code>BinaryExpression</code>的求值策略</h3>
<p>通用的<code>BinaryExpression</code>策略是采用递归法求解的：</p>
<ul>
<li>先递归求解<code>left</code>表达式的值<code>left_value</code></li>
<li>再递归求解<code>right</code>表达式的值<code>right_value</code></li>
<li>然后根据<code>left_value</code>和<code>right_value</code>的具体类型，分情况求解出最终的值。</li>
</ul>
<pre><code class="language-c">CRB_Value crb_eval_binary_expression(CRB_Interpreter *inter, LocalEnvironment *env, ExpressionType operator, Expression *left, Expression *right)
{
    CRB_Value   left_val;
    CRB_Value   right_val;
    CRB_Value   result;

    left_val = eval_expression(inter, env, left);
    right_val = eval_expression(inter, env, right);

    /* 整型 BinaryExpression 求解 */
    if (left_val.type == CRB_INT_VALUE &amp;&amp; right_val.type == CRB_INT_VALUE) {
        eval_binary_int(inter, operator, left_val.u.int_value, right_val.u.int_value, &amp;result, left-&gt;line_number);
    } 
    /* 浮点型 BinaryExpression */
    else if (left_val.type == CRB_DOUBLE_VALUE &amp;&amp; right_val.type == CRB_DOUBLE_VALUE) {
        eval_binary_double(inter, operator, left_val.u.double_value, right_val.u.double_value, &amp;result, left-&gt;line_number);
    }
    /* 浮点型 BinaryExpression */
    else if (left_val.type == CRB_INT_VALUE &amp;&amp; right_val.type == CRB_DOUBLE_VALUE) {
        left_val.u.double_value = left_val.u.int_value;
        eval_binary_double(inter, operator, left_val.u.double_value, right_val.u.double_value, &amp;result, left-&gt;line_number);
    }
    /* 浮点型 BinaryExpression */
    else if (left_val.type == CRB_DOUBLE_VALUE &amp;&amp; right_val.type == CRB_INT_VALUE) {
        right_val.u.double_value = right_val.u.int_value;
        eval_binary_double(inter, operator, left_val.u.double_value, right_val.u.double_value, &amp;result, left-&gt;line_number);
    }
    /* 布尔型 BinaryExpression */
    else if (left_val.type == CRB_BOOLEAN_VALUE &amp;&amp; right_val.type == CRB_BOOLEAN_VALUE) {
        result.type = CRB_BOOLEAN_VALUE;
        result.u.boolean_value = eval_binary_boolean(inter, operator, left_val.u.boolean_value, right_val.u.boolean_value, left-&gt;line_number);
    } 
    /* 字符串拼接 */
    else if (left_val.type == CRB_STRING_VALUE &amp;&amp; operator == ADD_EXPRESSION) {
        char    buf[LINE_BUF_SIZE];
        CRB_String *right_str;

        if (right_val.type == CRB_INT_VALUE) {
            sprintf(buf, &quot;%d&quot;, right_val.u.int_value);
            right_str = crb_create_crowbar_string(inter, MEM_strdup(buf));
        } else if (right_val.type == CRB_DOUBLE_VALUE) {
            sprintf(buf, &quot;%f&quot;, right_val.u.double_value);
            right_str = crb_create_crowbar_string(inter, MEM_strdup(buf));
        } else if (right_val.type == CRB_BOOLEAN_VALUE) {
            if (right_val.u.boolean_value) {
                right_str = crb_create_crowbar_string(inter, MEM_strdup(&quot;true&quot;));
            } else {
                right_str = crb_create_crowbar_string(inter, MEM_strdup(&quot;false&quot;));
            }
        } else if (right_val.type == CRB_STRING_VALUE) {
            right_str = right_val.u.string_value;
        } else if (right_val.type == CRB_NATIVE_POINTER_VALUE) {
            sprintf(buf, &quot;(%s:%p)&quot;, right_val.u.native_pointer.info-&gt;name, right_val.u.native_pointer.pointer);
            right_str = crb_create_crowbar_string(inter, MEM_strdup(buf));
        } else if (right_val.type == CRB_NULL_VALUE) {
            right_str = crb_create_crowbar_string(inter, MEM_strdup(&quot;null&quot;));
        } 
        result.type = CRB_STRING_VALUE;
        result.u.string_value = chain_string(inter, left_val.u.string_value, right_str);
    }
    /* 字符串比较大小 */
    else if (left_val.type == CRB_STRING_VALUE &amp;&amp; right_val.type == CRB_STRING_VALUE) {
        result.type = CRB_BOOLEAN_VALUE;
        result.u.boolean_value = eval_compare_string(operator, &amp;left_val, &amp;right_val, left-&gt;line_number);
    }
    /* 空值 */
    else if (left_val.type == CRB_NULL_VALUE || right_val.type == CRB_NULL_VALUE) {
        result.type = CRB_BOOLEAN_VALUE;
        result.u.boolean_value = eval_binary_null(inter, operator, &amp;left_val, &amp;right_val, left-&gt;line_number);
    } 
    /* 报错 */
    else {
        char *op_str = crb_get_operator_string(operator);
        crb_runtime_error(left-&gt;line_number, BAD_OPERAND_TYPE_ERR, STRING_MESSAGE_ARGUMENT, &quot;operator&quot;, op_str, MESSAGE_ARGUMENT_END);
    }

    return result;
}
</code></pre>
<h2>函数调用表达式求值</h2>
<p>函数调用表达式根据函数类型分为两种， <strong>原生函数调用</strong> 和 <strong>crowbar函数调用</strong> ，根据函数类型的不同，再选择性地调用<code>call_native_function()</code>或<code>call_crowbar_function()</code>:</p>
<pre><code class="language-c">static CRB_Value eval_function_call_expression(CRB_Interpreter *inter, LocalEnvironment *env, Expression *expr)
{
    CRB_Value           value;
    FunctionDefinition  *func;
    
    char *identifier = expr-&gt;u.function_call_expression.identifier;

    func = crb_search_function(identifier);
    if (func == NULL) {
        crb_runtime_error(expr-&gt;line_number, FUNCTION_NOT_FOUND_ERR, STRING_MESSAGE_ARGUMENT, &quot;name&quot;, identifier, MESSAGE_ARGUMENT_END);
    }
    switch (func-&gt;type) {
        case CROWBAR_FUNCTION_DEFINITION:
            value = call_crowbar_function(inter, env, expr, func);
            break;
        case NATIVE_FUNCTION_DEFINITION:
            value = call_native_function(inter, env, expr, func-&gt;u.native_f.proc);
            break;
        default:
            DBG_panic((&quot;bad case..%d\n&quot;, func-&gt;type));
    }

    return value;
}
</code></pre>
<p>原生函数调用的求值过程非常简单，因为原生函数实际上<code>C</code>语言编写的封装类型，通过指针，就可以直接调用：</p>
<pre><code class="language-c">static CRB_Value call_native_function(CRB_Interpreter *inter, LocalEnvironment *env, Expression *expr, CRB_NativeFunctionProc *proc)
{
    CRB_Value   value;
    int         arg_count;
    ArgumentList        *arg_p;
    CRB_Value   *args;
    int         i;

    /* 原生函数的参数个数 */
    for (arg_count = 0, arg_p = expr-&gt;u.function_call_expression.argument;
         arg_p; arg_p = arg_p-&gt;next) {
        arg_count++;
    }

    /* 原生函数的参数数组 */
    args = MEM_malloc(sizeof(CRB_Value) * arg_count);
    for (arg_p = expr-&gt;u.function_call_expression.argument, i = 0; arg_p; arg_p = arg_p-&gt;next, i++)
    {
        args[i] = eval_expression(inter, env, arg_p-&gt;expression);
    }

    /* 通过函数指针调用原生函数 */
    value = proc(inter, arg_count, args);

    /* 释放参数数组的内存 */
    for (i = 0; i &lt; arg_count; i++) {
        release_if_string(&amp;args[i]);
    }
    MEM_free(args);

    return value;
}
</code></pre>
<p>而利用<code>crowbar</code>脚本语言编写的脚本，则相对复杂一点；</p>
<ul>
<li>要为函数创建一个局部环境，然后把相关参数注册到该环境中，</li>
<li>然后再执行函数体中的语句列表</li>
<li>最后释放局部环境并返回最终结果</li>
</ul>
<pre><code class="language-c">static CRB_Value call_crowbar_function(CRB_Interpreter *inter, LocalEnvironment *env, Expression *expr, FunctionDefinition *func)
{
    CRB_Value   value;
    StatementResult     result;
    ArgumentList        *arg_p;
    ParameterList       *param_p;
    LocalEnvironment    *local_env;

    /* 创建一个局部环境，把相关参数添加到该局部环境中 */
    local_env = alloc_local_environment();
    for(arg_p = expr-&gt;u.function_call_expression.argument, param_p = func-&gt;u.crowbar_f.parameter; 
        arg_p;
        arg_p = arg_p-&gt;next, param_p = param_p-&gt;next) 
    {
        CRB_Value arg_val;

        if (param_p == NULL) {
            crb_runtime_error(expr-&gt;line_number, ARGUMENT_TOO_MANY_ERR, MESSAGE_ARGUMENT_END);
        }
        arg_val = eval_expression(inter, env, arg_p-&gt;expression);
        crb_add_local_variable(local_env, param_p-&gt;name, &amp;arg_val);
    }
    if (param_p) {
        crb_runtime_error(expr-&gt;line_number, ARGUMENT_TOO_FEW_ERR, MESSAGE_ARGUMENT_END);
    }

    /* 执行函数体 */
    result = crb_execute_statement_list(inter, local_env, func-&gt;u.crowbar_f.block -&gt;statement_list);

    if (result.type == RETURN_STATEMENT_RESULT) { value = result.u.return_value; } 
    else { value.type = CRB_NULL_VALUE; }

    dispose_local_environment(inter, local_env);

    return value;
}
</code></pre>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
      
 // 处理形如 <code>$E=mc^2$</code> 形式的公式
  var inlineMathNodes=document.querySelectorAll('code');
  var re=/^\$(.*)\$$/;
  for(var j=0;j<inlineMathNodes.length;j++){
    var result=re.exec(inlineMathNodes.item(j).innerText);
    if(result!==null){
      katex.render(result[1], inlineMathNodes.item(j));
    }
  }
  function removeNode(node){
    if(node.remove){
      node.remove();
    }else{
      return first.parentNode.removeChild(node);
    }
  };

  // 查找所有 pre code.language-math 节点 以备筛出数据公式
  var nodes=document.querySelectorAll("pre code.language-math");
  for(var i=0;i<nodes.length;i++){
    var node=nodes.item(i);
    // 魔术标记所在行 
    try{
      var lines = node.innerText.split('\n');
      if((!!lines) && lines.length > 0)
      {
        var first = lines[0];
        if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
          var views = "";
          // 逐行渲染
          for(var k=1; k <lines.length; k++){
              var f=lines[k];
              views += katex.renderToString(f);
          }
          // 消除父级嵌套 
          try{
            node.innerHTML=views;
          }catch(e){
            // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
            console.log('IE9 sucks',e);
            $(tr).html(node.innerHTML);
          }
        }
      }
    }
    catch(err){
      console.log(err)
    }
  }
    
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>