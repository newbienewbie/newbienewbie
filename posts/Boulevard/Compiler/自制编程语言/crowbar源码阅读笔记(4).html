<!DOCTYPE html><html>
  <head>

        <script type="text/javascript">
          var wsUri = "ws://localhost:8080/websocket";
      function init()
      {
        websocket = new WebSocket(wsUri);
        websocket.onclose = function(evt) { onClose(evt) };
      }
      function onClose(evt)
      {
        console.log('closing');
        websocket.close();
        document.location.reload();
      }
      window.addEventListener("load", init, false);
      </script>
            <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="/style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="/">
            <img src="/images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item" href="/">
            Home
          </a>
          <a class="navbar-item" href="/about.html">
            About
          </a>
          <a class="navbar-item" href="/contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="/posts/Boulevard/Compiler/自制编程语言/crowbar源码阅读笔记(4).html">
                    crowbar源码阅读笔记(4):语句构建
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-08-20
                </p>
              </div>
              <div class="content article-body">
                <p>这是《自制编程语言》一书中的脚本语言<code>crowbar</code>的源码阅读笔记(4):语句构建</p>
<h2>语句、语句表、与语句块的结构表示</h2>
<p>如<a href="/2017/08/18/Boulevard/Compiler/%E8%87%AA%E5%88%B6%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/crowbar%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%281%29">《crowbar源码阅读笔记(1):基本的数据结构》</a>中所述，<strong>语句</strong> 、<strong>语句表</strong> 、<strong>语句块</strong> 可以抽象为：</p>
<pre><code class="language-c">struct Statement_tag {
    StatementType       type;
    int                 line_number;
    union {
        Expression      *expression_s;
        GlobalStatement global_s;
        IfStatement     if_s;
        WhileStatement  while_s;
        ForStatement    for_s;
        ReturnStatement return_s;
    } u;
};

typedef struct StatementList_tag {
    Statement   *statement;
    struct StatementList_tag    *next;
} StatementList;

typedef struct {
    StatementList       *statement_list;
} Block;
</code></pre>
<!-- more -->
<h2>语句、语句链表、与语句块的构建机理</h2>
<p>和创建表达式类似，创建语句的时候，也需要申请在内存中开辟一段空间：</p>
<pre><code class="language-c">static Statement * alloc_statement(StatementType type)
{
    Statement *st;
    st = crb_malloc(sizeof(Statement));
    st-&gt;type = type;
    st-&gt;line_number = crb_get_current_interpreter()-&gt;current_line_number;
    return st;
}
</code></pre>
<p>开辟内存之后，再在其中填充<code>Statement</code>结构成员(类型、行号)；最后针对要创建的具体语句类型，填充<code>u</code>成员的特定字段。</p>
<p>语句表是用链表实现的，每个节点都包含一个<code>statement</code>成员指向相应语句和一个<code>next</code>成员指向下一个节点。故创建一个语句表的实现即为申请分配一个<code>StatementList</code>结构体大小的内存空间，然后将其<code>statement</code>成员初始化为指定的语句指针即可：</p>
<pre><code class="language-c">StatementList * crb_create_statement_list(Statement *statement)
{
    StatementList *sl;
    /* 申请开辟一段内存 */
    sl = crb_malloc(sizeof(StatementList));
    
    /* 设置语句链表的第一个节点为指定的语句 */
    sl-&gt;statement = statement;
    /* 把下一个节点初始化为NULL */
    sl-&gt;next = NULL;

    return sl;
}
</code></pre>
<p>仅仅能创建语句链表还不够方便，我们还需要随时可以给某个链表添加语句的功能，与新增变量会放到相关环境中第一个节点不同，新增的语句会作为最后一个节点追加到指定语句链表上：</p>
<pre><code class="language-c">StatementList * crb_chain_statement_list(StatementList *list, Statement *statement)
{
    StatementList *pos;

    if (list == NULL)
        return crb_create_statement_list(statement);

    /* 跳到链表的最后一个节点 */
    for (pos = list; pos-&gt;next; pos = pos-&gt;next)
        ;
    /* 追加新的语句 */
    pos-&gt;next = crb_create_statement_list(statement);

    return list;
}
</code></pre>
<p>构建语句块的过程也要先申请开辟内存，然后填充<code>Block</code>结构——把<code>statement_list</code>成员指向相关的语句表即可：</p>
<pre><code class="language-c">Block * crb_create_block(StatementList *statement_list)
{
    Block *block;

    block = crb_malloc(sizeof(Block));
    block-&gt;statement_list = statement_list;

    return block;
}
</code></pre>
<h2>与关键字相关的语句创建</h2>
<h3>分支判断语句创建</h3>
<p><code>crowbar</code>语言所支持的<code>if</code>语句的语法格式类似于：</p>
<pre><code class="language-ruby"># condition
if(condition)
# then block
{
}
# elsif list
elsif(){
    # ...
}
# else block
else{
    # ...
}
</code></pre>
<p>所以创建<code>if</code>语句的实现思路为先申请开辟一段内存存放<code>Statement</code>结构体，然后填充<code>u</code>成员<code>if_s</code>的相关字段:</p>
<pre><code class="language-c">Statement * crb_create_if_statement(Expression *condition, Block *then_block, Elsif *elsif_list, Block *else_block)
{
    Statement *st;
    st = alloc_statement(IF_STATEMENT);

    st-&gt;u.if_s.condition = condition;
    st-&gt;u.if_s.then_block = then_block;
    st-&gt;u.if_s.elsif_list = elsif_list;
    st-&gt;u.if_s.else_block = else_block;

    return st;
}
</code></pre>
<h3>循环语句创建：</h3>
<p><code>crowbar</code>语言支持<code>while</code>语句，其语法类似于：</p>
<pre><code class="language-ruby">while(condition)
{
    # block 
}
</code></pre>
<p>创建<code>while</code>语句的实现为先申请开辟一段内存存放<code>Statement</code>结构体，然后填充<code>u</code>成员<code>while_s</code>的相关字段：</p>
<pre><code class="language-c">Statement * crb_create_while_statement(Expression *condition, Block *block)
{
    Statement *st;
    st = alloc_statement(WHILE_STATEMENT);

    st-&gt;u.while_s.condition = condition;
    st-&gt;u.while_s.block = block;

    return st;
}
</code></pre>
<p>创建<code>for</code>循环语句与之类似：</p>
<pre><code>Statement * crb_create_for_statement(Expression *init, Expression *cond, Expression *post, Block *block)
{
    Statement *st;
    st = alloc_statement(FOR_STATEMENT);

    st-&gt;u.for_s.init = init;
    st-&gt;u.for_s.condition = cond;
    st-&gt;u.for_s.post = post;
    st-&gt;u.for_s.block = block;

    return st;
}
</code></pre>
<p>与循环相关的还有<code>break</code>和<code>continue</code>语句。由于不涉及其他信息，其实现非常简单，并不填充<code>Statement</code>的<code>u</code>字段：</p>
<pre><code class="language-c">Statement *crb_create_break_statement(void)
{
    return alloc_statement(BREAK_STATEMENT);
}

Statement *crb_create_continue_statement(void)
{
    return alloc_statement(CONTINUE_STATEMENT);
}
</code></pre>
<h3><code>return</code>语句</h3>
<p>创建<code>return</code>语句：</p>
<pre><code class="language-c">Statement * crb_create_return_statement(Expression *expression)
{
    Statement *st;
    st = alloc_statement(RETURN_STATEMENT);

    st-&gt;u.return_s.return_value = expression;

    return st;
}
</code></pre>
<h2>其他语句</h2>
<p>这类结构较为简单。</p>
<h3>表达式语句的创建</h3>
<pre><code class="language-c">Statement * crb_create_expression_statement(Expression *expression)
{
    Statement *st;
    st = alloc_statement(EXPRESSION_STATEMENT);

    st-&gt;u.expression_s = expression;

    return st;
}
</code></pre>
<h3>全局语句的创建</h3>
<pre><code class="language-c">Statement * crb_create_global_statement(IdentifierList *identifier_list)
{
    Statement *st;

    st = alloc_statement(GLOBAL_STATEMENT);
    st-&gt;u.global_s.identifier_list = identifier_list;

    return st;
}
</code></pre>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
      
 // 处理形如 <code>$E=mc^2$</code> 形式的公式
  var inlineMathNodes=document.querySelectorAll('code');
  var re=/^\$(.*)\$$/;
  for(var j=0;j<inlineMathNodes.length;j++){
    var result=re.exec(inlineMathNodes.item(j).innerText);
    if(result!==null){
      katex.render(result[1], inlineMathNodes.item(j));
    }
  }
  function removeNode(node){
    if(node.remove){
      node.remove();
    }else{
      return first.parentNode.removeChild(node);
    }
  };

  // 查找所有 pre code.language-math 节点 以备筛出数据公式
  var nodes=document.querySelectorAll("pre code.language-math");
  for(var i=0;i<nodes.length;i++){
    var node=nodes.item(i);
    // 魔术标记所在行 
    try{
      var lines = node.innerText.split('\n');
      if((!!lines) && lines.length > 0)
      {
        var first = lines[0];
        if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
          var views = "";
          // 逐行渲染
          for(var k=1; k <lines.length; k++){
              var f=lines[k];
              views += katex.renderToString(f);
          }
          // 消除父级嵌套 
          try{
            node.innerHTML=views;
          }catch(e){
            // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
            console.log('IE9 sucks',e);
            $(tr).html(node.innerHTML);
          }
        }
      }
    }
    catch(err){
      console.log(err)
    }
  }
    
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>