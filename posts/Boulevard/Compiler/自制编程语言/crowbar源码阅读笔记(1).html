<!DOCTYPE html><html>
  <head>
    <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie/"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item" href="">
            Home
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/Compiler/自制编程语言/crowbar源码阅读笔记(1).html">
                    crowbar源码阅读笔记(1):基本的数据结构
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-08-18
                </p>
              </div>
              <div class="content article-body">
                <p>这是《自制编程语言》一书中的脚本语言<code>crowbar</code>的源码阅读笔记(1):基本的数据结构。</p>
<p><code>crowbar</code>语言由<code>C</code>语言编写，分为以下三个独立模块:</p>
<ul>
<li><code>CRB</code>：<code>crowbar</code> 主程序</li>
<li><code>MEM</code>: 通用内存管理模块，源码位于<code>memory/</code>目录下</li>
<li><code>DBG</code>: 通用<code>Debug</code>模块，源码位于<code>debug/</code>目录下</li>
</ul>
<h2><code>CRB</code>解释器接口</h2>
<p><code>CRB.h</code>是解释器的接口文件：</p>
<pre><code class="language-c">/* 创建解释器 */
CRB_Interpreter *CRB_create_interpreter(void);

/* 使用解释器编译文件 */
void CRB_compile(CRB_Interpreter *interpreter, FILE *fp);

/* 使用解释器解释 */
void CRB_interpret(CRB_Interpreter *interpreter);

/* 回收解释器 */
void CRB_dispose_interpreter(CRB_Interpreter *interpreter);
</code></pre>
<h2><code>CRB</code>解释器扩展接口</h2>
<p>为了扩展解释器，可以使用解释器的开发接口：<code>CRB_dev.h</code>。这个接口规定了<code>crowbar</code>这门语言的值类型和扩展接口。</p>
<!-- more -->
<h3>值类型</h3>
<p><code>crowbar</code>中可用的类型包括布尔型、整型、浮点型、字符串型、原生指针型、和空引用型：</p>
<pre><code class="language-c">typedef enum {
    CRB_BOOLEAN_VALUE = 1,
    CRB_INT_VALUE,
    CRB_DOUBLE_VALUE,
    CRB_STRING_VALUE,
    CRB_NATIVE_POINTER_VALUE,
    CRB_NULL_VALUE
} CRB_ValueType;
</code></pre>
<p><code>crowbar</code>中变量可以是其中任意一种类型，为了表示变量的值，可以把“值”定义为:</p>
<pre><code class="language-c">typedef struct {
    CRB_ValueType       type;
    union {
        CRB_Boolean     boolean_value;
        int             int_value;
        double          double_value;
        CRB_String      *string_value;
        CRB_NativePointer       native_pointer;
    } u;
} CRB_Value;
</code></pre>
<h3>扩展接口</h3>
<p>要为这门语言开发功能，需要使用扩展接口，<code>CRB</code>提供了以下三个函数：</p>
<pre><code class="language-c">/* 代表能返回 CRB_Value 的函数 */
typedef CRB_Value CRB_NativeFunctionProc(CRB_Interpreter *interpreter, int arg_count, CRB_Value *args);

/* 注册函数到解释器 */
void CRB_add_native_function(CRB_Interpreter *interpreter, char *name, CRB_NativeFunctionProc *proc);
/* 注册全局变量到解释器*/
void CRB_add_global_variable(CRB_Interpreter *inter, char *identifier, CRB_Value *value);
</code></pre>
<h2><code>CRB</code> 解释器</h2>
<p><code>CRB</code>解释器相关定义位于<code>crowbar.h</code>中，规定了一些列语言相关的数据结构：</p>
<ul>
<li>解释器、编译错误、运行时错误、消息参数类型、消息格式、</li>
<li>变量、标识符列表、局部环境、全局变量引用</li>
<li>表达式类型、表达式、赋值表达式、二叉表达式、函数调用表达式、</li>
<li>语句类型、语句、语句列表、块、语句结果类型、语句结果、if语句、while语句、for语句、return语句、全局语句</li>
<li>函数定义、参数列表(链表)</li>
<li>String、String Pool</li>
</ul>
<p>其中最重要的是解释器<code>CRB_Interpreter</code>：</p>
<pre><code class="language-c">struct CRB_Interpreter_tag {
    /* 在解释器生成时生成，解释器废弃时释放 */
    MEM_Storage         interpreter_storage;
    /* 运行时的存储  */
    MEM_Storage         execute_storage;
    /* 全局变量 链表 */
    Variable            *variable;
    /* 函数定义 链表 */
    FunctionDefinition  *function_list;
    /* 语句 链表 */
    StatementList       *statement_list;
    /* 当前行号 */
    int                 current_line_number;
};
</code></pre>
<h2>变量</h2>
<p>其中，<code>Varible</code>实际上指的是全局变量链表：</p>
<pre><code class="language-c">typedef struct Variable_tag {
    char        *name;
    CRB_Value   value;
    struct Variable_tag *next;
} Variable;
</code></pre>
<p>变量都很简单，自身拥有两个属性：</p>
<ul>
<li>变量名：即标识符。</li>
<li>变量值：统一为<code>CRB_Value</code>类型。</li>
</ul>
<p><code>crowbar</code>以链表的形式组织变量，依次取<code>next</code>指针即可遍历。</p>
<p>在此变量基础上，就可以表示出全局变量变量链表和局部环境:</p>
<pre><code class="language-c">typedef struct GlobalVariableRef_tag {
    Variable    *variable;
    struct GlobalVariableRef_tag *next;
} GlobalVariableRef;

typedef struct {
    Variable    *variable;
    GlobalVariableRef   *global_variable;
} LocalEnvironment;
</code></pre>
<p>变量解析即是从相应环境（局部、全局）中寻找标识符的过程，由于<code>crowbar</code>采用了链表的组织方式，其的实现机理也是直接在相应环境中从头开始遍历<code>Varible</code>链表，检查链表相应节点的变量名是否和相应的标识符一致：</p>
<pre><code class="language-c">Variable * crb_search_local_variable(LocalEnvironment *env, char *identifier);
Variable * crb_search_global_variable(CRB_Interpreter *inter, char *identifier);
</code></pre>
<h3>表达式</h3>
<p>表达式的数据结构为：</p>
<pre><code class="language-c">struct Expression_tag {
    ExpressionType type;
    int line_number;
    union {
        CRB_Boolean             boolean_value;
        int                     int_value;
        double                  double_value;
        char                    *string_value;
        char                    *identifier;
        AssignExpression        assign_expression;
        BinaryExpression        binary_expression;
        Expression              *minus_expression;
        FunctionCallExpression  function_call_expression;
    } u;
};
</code></pre>
<p>表达式有多种，比如赋值表达式：</p>
<pre><code class="language-c">typedef struct {
    char        *variable;
    Expression  *operand;
} AssignExpression;
</code></pre>
<p>二叉表达式：</p>
<pre><code class="language-c">typedef struct {
    Expression  *left;
    Expression  *right;
} BinaryExpression;
</code></pre>
<p>函数调用表达式:</p>
<pre><code class="language-c">typedef struct {
    char                *identifier;
    ArgumentList        *argument;
} FunctionCallExpression;
</code></pre>
<h3>语句、语句列表、及块</h3>
<h4>对语句、语句列表及块的抽象表示</h4>
<p>一个语句可能是表达式语句、全局语句、<code>if</code>语句、<code>while</code>语句、<code>for</code>语句、<code>return</code>语句。故可以把语句抽象为：</p>
<pre><code class="language-c">struct Statement_tag {
    StatementType       type;
    int                 line_number;
    union {
        Expression      *expression_s;
        GlobalStatement global_s;
        IfStatement     if_s;
        WhileStatement  while_s;
        ForStatement    for_s;
        ReturnStatement return_s;
    } u;
};
</code></pre>
<p>在此基础上，可以抽象出语句链表：</p>
<pre><code class="language-c">typedef struct StatementList_tag {
    Statement   *statement;
    struct StatementList_tag    *next;
} StatementList;
</code></pre>
<p>而一系列语句列表可以构成块：</p>
<pre><code class="language-c">typedef struct {
    StatementList       *statement_list;
} Block;
</code></pre>
<h4>具体分类的语句的定义</h4>
<p>不同的语句有不同的特征，需要为具体类型的语句定义特定的成员。比如<code>if</code>语句为：</p>
<pre><code class="language-c">typedef struct {
    Expression  *condition;
    Block       *then_block;
    Elsif       *elsif_list;
    Block       *else_block;
} IfStatement;
</code></pre>
<p>而用于循环的<code>while</code>语句：</p>
<pre><code class="language-c">typedef struct {
    Expression  *condition;
    Block       *block;
} WhileStatement;
</code></pre>
<p><code>for</code>语句：</p>
<pre><code class="language-c">typedef struct {
    Expression  *init;
    Expression  *condition;
    Expression  *post;
    Block       *block;
} ForStatement;
</code></pre>
<p><code>return</code>用于返回一个表达式的值：</p>
<pre><code class="language-c">typedef struct {
    Expression *return_value;
} ReturnStatement;
</code></pre>
<h3>函数定义构成的链表</h3>
<p>在定义函数之前，先要抽象出参数链表:</p>
<pre><code class="language-c">typedef struct ArgumentList_tag {
    Expression *expression;
    struct ArgumentList_tag *next;
} ArgumentList;
</code></pre>
<p>函数分为<code>CROWBAR_FUNCTION</code>和<code>NATIVE_FUNCTION</code>两种。对于前者，函数定义由参数链表和<code>block</code>构成。对于后者，实际上由<code>C</code>语言写就，故可以用一个函数指针来表示。</p>
<pre><code class="language-c">typedef struct FunctionDefinition_tag {
    char                       *name;
    FunctionDefinitionType      type;
    union {
        struct {
            ParameterList       *parameter;
            Block               *block;
        } crowbar_f;
        struct {
            CRB_NativeFunctionProc      *proc;
        } native_f;
    } u;
    struct FunctionDefinition_tag       *next;
} FunctionDefinition;
</code></pre>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
      
 // 处理形如 <code>$E=mc^2$</code> 形式的公式
  var inlineMathNodes=document.querySelectorAll('code');
  var re=/^\$(.*)\$$/;
  for(var j=0;j<inlineMathNodes.length;j++){
    var result=re.exec(inlineMathNodes.item(j).innerText);
    if(result!==null){
      katex.render(result[1], inlineMathNodes.item(j));
    }
  }
  function removeNode(node){
    if(node.remove){
      node.remove();
    }else{
      return first.parentNode.removeChild(node);
    }
  };

  // 查找所有 pre code.language-math 节点 以备筛出数据公式
  var nodes=document.querySelectorAll("pre code.language-math");
  for(var i=0;i<nodes.length;i++){
    var node=nodes.item(i);
    // 魔术标记所在行 
    try{
      var lines = node.innerText.split('\n');
      if((!!lines) && lines.length > 0)
      {
        var first = lines[0];
        if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
          var views = "";
          // 逐行渲染
          for(var k=1; k <lines.length; k++){
              var f=lines[k];
              views += katex.renderToString(f);
          }
          // 消除父级嵌套 
          try{
            node.innerHTML=views;
          }catch(e){
            // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
            console.log('IE9 sucks',e);
            $(tr).html(node.innerHTML);
          }
        }
      }
    }
    catch(err){
      console.log(err)
    }
  }
    
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>