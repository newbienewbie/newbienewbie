<!DOCTYPE html><html>
  <head>

        <script type="text/javascript">
          var wsUri = "ws://localhost:8080/websocket";
      function init()
      {
        websocket = new WebSocket(wsUri);
        websocket.onclose = function(evt) { onClose(evt) };
      }
      function onClose(evt)
      {
        console.log('closing');
        websocket.close();
        document.location.reload();
      }
      window.addEventListener("load", init, false);
      </script>
            <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item is-active" href="">
            Home
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/PHP/WordPress/model-layer/Model-Layer.html">
                    WordPress Model Layer
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2015-04-10
                </p>
              </div>
              <div class="content article-body">
                <p>WordPress虽说并不和现代的MVC模式一致,但是也有独立的数据库操作层。</p>
<h1>全局对象$wpdb</h1>
<p>有一个全局对象$wpdb 作为WPINC/wp-db.php中的wpdb类实例对象。该类是
<code> WordPress Database Access Abstraction</code>。</p>
<p>可以用其他的类替换之。</p>
<h2>Adding Data</h2>
<p>利用$wpdb-&gt;insert()方法，此方法接受三个参赛：</p>
<ol>
<li>表名</li>
<li>数组，字段的名和值对组成的数组</li>
<li>数组，可选的格式</li>
</ol>
<pre><code class="language-PHP">$wpdb-&gt;insert(
   $wpdb-&gt;posts,
   array(
       'post_title'=&gt;'xx',
       'post_content'=&gt;'xx',
       'post_type'=&gt;'xx',
   ),
   array(&quot;%s&quot;,%s&quot;,&quot;%s&quot;)
);
</code></pre>
<h2>update</h2>
<p>利用$wpdb-&gt;update()方法，此方法接受5个参数：</p>
<ol>
<li>表名</li>
<li>新记录的数组表示，由各字段的名/值对组成的数组</li>
<li>where条件数组</li>
<li>数组,每个元素表示新记录中的值的格式</li>
<li>数组，表示where条件数组的格式</li>
</ol>
<pre><code class="language-PHP">$wpdb-&gt;update(
    $wpdb-&gt;posts,
    array(
       'post_title'=&gt;'new',
       'post_content'=&gt;'new',
       'post_type'=&gt;'new',
    ),
    array(
       'ID'=&gt;$post_id,
    ),
    array(&quot;%s&quot;,&quot;%s&quot;),
    array(&quot;%s&quot;)
);
</code></pre>
<h2>Delete</h2>
<p>$wpdb-&gt;delte()方法可以用来删除行记录。 原型为</p>
<pre><code class="language-PHP">public function delete( $table, $where, $where_format = null ) 
</code></pre>
<p>例如：</p>
<pre><code class="language-PHP">$wpdb-&gt;delete( 'table', array( 'ID' =&gt; 1 ), array( '%d' ) );
</code></pre>
<h2>Retrieving</h2>
<h3>获取单个值</h3>
<pre><code class="language-PHP">$post_id=$wpdb-&gt;get_var(
    &quot;select ID from &quot;.$wpdb-&gt;posts.&quot; where post_author=1 limit 1&quot;
);
</code></pre>
<h3>获取一列值</h3>
<pre><code class="language-PHP">$wpdb-&gt;get_col(
    &quot;select ID from &quot;.$wpdb-&gt;posts.&quot; where post_author=1 &quot;,
    ARRAY_A    # NULL|ARRAY_A|ARRAY_N,默认为object格式的返回值，
);
</code></pre>
<h3>获取一行值</h3>
<pre><code class="language-PHP">$wpdb-&gt;get_row(
    &quot;select * from &quot;.$wpdb-&gt;users.&quot; where ID=43;&quot;,
    ARRAY_N    #NULL|ARRAY_A|ARRAY_N
);
</code></pre>
<h3>获取完整的数据集</h3>
<pre><code class="language-PHP">$wpdb-&gt;get_results(
    &quot;select * from &quot;.$wpdb-&gt;users.a&quot;,
    ARRAY_N    #NULL|ARRAY_A|ARRAY_N
);
</code></pre>
<h2>执行查询</h2>
<pre><code class="language-PHP">$wpdb-&gt;query(string SqlString);
</code></pre>
<h2>SQL 注入与防御</h2>
<p>WordPress 使用<code>$wpdb-&gt;prepare()</code>防御SQL注入。此方法使用PHP printf()函数的语法为字段进行代换，
如同printf()那样，这里的占位符也可以使用排序索引。</p>
<pre><code>$sanitized_sql=$wpdb-&gt;prepare(
    &quot;'insert into my_plugin_table set field1=%1$d,$field2=$2$s,$field=%3$s,32',32,'Barzell','Washington,DC'&quot;
);
$wpdb-&gt;query($sanitized_sql);
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/PHP/WordPress/model-layer/Persist-Data.html">
                    保存插件的数据到数据库
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2015-04-10
                </p>
              </div>
              <div class="content article-body">
                <p>大多数WordPress插件都需要获取管理员或用户输入的一些信息，并保存在会话中，以便在过滤器函数(filter)、动作函数(action)和模板函数(template)中使用。若需要在下次会话中继续使用这些信息，就必须将它们保存到WordPress数据库中。以下是将插件数据保存到数据库的几种方法：</p>
<ol>
<li>使用WordPress的&quot;选项&quot;机制。</li>
<li>使用文章元数据（又名自定义域）。</li>
<li>使用自定义分类。</li>
<li>使用其他数据表</li>
<li>创建一个新的，自定义的数据库表。这种方式适合保存那些与个人文章、页面或附件无关的，会随着时间逐渐增长的，并且没有特定名称的数据。关于如何使用，你可以阅读Creating Tables with Plugins以获取更多信息</li>
</ol>
<h2>WordPress选项机制</h2>
<p>WordPress有一个&quot;选项&quot;机制，适合储存少量静态的、具有特定名称的数据(通常是网站所有者在创建插件时设置的一些初始化参数，并且以后很少会进行改动) 。
选项的值可以是字符串、数组，甚至是PHP对象（当然，PHP对象在保存时必须能够被序列化或转换成字符串，检索的时候也必须能够被反序列化）。选项的名称必须是字符串，且必须是唯一的，这样才能够确保它们不会和WoredPress或其它插件产生冲突。</p>
<p>对应数据库中数据表<code>{$wpdb-&gt;prefix}_options</code>。该表结构类似于：</p>
<pre><code>mysql&gt; select * from wp_options limit 25;
+-----------+---------------------------+-----------------------------+----------+
| option_id | option_name               | option_value                | autoload |
+-----------+---------------------------+-----------------------------+----------+
|        11 | comments_notify           | 1                           | yes      |
|        12 | posts_per_rss             | 10                          | yes      |
|        13 | rss_use_excerpt           | 0                           | yes      |
|        14 | mailserver_url            | mail.example.com            | yes      |
|        15 | mailserver_login          | login@example.com           | yes      |
|        16 | mailserver_pass           | password                    | yes      |
|        17 | mailserver_port           | 110                         | yes      |
|        18 | default_category          | 1                           | yes      |
|        19 | default_comment_status    | open                        | yes      |
|        20 | default_ping_status       | open                        | yes      |
|        21 | default_pingback_flag     | 1                           | yes      |
|        22 | posts_per_page            | 10                          | yes      |
|        23 | date_format               | F j, Y                      | yes      |
|        24 | time_format               | g:i a                       | yes      |
|        25 | links_updated_date_format | F j, Y g:i a                | yes      |
+-----------+---------------------------+-----------------------------+----------+
</code></pre>
<p>选项机制的几个主要函数：</p>
<ul>
<li><code>add_option($name,$value,$deprecated,$autoload)</code></li>
<li><code>get_option($name)</code></li>
<li><code>update_option($name,$value)</code></li>
<li><code>delete_option()</code></li>
</ul>
<p>通常情况下，最好能够对插件选项的数量进行一下精简。例如，如果有10个不同名称的选项需要保存到数据库中，那么，就可以考虑将这10个数据作为一个数组，并保存到数据库的同一个选项中。</p>
<h2>文章元数据</h2>
<p>这种方式与第一种方案类似，但是与具体的post相关联，故而适合保存与post相关的数据。</p>
<p>对应数据表<code>{$wpdb-&gt;prefix}_postmeta</code>,基本的数据结构类似于：</p>
<pre><code>mysql&gt; select * from wp_postmeta limit 15 ;
+---------+---------+-----------------------------+-----------------------------+
| meta_id | post_id | meta_key                    | meta_value                  |
+---------+---------+-----------------------------+-----------------------------+
|       1 |       2 | _wp_page_template           | default                     |
|       2 |       5 | _edit_last                  | 1                           |
|       3 |       5 | _edit_lock                  | 1441571672:1                |
|       4 |       7 | _edit_last                  | 1                           |
|       5 |       7 | _edit_lock                  | 1441572102:1                |
|       6 |       8 | _edit_last                  | 1                           |
|       7 |       8 | _edit_lock                  | 1441572197:1                |
|       8 |      10 | _menu_item_type             | custom                      |
|       9 |      10 | _menu_item_menu_item_parent | 0                           |
|      10 |      10 | _menu_item_object_id        | 10                          |
|      11 |      10 | _menu_item_object           | custom                      |
|      12 |      10 | _menu_item_target           |                             |
|      13 |      10 | _menu_item_classes          | a:1:{i:0;s:0:&quot;&quot;;}           |
|      14 |      10 | _menu_item_xfn              |                             |
|      15 |      10 | _menu_item_url              | http://localhost/wordpress/ |
+---------+---------+-----------------------------+-----------------------------+

</code></pre>
<p>涉及到的一些基本的CRUD函数为：</p>
<ul>
<li><code>add_post_meta()</code></li>
<li><code>get_post_meta()</code></li>
<li><code>update_post_meta()</code></li>
<li><code>delete_post_meta()</code></li>
</ul>
<p>实际上，WordPress2.9之后，引入了<code>register_post_type</code>来创建新的Post Type。配合对元数据的操作函数，可以极大程度上模拟各种实体功能，从而避免创建新的的数据表。</p>
<pre><code class="language-PHP">//...某插件提供的Post Type注册方法片段

register_post_type(
    self::POST_TYPE,
    array(
        'labels' =&gt; array(
            'name' =&gt; __(sprintf('%ss', ucwords(str_replace(&quot;_&quot;, &quot; &quot;, self::POST_TYPE)))),
            'singular_name' =&gt; __(ucwords(str_replace(&quot;_&quot;, &quot; &quot;, self::POST_TYPE)))
        ),
        'public' =&gt; true,
        'has_archive' =&gt; true,
        'description' =&gt; __(&quot;This is a sample post type meant only to illustrate a preferred structure of plugin development&quot;),
        'supports' =&gt; array(
            'title', 'editor', 'excerpt', 
        ),
    )
);
</code></pre>
<p>一旦使用了自定义的Post Type来作为Entity，就可以使用WordPress自带的CRUD函数来操作：</p>
<ul>
<li><code>wp_insert_post()</code> #Create a new post (C).</li>
<li><code>get_post()</code>       #Retrieve a post (R).</li>
<li><code>wp_update_post()</code> #Update an existing post (U).</li>
<li><code>wp_delete_post()</code> #Delete a post (D).</li>
</ul>
<p>当然，搭配到WordPress的钩子上，就更强大了。例如：</p>
<ul>
<li><code>save_post</code>             # 当保存文章时被触发的钩子事件</li>
<li><code>save_post_{post_type}</code> # WP3.7新增钩子,无须校验<code>is_post_type($post_type)</code></li>
</ul>
<h2>Custom Taxonomy</h2>
<p>WordPress默认内置了4种Taxonomies:</p>
<ol>
<li>Category      #往往是写文章之前就预定义好的</li>
<li>Tag           #往往拥有多个tag，可在写文章时即时生成</li>
<li>Link Category #往往只在内部使用，可用来categorize links</li>
<li>Post Formats  #meta信息，可以用来定制文章的呈现形式。</li>
</ol>
<p>除此之外，WordPress还允许创建自己的taxonomies。</p>
<p>这种方式适合保存那些需要分门别类存放的数据，如用户信息、评论内容以及用户可编辑的数据等，特别适合于当你想要根据某个类型去查看相关的文章和数据的情况。</p>
<h2>使用WordPress内置的其他数据表</h2>
<p>WordPress为内置数据表提供了许多便利函数，比如Users数据表:</p>
<pre><code>* `wp_create_user()`#Create a new user (C).
* `get_userdata()`  #Retrieve a user’s data (R).
* `wp_update_user()`#Update an existing user (U).
* `wp_delete_user()`#Delete a user (D).
</code></pre>
<h2>建立额外的数据表</h2>
<p>除了使用现有的数据库模式之外，还可以添加自己的数据表。如著名的插件WooCommerce就添加了定制的数据表：</p>
<pre><code>+-------------------------------------------------+
| Tables_in_wordpress                             |
+-------------------------------------------------+
| wp_woocommerce_api_keys                         |
| wp_woocommerce_attribute_taxonomies             |
| wp_woocommerce_downloadable_product_permissions |
| wp_woocommerce_order_itemmeta                   |
| wp_woocommerce_order_items                      |
| wp_woocommerce_tax_rate_locations               |
| wp_woocommerce_tax_rates                        |
| wp_woocommerce_termmeta                         |
+-------------------------------------------------+

</code></pre>
<h3>create schema</h3>
<h3>update schema</h3>
<h3>日常操作</h3>
<p>可借助于WPDB类全局类对象$wpdb提供的方法完成。</p>
<pre><code class="language-PHP">$wpdb-&gt;insert(
    $table_name,
    array(
        'time'=&gt;current_time('mysql'),
        'name'=&gt;$welcome_name,
        'text'=&gt;$welcome_text
    )
);
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/PHP/WordPress/template-layer/Wordpress-Template-Layer.html">
                    WordPress Template Layer 1
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2015-04-10
                </p>
              </div>
              <div class="content article-body">
                <p>如基础架构中所述，WP的模板加载是通过wp-includes/template-load.php文件来完成的,根据模板等级结构，优先选择级别较低的模板。</p>
<p>在WordPress中，任意一个没有找到对应的模板文件的请求都会被index.php模板处理。</p>
<h2>模板文件碎片</h2>
<p>为了最大限度上复用模板，WordPress提供了以下默认的模板文件碎片</p>
<ul>
<li>header.php    #<code>get_header()</code></li>
<li>sidebar.php   #<code>get_sidebar()</code></li>
<li>footer.php    #<code>get_footer()</code></li>
<li>comments.php   #<code>comments_template()</code>,<code>wp_list_comments()</code></li>
<li>search.php</li>
</ul>
<h2>模板函数和钩子</h2>
<p>以下三个钩子包装函数应该在每一套主题中设置：</p>
<ul>
<li><code>wp_head()</code>         #在header.php模板的</head>关闭之前布置钩子</li>
<li><code>wp_footer()</code>       #在footer.php模板的</body>关闭之前布置钩子</li>
<li><code>comment_form()</code>    #在comments.php模板的</form>关闭之前布置钩子</li>
</ul>
<h3>template tags的原理及其依赖</h3>
<p>所谓templte tags，其实就是一些为模板编写的简单PHP函数，定义于</p>
<ul>
<li><code>wp-includes/</code>
<ul>
<li><code>template.php</code>、</li>
<li><code>category-template.php</code></li>
<li><code>post-template.php</code></li>
<li><code>general-template.php</code></li>
<li>...</li>
</ul>
</li>
</ul>
<p>等之类的文件中。这些template tags为定制模板提供了极大的方便：</p>
<ul>
<li><code>bloginfo()</code>    #常用于header、footer中，提供基本信息,如字符集、样式文件路径、模板URL等等</li>
</ul>
<p>由于查询、渲染是个多步过程，一些template tags的使用是有条件的。例如，可以在Loop中使用的template tags:</p>
<ul>
<li><code>the_title()</code></li>
<li><code>the_permalink()</code></li>
<li><code>the_author()</code></li>
<li><code>the_author_post_link()</code></li>
<li><code>the_date()</code></li>
<li><code>the_time()</code></li>
<li><code>the_excerpt()</code></li>
<li><code>the_content()</code></li>
<li><code>the_category()</code></li>
<li><code>the_tags()</code></li>
</ul>
<p>这些template tags 依赖于<code>the_post()</code>函数在Loop的顶部执行后生成的$post对象，因此这些template tags不可在Loop外使用。</p>
<p>如果想使用类似的功能，可以一个定制的Loop，还可以使用以$postid为参数的get系列 template tag</p>
<ul>
<li><code>get_the_title($postid)</code></li>
<li><code>get_the_permalink($postid)</code></li>
<li><code>get_the_category($postid)</code></li>
<li><code>get_the_tags($postid)</code></li>
<li><code>get_post($postid)</code></li>
</ul>
<p><code>get_post()</code>返回$post对象,该对象的属性：</p>
<ul>
<li><code>post_exerpt</code></li>
<li><code>post_content</code></li>
</ul>
<h2>引入JavaScript和CSS</h2>
<p>直接在模板中硬编码引入JavaScript容易造成冗余及依赖问题，WordPress提供了以下两个函数确保JavaScript按合适的顺序加载。</p>
<ul>
<li><code>wp_enqueue_script()</code></li>
<li><code>wp_print_scripts()</code></li>
</ul>
<p>可以在 functions.php 中创建一个函数来负责处理主题中的所有JavaScript脚本</p>
<pre><code class="language-PHP">
function theme_javascript(){
    wp_enqueque_script(
        'jquery-corners',
        'http://example.com/jquery-corners.js',
        array('jquery')
    );
}


function theme_print_scripts(){

    $js=&lt;&lt;&lt;EndOfString
    &lt;script type='text/javascript'&gt;
        jQuery.noConflict();
        jQuery(document).ready(function(){
            //...
        });
    &lt;/script&gt;

}


add_action('wp_head','theme_print_scripts');
add_action('wp_enqueue_script','theme_javascript');

</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/PHP/WordPress/architecture/architecture1-basic-workflow.html">
                    WordPress 前台基础架构分析之一:基本流程
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2015-04-10
                </p>
              </div>
              <div class="content article-body">
                <h2>基本流程代码分析</h2>
<p>WordPress并没有统一的入口，比如</p>
<ul>
<li><code>wp-login.php</code>    #用于登录</li>
<li><code>wp-admin/index.php</code>    #用于后台管理</li>
<li><code>index.php</code>    #前台博客功能入口</li>
</ul>
<p>这里要分析的是WordPress的前台功能基础架构。</p>
<h2>前台入口的基本逻辑</h2>
<p>前台入口文件<code>index.php</code>非常简单，所做的只是转而去加载WordPress博客头<code>wp-blog-header.php</code>文件。</p>
<pre><code class="language-PHP">//index.php

/** Loads the WordPress Environment and Template */
require( dirname( __FILE__ ) . '/wp-blog-header.php' );
</code></pre>
<p>而这<code>wp-blog-header.php</code>文件所做的事儿则是WordPress博客功能的核心：</p>
<pre><code class="language-PHP">
if ( !isset($wp_did_header) ) {
	$wp_did_header = true;


	#加载所有的必需文件
	require_once( dirname(__FILE__) . '/wp-load.php' );


	#执行WordPress的查询过程，设置相应全局变量
	wp();


	#利用模板加载器加载相应的模板
	require_once( ABSPATH . WPINC . '/template-loader.php' );
}
</code></pre>
<p>综上所述，WordPress博客功能便是做这三件事:</p>
<ol>
<li>加载必要的基础文件</li>
<li>执行查询并设置一些列全局变量，</li>
<li>加载特定的模板模板输出响应。</li>
</ol>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/PHP/WordPress/architecture/Hook-and-Pluggable.html">
                    WordPress钩子和Pluggable
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2015-04-10
                </p>
              </div>
              <div class="content article-body">
                <p>钩子和Pluggable是WordPress插件机制的基础。</p>
<h2>Action和Filter</h2>
<p>与Symfony/EventDispather组件、GuzzleHttp 的事件分发机制类似，WordPress提供了一种过程式的钩子实现。当特定事件发生时，WordPress就会根据当前事件对所关联的函数进行调用。</p>
<p>布置钩子的常用函数：</p>
<ul>
<li><code>do_action</code></li>
<li><code>do_action_ref_array</code></li>
<li><code>apply_filters</code></li>
<li><code>apply_filters_ref_array</code></li>
</ul>
<p>类似这些钩子，可以接受不定数量的参数 ，如：</p>
<pre><code class="language-PHP">do_action('save_post',$post_id,$post);

do_action( $hook_name, $arg_1, $arg_2, $arg_3,... );
</code></pre>
<p>因此，在将函数钩到事件时，需要用第四个参数来说明钩取的函数接受的参数数量:</p>
<pre><code class="language-PHP">add_action ( 'hook_name', 'your_function_name', [priority], [accepted_args_num=1] );
add_filter ( 'hook_name', 'your_function_name', [priority], [accepted_args_num=1] );
</code></pre>
<p>还可以将事件对应的函数移除：</p>
<pre><code class="language-PHP">remove_action('action_hook_name','action_function_name');
remove_filter('filter_hook_name','filter_function_name');
</code></pre>
<h2>Pluggable 函数</h2>
<p>除了钩子（actions 和 filters）,另外一个修改WordPress行为的方法是覆盖Pluggable的函数。</p>
<p>在<code>wp-includes/pluggable.php</code>文件中，预定义了一小部分函数。此文件会在加载完插件后加载:</p>
<pre><code class="language-PHP">// wp-settings.php

//...

register_theme_directory( get_theme_root() ); // Register the default theme directory root

// Load active plugins.
foreach ( wp_get_active_and_valid_plugins() as $plugin ) {
	wp_register_plugin_realpath( $plugin );
	include_once( $plugin );
}
unset( $plugin );

// Load pluggable functions.
require( ABSPATH . WPINC . '/pluggable.php' );
require( ABSPATH . WPINC . '/pluggable-deprecated.php' );

//...

</code></pre>
<p>此<code>pluggable.php</code>文件中定义的函数，都采用类似以下的形式，以保证只有当所有的插件都被加载后仍未定义的函数，这部分预定义的函数才会被定义。</p>
<pre><code class="language-PHP">// wp-includes/pluggable.php

if ( !function_exists('wp_get_current_user') ) :
    function wp_get_current_user() {
        global $current_user;
        get_currentuserinfo();
        return $current_user;
    }
endif;

</code></pre>
<p>尽管如此，Pluggable functions are no longer being added to WordPress core. All new functions instead use filters on their output to allow for similar overriding of their functionality.</p>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <div class="container">
      <div class="container has-text-centered">
        <a href="/posts/page28.html">
          Previous
        </a>
        30 of 32
        <a href="/posts/page30.html">
          Next
        </a>
      </div>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
      
 // 处理形如 <code>$E=mc^2$</code> 形式的公式
  var inlineMathNodes=document.querySelectorAll('code');
  var re=/^\$(.*)\$$/;
  for(var j=0;j<inlineMathNodes.length;j++){
    var result=re.exec(inlineMathNodes.item(j).innerText);
    if(result!==null){
      katex.render(result[1], inlineMathNodes.item(j));
    }
  }
  function removeNode(node){
    if(node.remove){
      node.remove();
    }else{
      return first.parentNode.removeChild(node);
    }
  };

  // 查找所有 pre code.language-math 节点 以备筛出数据公式
  var nodes=document.querySelectorAll("pre code.language-math");
  for(var i=0;i<nodes.length;i++){
    var node=nodes.item(i);
    // 魔术标记所在行 
    try{
      var lines = node.innerText.split('\n');
      if((!!lines) && lines.length > 0)
      {
        var first = lines[0];
        if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
          var views = "";
          // 逐行渲染
          for(var k=1; k <lines.length; k++){
              var f=lines[k];
              views += katex.renderToString(f);
          }
          // 消除父级嵌套 
          try{
            node.innerHTML=views;
          }catch(e){
            // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
            console.log('IE9 sucks',e);
            $(tr).html(node.innerHTML);
          }
        }
      }
    }
    catch(err){
      console.log(err)
    }
  }
    
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>