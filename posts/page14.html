<!DOCTYPE html><html>
  <head>

        <script type="text/javascript">
          var wsUri = "ws://localhost:8080/websocket";
      function init()
      {
        websocket = new WebSocket(wsUri);
        websocket.onclose = function(evt) { onClose(evt) };
      }
      function onClose(evt)
      {
        console.log('closing');
        websocket.close();
        document.location.reload();
      }
      window.addEventListener("load", init, false);
      </script>
            <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie/"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item is-active" href="">
            Home
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/OS/硬件基础/CPU.html">
                    操作系统笔记 硬件基础——CPU
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-10-26
                </p>
              </div>
              <div class="content article-body">
                <h2>CPU结构</h2>
<p>CPU 主要有运算器、控制器、寄存器组、和内部总线组成。</p>
<pre><code>                                                 执行指令控制
                                                  ^^^^^^^^^
                   +---+                          |-------|
                   |PSW&lt;---+---------+        +---------------+
                   +---+   |         |        | 操 作 控 制 器 |      +-------+
                       +---+   ALU   |        |               &lt;------+ 时 钟 |
      +------+         | +-+         |        | 时 序 产 生 器 &lt;------+ 状 态 |
+-----+      +---+     | | +-+-+--^^-+        +-----+-+-+------      +-------+
| ----+ RAM  +---+     | |   ^ ^  | |               ^ ^ ^ ^
| |   +------+ | |     | |   | |  | |               | | | |
| |            | |    +v-v---+-+  | |             +--+-+-+-+---+
| |            | |    |  AC    &lt;--- |             |    ID      |
| |            | |    +------^^+  | |             +---^-^------+
| |            | |           ||   | |               | |
| ----+-----+----+         +---------+             +-+-+------+
| ----+ I/O +----+         |   DR    +-------------&gt;   IR     |
| |   +-----+  | |         +---^-^---+             -+-+-------+
| |            | |  DBus       | |                  | |
| |            | +------------------------------------+
| |            +--------------------------------------+
| |                                                 | |    +------+
| |                                                 | +----+  PC  |
| |                                                 +-------------+
| |                                                 | |    +------+
| |                                                 | +----+  AR  |
| |                                                 +---------+-+-+
| |  ABus                                                     | |
| ------------------------------------------------------------+ |
+---------------------------------------------------------------+
</code></pre>
<!-- more -->
<h3>运算器</h3>
<ul>
<li>算术逻辑单元（<code>Arithmetic and Logic Unit</code>, <code>ALU</code>）:负责对数据进行算术运算和逻辑运算。</li>
<li>累加寄存器（<code>AC</code>）：累加器，通用寄存器，为<code>ALU</code>提供了一个工作区。</li>
<li>数据缓冲寄存器（<code>DR</code>）:为CPU和内存、外围设备之间数据传送的中转站、缓冲。</li>
<li>状态条件寄存器（<code>PSW</code>）:包括状态标准和控制标志，例如进位(C)、溢出(V)、运算结果为0（Z）、运算结果为负值（N）、中断（I）等。</li>
</ul>
<h3>控制器</h3>
<p>控制器用于控制整个CPU的工作。一般包括：</p>
<ul>
<li>指令寄存器（<code>IR</code>）:当CPU执行一条指令时，先把它从内存中取到<code>DR</code>，然后送入<code>IR</code>暂存。指令译码器根据<code>IR</code>的内容产生各种微操作指令，控制其他部件完成工作。</li>
<li>程序计数器（<code>PC</code>）: 又称之为指令计数器，<code>PC</code>有寄存信息和计数两个功能。执行指令时，CPU将自动修改<code>PC</code>内容，使其保持的总是将要执行的下一条指令的地址。</li>
<li>地址寄存器（<code>AR</code>）: 保存了当前CPU所访问内容单元的地址，直到对内存的读写操作完成。</li>
<li>指令译码器（<code>ID</code>）: 指令分为操作码和地址码两部分。<code>ID</code>是对指令中的操作码字段进行分析解释，识别指令规定的操作，向操作控制器发出具体的控制信号，控制各部件完成工作。</li>
</ul>
<p>其他还包括：</p>
<ul>
<li>时序控制器：为每条指令按时间顺序提供有效的控制信号。</li>
<li>总线逻辑：信息通路的控制电路。</li>
<li>中断控制器：用于控制各种中断请求，并根据优先级进行排队，逐个交给CPU处理。</li>
<li>e.t.c</li>
</ul>
<h3>寄存器组</h3>
<p>分为通用寄存器和专用寄存器。专用寄存器作用是固定的，如控制器和运算器中的寄存器。而通用寄存器可以由程序员指定用途。</p>
<h2>指令执行过程</h2>
<ol>
<li>取指：从内存中读取一条指令到<code>DR</code>，然后送入<code>IR</code></li>
<li>解码: <code>ID</code>对指令进行分析解码，识别规定的动作</li>
<li>执行</li>
</ol>
<h3>流水线技术</h3>
<p>CPU可以有分开的取值单元、解码单元、和执行单元。也就是说，不必等到一条指令从头到尾执行完毕后再开始处理下一条指令。三级流水线其示意图为：</p>
<pre><code>// 流水线技术
          ^
          |                                           X : 取指流水线
          |                                           Y : 解码流水线
          |                                           Z : 执行流水线
          |
          |
+-------+ +------+------+-----------------+-----+
   X      |  1   |  2   |       ...       |  n  |
+-------+ +----------+------+-------------+----------+
   Y      |      | 1 |  | 2 |      ...          | n  |
+-------+ |      +------+---------+-----+-----+-+---------+
   Z      |          |  1   |  2  |  3  | ... |      | n  |   时间
+-------+ +-----------------+-----+-----+-----+------------------&gt;
          |XXXXXX|YYY|                               |ZZZZ|
          |XXXXXX|YYY|                               |ZZZZ|
          +----------+                               +----+
</code></pre>
<p>在某个时刻，第一条指令取指完成（对应图中XXXXXX标注区域），解码流水线立即开始第一条指令的解码，同时取指流水线开始对第二条指令的取指；第一条指令的解码操作完成之后（对应图中YYYY标注区域），执行流水线开始对第一条指令的执行操作，同时解码流水线等待第二条指令送达。</p>
<p>假设每条指令的取指操作需要<code>$\Delta t_1 $</code>时间，解码需要<code>$\Delta t_2$</code>时间，执行需要消耗<code>$\Delta t_3$</code>时间，则最终执行N条指令，则完成上图N条指令共需要时间为：</p>
<pre><code class="language-math">%% KaTex
(\sum\limits_{i=1}^3 \Delta t_i) + (n-1)*\Delta t_3
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/OS/硬件基础/总线结构.html">
                    操作系统笔记 硬件基础——总线结构
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-10-26
                </p>
              </div>
              <div class="content article-body">
                <p>计算机系统的硬件部分以总线方式进行互联，以实现部件和设备的扩充。</p>
<p>一种多总线结构示意图：</p>
<pre><code>// 总线结构
                  高速缓存总线           局部总线                          内存总线
                       |                   |                                |
                       |                   |                                |
    +---------------+  | +-----------+     |    +------------+              |             +----------------+
    |     二   级   +--+--&gt;           +-----+----&gt;           +--------------+-------------&gt;                 |
    |高 速  缓  存  |     |    CPU    |          |   PCI桥    |                            |  主  存  储  器 |
    |              &lt;-----+           &lt;----------+            &lt;----------------------------+                 |
    +--------------+     +-----------+          +------^-----+                            +----------------+
                                                      |-|
                                                      |-|
                                                      |-|
                                                      |-|
                                                      |-|
                                                      |-|                        PCI 总 线
    +----------------------------------------------------------------------------------------------------+
    +----------------------------------------------------------------------------------------------------+
      | |                | |                          |-|                                  ||
      | |                | |                          |-|                                  ||
      | |                | |                          |-|                                  ||
  +---+-+---+        +---+-+---+                      |-|                             +---------------+
  |  SCSI   |        |   USB   |                      |-|                             |图 形 适 配 器  |
  +----+----+        +----+----+                      |-|                             +---------------+
       |                  |                           |-|
       v  SCSI总线        v       USB总线        +------------+ IDE总线+------------+
+------------+     &lt;--+---+------+--&gt;           |            +--------+            |
+------------+        |          |              |    ISA桥   &lt;--------&gt;   IDE硬盘  |
                      |          |              |            +--------+            |
                      |          |              +------------+        +------------+
                  +---+---+  +---+-----+              |-|
                  | mouse |  |keyboard |              |-|
                  +-------+  +---------+              |-|
                                                      |-|
                                                      |-|
                                                      |-|                        ISA 总 线
+----------------------------------------------------------------------------------------------------------+
+----------------------------------------------------------------------------------------------------------+
     | |                     | |                               | |
     | |                     | |                               | |
  +--+-+--+             +----+-+-----+                    +----+-+------+
  | 声卡  |             |   打 印 机  |                    |调 制 解 调 器|
  +-------+             +------------+                    +-------------+
</code></pre>
<p>在这种总线结构中，CPU内部有个一级高速缓存；CPU之外有个二级缓存通过高速缓存总线与CPU相连。CPU通过局部总线与PCI桥芯片对话，PCI桥芯片通过专门的存储总线与存储器对话。</p>
<!-- more -->
<p>总线分类：</p>
<ol>
<li>内部总线：用于芯片一级的互联，分为芯片内总线和元件级总线。</li>
<li>系统总线：又称为内部总线，用于插件板一级的互联。</li>
<li>外部总线：又称为通信总线，用于设备一级的互联。</li>
</ol>
<p>系统总线：典型的有ISA总线（工业标准总线，Industry Standard Architecture）、PCI总线（外网组件互联总线，Peripheral Component Interconnect）。</p>
<p>外部总线有很多：</p>
<ol>
<li>RS232C：串行，在工控行业应用较多。</li>
<li>SCSI : 小型计算机接口，一种高速的并行外总线。用于扫描仪、高速影盘等需要高带宽的设备上。</li>
<li>USB：通用串行总线。将慢速I/O设备与计算机相连。</li>
<li>其他</li>
</ol>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/OS/二进制基础/数据表示.html">
                    操作系统笔记 二进制基础——数据表示
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-10-26
                </p>
              </div>
              <div class="content article-body">
                <h2>数制转换</h2>
<p>我们知道，一个数N从一个数制X转换到另一个数制Y，可以使用以下公式展开，得到的相应幂序列就是结果：</p>
<pre><code class="language-math">%% KaTex
N_X=\sum\limits_{i=0}^m Y^i
</code></pre>
<p>具体到二进制整数，相应公式为：<code>$\sum\limits_{i=0}^m 2^i$</code>。 比如，一个10进制数100，转换到2进制，其基本过程可以表示为：</p>
<pre><code class="language-math">%% KaTex
100D=64D+32D+4D=2^{6}D+2^{5}D+2^2D=110\,0100B
</code></pre>
<p>二数制小数部分转换同理，只要把N以如下公式分解：</p>
<pre><code class="language-math">%% KaTex
\sum\limits_{j=1}^{n} 2^{-j}
</code></pre>
<p>即可得到结果。比如有十进制纯小数0.75D，欲转换为二进制的纯小数，其基本过程为：</p>
<pre><code class="language-math">%% KaTex
0.75D=0.5D+0.25D=2^{-1}D+2^{-2}D=\bigodot11B
</code></pre>
<p>在这里，用<code>$\bigodot$</code>表示隐含的小数点位置。对于小数而言，采用这种展开的方法并不方便，因为记住或者推算 0.5、0.25、0.125、... 这种小数序列并没有记忆或推算 2、4、8、16、...、这种整数序列方便。故另外一个可选的办法是乘2取整法，以十进制的0.625为例：</p>
<pre><code class="language-math">%% KaTex
0.625D *2=\color{orange}{1} \color{white}.25D
0.25\enspace D *2=\color{orange}{0} \color{white}.50D
0.50\enspace D *2=\color{orange}{1} \color{white}.00D
</code></pre>
<p>所以最终得到的结果为<code>$\bigodot101B$</code></p>
<!-- more -->
<h2>码制</h2>
<p>计算机中常用的码制有原码、反码、补码、移码。</p>
<h3>原码</h3>
<p>计算机并不认识负数。为了用二进制表示负数，可以人为的设定一个负数标志。原码规定，对于正数，表示方法并没有什么两样；但是为了表示负数，我们需要把最高位作为标志位，也就是说当符号位为1，表示负数。</p>
<p>设X为二进制的n位纯整数，当<code>$X&lt;0$</code>，需要在最高位也就是<code>$2^n$</code>位设置符号位为1，用公式表达为：</p>
<pre><code class="language-math">%% KaTex
X_o=2^{n-1}+ |X|  \qquad(\color{white} -(2^{n-1}-1) \le X \le 0)
</code></pre>
<p>若X为n位纯小数，当<code>$X&lt;0$</code>，需要在最高位也就是<code>2^0</code>设置设置符号为1，用公式表达为：</p>
<pre><code class="language-math">%% KaTex
X_o=2^{0}+ |X|    \qquad(\color{white} -1&lt;X \le 0)
</code></pre>
<h3>减法的计算</h3>
<h4>原码之痛</h4>
<p>我们知道，计算机有专门的加法电路来求解加法，并没有专门的减法器。所有的减法计算都要转换为加法运算来求解。似乎有大家都知道的解决办法：<code>$X-Y=X+(-Y)$</code>。</p>
<p>假设要求 <code>$1-1$</code> 的值，计算机将使用加法器计算<code>$1+(-1)$</code>的值：</p>
<pre><code class="language-math">%% Katex
\overbrace{0\enspace 000\;0001}^{\text{1}}

\overbrace{1\enspace 000\;0001}^{\text{-1}}

+-------------
\overbrace{1\enspace 000\;0010}^{\text{-2}}
</code></pre>
<p>显然，这里得到的结果是-2而非0。这是因为我们人为规定的符号标志位(最高位)也被当作了数的一部分参与了求和运算。用原码表示，虽然直观易懂，但是不能正确地直接处理减法：公式<code>$X-Y = X+(-Y)$</code>并不能帮助我们把减法转换为加法运算，我们还需要寻求另外的转换方法。</p>
<h4>模运算</h4>
<p>为了解决减法向加法转换的问题，先考虑以下两个简单的小问题：</p>
<ol>
<li>对于一个12进制的表盘式的时钟，其时针刻度最多可以容纳1点、2点、...、到12点共12个数字。我们想求5点之前8小时是几点，由于存在借位关系，普遍的做法是计算(5点+12点)-8点=5点+(12点-8点)=9点。</li>
<li>现在有一个24进制的时钟时针刻度，其时钟刻度最多容纳1点、2点、...、到24点共24个数字。我们想求凌晨6点之前的9小时是几点，由于存在借位关系，通常的做法是计算(6点+24点)-9点=6点+(24点-9点）=21点。</li>
</ol>
<p>其实上述的减法计算无论是否存在借位关系都成立，12进制下任意整点时刻X之后的12小时还是X，因此有<code>$X-Y \equiv X+12-Y \quad (\mod 12)$</code>，所以求X之前的Y小时可以转化为</p>
<pre><code class="language-math">%% KaTex
X-Y \equiv X+(12-Y) \quad (\mod 12)
</code></pre>
<p>而24进制下任意整点时刻X之后的24小时还是X，所以X之前的Y小时可以转换为：</p>
<pre><code class="language-math">%% KaTex
X-Y \equiv X+(24-Y) \quad(\mod 24)
</code></pre>
<p>这里的12、24实际上是在表达一种容量大小——容纳数字的空间最多可以放多少个数字，称之为模。超过模的数溢出的结果等同于取余数。</p>
<p>我们知道，在计算机里存放整数可能有<code>int</code>、<code>short</code>、<code>long</code>、<code>long long</code>等很多类型，每种类型能表示的整数范围不一样。假设某种类型大小是n位，则该类型一共可以容纳<code>$2^n$</code>个数字，故该类型的模大小为<code>$M=2^n$</code>，也就是说：</p>
<pre><code class="language-math">%% KaTex
X-Y \equiv X+(M-Y) \quad ( \mod M)
</code></pre>
<p>记<code>$C=M-Y$</code>，所以该类型下的减法可以表示为:</p>
<pre><code class="language-math">%% KaTex
X -Y =X + C
</code></pre>
<p>这样，就从形式上把减法运算转换成了加法运算。现在的问题在于，如何求解C呢？计算机中没有专门的减法器，所有的减法都是用加法来进行的，然而定义式中<code>$C=M-Y$</code>还是使用了减法运算。所以我们需要对其进行等价转换。</p>
<h4>补数推导</h4>
<p>考虑有一个正数Y可以表示成n位二进制原码数，其中最高位是符号位。则必有</p>
<pre><code class="language-math">%% KaTex
Y= k_0*2^0 + k_1*2^1 + k_2*2^2 + ... +k_{n-2}*2^{n-2}  \qquad (1)
</code></pre>
<p>所以对应的二进制数为 <code>$\color{orange}{S} \color{green} \overbrace{ k_{n-2} k_{n-1} ... k_2 k_1  k_0}^\text{(n-1) bits} $</code>，其中<code>$\color{orange}{S}$</code>代表符号位，Y自身可以展开为<code>$\color{green}(n-1)$</code>位</p>
<p>显然，这(n-1)位二进制数最多能表示<code>$2^{n-1}$</code>个数，故其模为<code>$2^{n-1}$</code>，所以对于正数Y，相应的有<code>$C=2^{n-1}-Y$</code>。</p>
<p>根据等比数列求和公式： <code>$2^0+2^1+2^2+...+2^{n-2}= 2^{n-1} -1 $</code>，即有</p>
<pre><code class="language-math">%% KaTex
2^{n-1}=1+ \left( 2^0+2^1+2^2+...+2^{n-2} \right) \quad (2)
</code></pre>
<p>由 (1)(2)式，得到：</p>
<pre><code class="language-math">%% KaTex
2^{n-1} -Y =1+ \left(  (1-k_0)*2^0 + (1-k_1)*2^1 + (1-k_2)*2^2 + ... +(1-k_{n-2})*2^{n-2}   \right)
</code></pre>
<p>这里<code>$ k_0 , k_1, k_2, ... k_{n-2} $</code>都只会取值 0 或者1 。所以上式中的<code>$1-k_i \quad( i\in [0,n-2])$</code>实际上在表达按位取反的意思。可见：对于一个正数Y，相应的C等于其二进制码按位取反再+1。换言之，一个数的减法运算<code>$X-Y$</code>被转化为了加法运算<code>$X+C$</code>。</p>
<p>还是举<code>$1-1$</code>的例子，对于一个8比特型有符号整数，最高位为符号位:</p>
<pre><code class="language-math">%% KaTex
1B=\color{orange}0\enspace \color{green}000\,0001

C(1)=\color{orange}0\enspace \color{green}111\;1110 \color{white}+ 1 = \color{orange}1\enspace \color{green}000\;0001

\therefore \quad 1-1=1+C(1) =

\overbrace{\color{orange}0\enspace \color{green}000\;0001}^{\text{1}}

\overbrace{\color{orange}1\enspace \color{green}111\;1111}^{\text{C(1)}}

+-------------
\overbrace{0\enspace 000\;0000}^{\text{0}}
</code></pre>
<h3>补码</h3>
<p>何为负数？ 对于一个正数Y，相应的负数=0-Y。在上文推导C的过程中，我们假定的场景是：<code>某个数X-正数Y</code>。推导的结论表明，我们可以把<code>负数Y</code>代换成<code>补数C</code>(注意，这里要求<code>$Y&gt;0$</code>，如果<code>$Y&lt;0$</code>，则其实是直接对两个正数相加)。美中不足的是，我们为了加上一个负数还需要将其中被减数表示为原码，再将减去减数这个操作表示为加上补码，最后计算出补码后再对二者求和。</p>
<h4>补码的统一定义</h4>
<p>为了更进一步，统一<code>$X \pm Y$</code>对正负零<code>X</code>和<code>Y</code>均成立，可以规定正数<code>Y</code>的补码还是<code>Y</code>本身，而<code>负数Y</code>的补码为C。</p>
<p>例如：为了计算-127的补码，先计算其等价的二进制表示:</p>
<pre><code class="language-math">%% KaTex
127D=128D-1D=1000 \; 0000B -1 B= 0111 \; 1111B 
</code></pre>
<p>假定采用8bits的<code>char</code>型来存储，其中最高位为符号位，则按位取反应该是对后7位进行：</p>
<pre><code class="language-math">%% KaTex
\therefore \quad \lnot(111 \; 1111B)=000 \; 0000B
</code></pre>
<p>所以，最后求得的补码为：</p>
<pre><code class="language-math">%% KaTex
\therefore \quad C(-127)=\color{orange}1 \color{white}000 \; 0000B + 1B= \color{orange}1 \color{white}000 \; 0001B
</code></pre>
<p>再例如，为了计算 -0.5的补码，先计算其等价的二进制表示:</p>
<pre><code class="language-math">%% KaTex
0.5D=\bigodot 1B
</code></pre>
<p>其中，<code>$\bigodot$</code>表示隐含的小数点位置。假定采用 8bits 存储，则其中最高位为符号位，按位取反应该是对后7位进行：</p>
<pre><code class="language-math">%% KaTex
\therefore \quad  \lnot(\bigodot 100 \; 0000B ) =\bigodot 011 \; 1111B
</code></pre>
<p>所以，最后求得的补码为：</p>
<pre><code class="language-math">%% KaTex
\therefore \quad C(-0.5)=\color{orange}1 \color{white}\bigodot 011 \; 1111B + 1B= \color{orange}1 \color{white}\bigodot 100 \; 0000B
</code></pre>
<h4>补码的加减法</h4>
<p>统一使用补码的好处是两个二进制的加减法只要计算非常符合数学直觉。以两个补码的加法为例：</p>
<pre><code class="language-math">%% KaTex
-1+1=

\overbrace{1111\,1111}^{\text{-1}}

\overbrace{0000\,0001}^{\text{1}}

+-----
\overbrace{0000\,0000}^{\text{0}}
</code></pre>
<p>而两个补码的减法等价于被减数的补码+((-减数)的补码)，同样非常自然：</p>
<pre><code class="language-math">%% KaTex
1-1=

\overbrace{0000\,0001}^{\text{1}}

\overbrace{1111\,1111}^{\text{-1}}

+-----
\overbrace{0000\,0000}^{\text{0}}
</code></pre>
<h3>反码</h3>
<p>注意到上述求解补码的过程有:<code>负数的补码=按位取反部分+1</code>，这里把按位取反部分叫反码。为了表达按位取反，我们可以给其中每位加1，由于<code>$2^n=1\overbrace{000....000}^{\text{(n-1)bits}}$</code>，所以可以利用<code>$2^n-1$</code>构造出<code>$\overbrace{111...111}^{\text{(n-1)bits}}$</code>，然后加到原二进制数上，从而起到按位取反的效果，故所谓反码，还用公式表示为：</p>
<pre><code class="language-math">%% KaTex
X = \begin{cases}  X &amp;\text{if } X\ge 0   \\    (2^{n}-1) +X &amp;\text{if } X \lt 0 \end{cases}
</code></pre>
<p>对于负的纯小数，用公式表示为：</p>
<pre><code class="language-math">%% KaTex
X =2-2^{-(n-1)}+ X    \qquad(\color{white} -1&lt;X \le 0)
</code></pre>
<h3>移码</h3>
<p>对补码的符号位取反就得了移码。移码主要用于表达浮点数的阶码。</p>
<h2>浮点数的表示</h2>
<p>上述计算小数的过程都是小数点的位置隐含在固定位置。对于纯整数而言，假定小数点固定住数据末尾；而对于纯小数而言，则假定小数点固定在最高有效位之前。</p>
<p>浮点数是小数点位置可以浮动的数。一个二进制数N表示数值可以表示为：<code>$N=2^E*F$</code>。采用这种表示法称之为浮点表示法。</p>
<pre><code>---------------------------------
| 阶符 | 阶码(E) | 数符 | 尾数(F) |
---------------------------------
</code></pre>
<p>通常，阶码E采用移码来表示，而尾数F通常采用补码或者原码来表示。</p>
<p>阶码决定了浮点数的数值范围，而尾数决定了浮点数的数值精度。由于<code>0.111B</code>可以表示为<code>$1.11B*2^{-1}D$</code>，而后者可以多出一位小数表达数值，因而可以达到更高的精度。基于这样的思想，通常采用规格化浮点数，即让尾数的绝对值限定在<code>[0.5,1]</code>之间</p>
<h3>IEEE 754 工业标准</h3>
<p>IEEE754标准规定浮点数的表现形式为：</p>
<pre><code class="language-math">%% KaTex
(-1)^S 2^E \overbrace{(f_0 f_1 f_2 ... f_{p-1})}^\text{F}
</code></pre>
<p>其中:</p>
<ol>
<li><code>$(-1)^S$</code>为数符，S为0表示正数，S为1为负数。</li>
<li><code>$E$</code> 为指数，即阶码，用移码表示。</li>
<li><code>$f_0 f_1 f_2 ... f_{p-1}$</code> 为尾数，其长度为P位，用原码表示。</li>
</ol>
<p>根据使用的二进制位数的不同，可以分为单精度、双精度、扩充精度。</p>
<ol>
<li>单精度:是指浮点数字长32位（符号位长度为1，指数长度8，尾数长度23）</li>
<li>双精度：是指浮点数字长64位（符号位长度为1，指数长度11，尾数长度52）</li>
<li>扩充精度:是指浮点数字长80位（符号位长度为1，指数长度15，尾数长度64）</li>
</ol>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/ECMAScript/misc/一种配合Express-React使用UEditor的方案(2).html">
                    一种配合Express+React使用UEditor的方案(2)
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-10-17
                </p>
              </div>
              <div class="content article-body">
                <p>这是一种配合Express+React使用UEditor的方案的第(2)篇。</p>
<p>前文讲了如何在<code>Express</code>和<code>React</code>下使用<code>UEditor</code>的基本方案。这一篇博文详细说明如何使用<code>UEditor</code>的<code>React</code>封装。</p>
<h3>安装</h3>
<pre><code>npm install simple-react-ui --save
</code></pre>
<h3>使用</h3>
<ul>
<li>把<code>UEditor</code>相应的<code>assets</code>文件包放置在浏览器端可以访问的URL路径下，比如，<code>/static</code></li>
<li>引入 <code>simple-react-ui</code> 的 <code>UEditor</code> 组件，提供相应的属性</li>
</ul>
<p><code>UEditor</code>提供两种模式供用户使用， <em>受控模式</em>  和 <em>非受控模式</em> 。</p>
<h2>非受控模式</h2>
<p>在非受控模式下，用户主要通过</p>
<ul>
<li><code>initialContent</code> 属性来提供初始值</li>
<li><code>afterInit(ue)</code> 回调函数来与 <code>UEditor</code> 互动，其中<code>ue</code>参数是<code>UE.getEditor('id')</code>返回的编辑器实例。</li>
</ul>
<p><code>afterInit(ue)</code>在某种程度上类似于原生<code>React</code>组件的<code>ref</code>回调，我们可以把<code>ue</code>传递给父组件，从而可以在父组件中来做任何<code>UEditor</code>可以做的事儿。</p>
<p>注意，用户不得指定<code>value</code>属性，否则会自动转换为 <em>受控模式</em></p>
<!-- more -->
<h3>示例一：以非受控模式使用</h3>
<pre><code class="language-js">&lt;form id=&quot;postAddOrEditForm&quot;&gt;
    &lt;input name='title' type='text' placeholder='标题' 
        value={this.state.title||''} 
        onChange={(v)=&gt;{ this.setState({title:v.target.value}); }}
    /&gt;

    &lt;textarea required placeholder='摘要' 
        value={this.state.excerpt||''} 
        onChange={(v)=&gt;{ this.setState({excerpt:v.target.value});}} 
    /&gt;

    &lt;UEditor id=&quot;ueditorContainer&quot; name=&quot;content&quot; 
        initialContent={this.props.initialContent} 
        width={800} height={500} 
        afterInit={(ue)=&gt;{
            const id=this.props.id;
            if(!!id){    // 编辑已有文章的表单
                // 获取最新的数据
                fetch(`/post/detail?id=${id}`,{/**/})
                .then(resp=&gt;resp.json())
                .then(info=&gt;{
                    const state=Object.assign({},info);
                    this.setState(state,()=&gt;{
                        ue.setContent(info.content);
                    });
                });
            }else{ 
                // 这是一个用于新增文章的表单
            }
        }} 
    /&gt; 
    &lt;Button onClick={e=&gt;{
        e.preventDefault();
        // ... ajax post to server
        return fetch('',{/**/})
            .then(resp=&gt;resp.json())
            .then((info)=&gt;{
                message.info(`创建文章成功！`);
                ue.setContent('');
            });
    }}&gt;提交
    &lt;/Button&gt;
&lt;/form&gt;
</code></pre>
<h2>受控模式</h2>
<p>受控模式是更符合<code>React</code>理念使用方式。注意， <em>受控模式</em> 和 <em>非受控模式</em> 二者只居其一，不能共存。一旦提供<code>value</code>属性，则会被认为是受控模式，此时<code>initialContent</code>不再起作用。</p>
<p>在受控模式下，用户可以通过</p>
<ul>
<li><code>value</code>属性：父组件可以通过<code>value</code>属性来动态设置编辑器的内容</li>
<li><code>onChange(content)</code> 事件处理函数，当编辑器的内容发生变化以<code>onChange(content)</code>的方式通知父组件</li>
</ul>
<h3>示例二：以受控模式使用</h3>
<p>作为受控模式的示例，这里配合 <code>ant-design</code>的<code>Form.create()()</code> 使用：</p>
<pre><code class="language-javascript">export class PlainAddOrEditForm extends React.Component{

    constructor(props){
        super(props);
        this.state= {
            title:'',
            categoryId:'',
            featureImageUrl:'#',
            keywords:[
                {id:null,postId:null,tag:''},
            ],
            commentable:true,
        };
    }

    render() {

        const FormItem=Form.Item;
        const {getFieldDecorator,getFieldsError, getFieldError, isFieldTouched,validateFields}=this.props.form;
        const hasFieldError=(fieldname)=&gt;isFieldTouched(fieldname) &amp;&amp; getFieldError(fieldname);
        const hasErrors=(fieldsError)=&gt;Object.keys(fieldsError).some(field =&gt; fieldsError[field]);

        return (
            &lt;Form onSubmit={e=&gt;{
                e.preventDefault();
                validateFields((err, values) =&gt; {
                    if (!err) {
                        console.log(values);
                    }
                });
            }}&gt;
                &lt;FormItem label='标题' validateStatus={hasFieldError('title')} help={hasFieldError('title')||''} &gt;
                {
                    getFieldDecorator('title',{
                        rules:[{required:true,message:'title required'}],
                    })(
                        &lt;Input name='title' type='text' placeholder='标题'/&gt;
                    )
                }
                &lt;/FormItem&gt;
            
                &lt;FormItem label='content' validateStatus={hasFieldError('content')} help={hasFieldError('content')||''} &gt;
                {
                    getFieldDecorator('content',{
                        rules:[{required:true,message:'content required'}],
                        initialValue:'&lt;p&gt;测试&lt;/p&gt;&lt;b&gt;测试&lt;/b&gt;'
                    })(
                        &lt;UEditor id=&quot;ueditorContainer&quot; 
                            width={800} height={500} 
                            uconfigSrc={&quot;/url/to/uconfig.js&quot;} ueditorSrc={&quot;/url/to/ueditor.js&quot;}
                            afterInit={(ue)=&gt;{ this.ue=ue;}} 
                            onChange={content=&gt;{ console.log(content); }}
                    /&gt; 
                    )
                }
                &lt;/FormItem&gt;
  
                &lt;FormItem&gt;
                    &lt;Button htmlType='submit' type=&quot;primary&quot; size=&quot;large&quot; disabled={hasErrors(getFieldsError())}&gt;Submit&lt;/Button&gt;
                &lt;/FormItem&gt;
            &lt;/Form&gt;
        );
    }
}


export default Form.create()(PlainAddOrEditForm);
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/ECMAScript/misc/一种-Admin-UI-设计思路——兼谈Admin-UI的自动生成.html">
                    一种 Admin UI 设计思路——兼谈Admin UI的自动生成
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-10-08
                </p>
              </div>
              <div class="content article-body">
                <p>后台管理很多都是在简单的增删改查，本文讨论的就是如何自动生成增删改查的界面。</p>
<p>对于创建、修改工作，大部分时候我们都需要使用表单。一个普通的表单负责前端验证、简单错误提示，并将数据发送到后端。但是编写这样的代码并不愉快。
首先，创建表单和编辑表单在很大概率上是一样的，或者差异比较小的，起码验证逻辑、错误提示的规则配置是几乎一致的。其次，为每个模型都去编写创建界面/编辑界面/删除界面/查询界面，非常琐碎、耗时。
我们的目标就是要尽可能地少些代码，尽可能地多自动生成增删改查的管理界面。</p>
<h2>从普通的视图组件说起</h2>
<h3>PlainForm</h3>
<p>必须只包含视图内容，不得含有任何远程交互代码，甚至不得含有任何远程交互的意图。必须提供 <code>initialValues</code> 属性，来设置初始值。</p>
<pre><code class="language-js">// 一个纯粹的视图组件，将来可以用于新增或者编辑角色模型
class PlainAddOrEditForm extends React.Component{
    constructor(props){
        super(props);
    }

    render(){
        const {getFieldDecorator,getFieldsError, getFieldError, isFieldTouched,validateFields}=this.props.form;
        const hasFieldError=(fieldname)=&gt;isFieldTouched(fieldname) &amp;&amp; getFieldError(fieldname);
        const hasErrors=(fieldsError)=&gt;Object.keys(fieldsError).some(field =&gt; fieldsError[field]);
        const FormItem=Form.Item;
        return (
        &lt;Form &gt;
            &lt;FormItem label='角色名' validateStatus={hasFieldError('name')} help={hasFieldError('name')||''} &gt;
            {
                getFieldDecorator('name',{
                    rules:[{required:true,message:'角色名必填'}],
                    initialValue:this.props.initialValues.name,
                })(
                    &lt;Input placeholder='角色名' /&gt;
                )
            }
            &lt;/FormItem&gt;
        
            &lt;FormItem label='描述' validateStatus={hasFieldError('description')} help={hasFieldError('description')||''} &gt;
            {
                getFieldDecorator('description',{
                    rules:[{required:true,message:'角色描述必填'}],
                    initialValue:this.props.initialValues.description,
                })(
                    &lt;Input placeholder='description' /&gt;
                )
            }
            &lt;/FormItem&gt;
        
        &lt;/Form&gt;);
        
    }
}
</code></pre>
<!-- more -->
<h3>PlainViewComponent</h3>
<p><code>PlainForm</code>可以不经过嵌套直接使用(为了方便，将之表示为 <code>PlainForm组件</code> )。
我们大可以在其中加入<code>button</code>控制其提交，但是这会带来代码复用的问题。因为这相当于假定这个表单已经有了一个我们定义的提交按钮了。如果我们需要在对话框中显示这个表单，当点击对话框右下侧的取消按钮，我们希望什么也不做，关闭对话框；当我们单机对话框右下侧的确定按钮，表单会进行提交。这样我们就有了两个提交按钮，这无疑很扯蛋。</p>
<p>为了更好的代码复用，一个更好的办法是让<code>PlainForm</code>本身不包含提交或者取消这类控制指令的视图元素，而是<code>PlainForm</code>嵌套在其他组件中 (表示为<code>聚合PlainForm的纯视图组件</code>)。
一个最简单的例子是：</p>
<pre><code class="language-js">class PlainAddOrEditFormWithSubmitButton extends React.Component{
    constructor(props){
        super(props);
    }
    render(){
        return &lt;div&gt;
            &lt;PlainAddOrEditForm form={this.props.form} initialValues={this.props.initialValues}/&gt;
            &lt;Button htmlType=&quot;submit&quot; type=&quot;primary&quot; onClick={this.props.onOk}&gt; 提交 &lt;/Button&gt;
        &lt;/div&gt;;
    }
}
</code></pre>
<p>在这里我们组合了一个新的组件，注意作为<code>PlainForm</code>的<code>PlainAddOrEditForm</code>组件并不含<code>button</code>元素。为了设置对用户点击提交按钮时的响应，我们添加了一个<code>Button</code>组件，然后将其<code>onClick</code>属性设置为由父组件传递的<code>props.onOk</code>。</p>
<p>为了表示方便，把<code>PlainForm</code>组件或者<code>聚合PlainForm的纯视图组件</code>统称为<code>PlainViewComponent</code>。</p>
<p>无论如何，<code>PlainViewComponent</code>都不应该包含任何的服务端交互意图；作为补偿，必须对外暴露这样几个<code>props</code>：</p>
<ul>
<li>initialValues : 设置初始值</li>
<li>onOk : 钩子函数，作为提交表单时触发的 callback</li>
<li>onCancel : 钩子函数，作为取消表单时触发的 callback</li>
</ul>
<h3>表单验证、错误提示</h3>
<p>既然<code>PlainViewComponent</code>只负责显示，那么如何控制其表单验证逻辑、错误提示呢？
这块工作可以剥离出来，我们可以根据<code>PlainViewComponent</code>和相应的字段验证规则、错误提示等配置信息，自动生成一个包装组件。最后利用包装组件对表单进行验证、错误提示、提取当前值。</p>
<p>所幸这块工作已经有人替我们想到了，由 <code>antd.Form.create()(PlainViewComponent)</code>可以完成这种工作。包装生成的新组件，会被注入<code>form</code>属性。从而可以控制表单的验证、错误显示和提取当前值操作。</p>
<p>为了方便，把表示为这种经过包装的组件称之为<code>DecoratedFormComponent</code></p>
<h2>用于创建模型的表单</h2>
<p>既然已经有了以上<code>PlainViewComponent</code>机制，让我们先来编写一个用于创建模型的表单来热热身：</p>
<p>假设我们有:</p>
<ul>
<li>一个<code>model</code>定义，其中<code>model.methods.create()</code>方法定义了如何与服务器交互创建一个新的模型对象。</li>
<li>一个经过包装的<code>DecoratedFormComponent</code>表单组件<code>AddOrEditForm</code>。</li>
</ul>
<p>则一个跟远程服务器通讯的的用于添加模型的表单，可以写成这种形式：</p>
<pre><code class="language-js">class AddForm extends React.Component{
    constructor(props){
        super(props);
        this.formRef=null;
    }

    onOk(){
        return this.formRef.validateFields((err,value)=&gt;{
            if(!err){
                model.methods.create(value)
                    .then(resp=&gt;{
                        message.success(`创建成功`);
                        this.formRef.resetFields();
                    })
                    .catch(e=&gt;{
                        message.error(`失败`+e);
                    });
            }
        });
    }

    render() {
        return &lt;AddOrEditForm ref={form=&gt;this.formRef=form} onOk={this.onOk} /&gt; ;
    }
}
</code></pre>
<p>看起来很傻对不对？绕了一大圈，却只是为了一个用于创建模型的表单，为什么要这么麻烦？</p>
<p>但是仔细观察上面这段代码，我们会发现，我们编写的这个组件除了依赖<code>model</code>和<code>DecoratedFormComponent</code>，其他完全都是样板代码！所以，根据<code>DRY</code>原则，我们可以编写这样一个函数：</p>
<pre><code class="language-js">(model,AddOrEditForm)=&gt;AddComponent
</code></pre>
<p>以后只要针对具体的模型提供<code>model</code>定义、和<code>AddOrEditForm</code>即可动态生成表单。为了方便，我们还可以编写一个用于创建默认的<code>AddOrEditForm</code>的函数：</p>
<pre><code class="language-js">createDecoratedAddOrEditForm(PlainAddOrEditForm) =&gt; DecoratedFormComponent
</code></pre>
<p>这样，就可以利用<code>PlainAddOrEditForm</code>创建一个<code>DecoratedFormComponent</code>，再加上一个<code>model</code>定义，我们就可以自动生成最终的添加模型的表单。</p>
<h2>Datagrid</h2>
<p>有了上面的思路，我们可以轻而易举封装出一个通用的<code>Datagrid</code>组件，其基本功能包括：</p>
<ul>
<li>列表显示</li>
<li>每行最后一列可以针对当前行执行相应操作
<ul>
<li>删除当前行记录 ：有对话框确认</li>
<li>修改当前行记录 ：保持页面不跳转，弹出对话框，编辑当前行记录</li>
</ul>
</li>
<li>带分页功能</li>
</ul>
<p>此外，还可以添加排序、筛选功能。</p>
<pre><code class="language-js">class List extends React.Component{

    constructor(props){
        super(props);
        this.state={
            data:[],                   // 当前数据源
            pagination:{},             // 当前分页
            loading:true,              // 表格是否正在加载，用于控制动画
            currentRecord:{},          // 执行操作时的当前行记录
            editModalVisible:false,    // 编辑表单是否可见
        };
        // 对 编辑表单组件 的引用
        this.editForm=null;
        // bind `this`
        this.onTableChange=this.onTableChange.bind(this);
        this.onRemove=this.onRemove.bind(this);
        this.onEditFormSubmit=this.onEditFormSubmit.bind(this);
        this.onEditFormCancel=this.onEditFormCancel.bind(this);
    }

    /**
     * 当表单发生分页变化、过滤器变化、或者排序器变化时，应该从服务器重新加载数据
     * @param {*} pagination 
     * @param {*} filters 
     * @param {*} sorter 
     */
    onTableChange(pagination, filters={}, sorter={}) {
        const {pageSize,current}=pagination;
        return model.methods.list(current,pageSize /* ,condition */)
            .then(result=&gt;{
                const {count,rows}=result;
                const pagination = Object.assign({}, this.state.pagination );
                pagination.total = count;
                this.setState({ loading: false, data: rows, pagination, });
            });
    }

    onRemove(record){
        return model.methods.remove(record.id)
            .then(resp=&gt;{
                console.log(resp);
                message.warning('删除成功');
            })
            // 刷新数据源
            .then(_=&gt;{
                return this.onTableChange(this.state.pagination);
            });
    }

    onEditFormSubmit(){
        return this.editForm.validateFields((err,values)=&gt;{
            if(!err){
                const {id}=this.state.currentRecord;
                model.methods.update(id,values)
                    .then(resp=&gt;{
                        message.success(`修改成功`);
                        console.log(resp);
                        this.setState({editModalVisible:false},()=&gt;{
                            // 刷新数据源
                            this.onTableChange(this.state.pagination);
                        });
                    })
            }
        });
        
    }

    onEditFormCancel(){
        this.setState({editModalVisible:false});
    }

    componentDidMount(){
        this.setState({loading:true},()=&gt;{
            return this.onTableChange(this.state.pagination);
        });
    }
    render() {
        const {Column,ColumnGroup}=Table;
        const fields=model.fields;
        return (&lt;div&gt;
        &lt;Table dataSource={this.state.data} pagination={this.state.pagination} loading={this.state.loading} onChange={this.onTableChange} &gt;
            { Object.keys(fields).map(k=&gt;{
                const field=fields[k];
                return &lt;Column title={field.title} key={k} dataIndex={k} /&gt;;
            }) }
            &lt;Column title='操作' key='action' render={(text, record) =&gt; (
                &lt;span&gt;
                    &lt;a onClick={()=&gt;{this.setState({editModalVisible:true,currentRecord:record});return false; }} &gt;修改&lt;/a&gt;
                    &lt;span className='ant-divider' /&gt;
                    &lt;Popconfirm title='确认要删除吗' okText='是' cancelText='否' onConfirm={() =&gt; { this.onRemove(record); }} &gt;
                        &lt;a href='#'&gt;删除&lt;/a&gt;
                    &lt;/Popconfirm&gt;
                    &lt;span className='ant-divider' /&gt;
                &lt;/span&gt;)} /&gt;
        &lt;/Table&gt;

        &lt;AddOrEditFormModal ref={form=&gt;this.editForm=form} visible={this.state.editModalVisible}
            initialValues={this.state.currentRecord}
            onOk={this.onEditFormSubmit}
            onCancel={this.onEditFormCancel}
        /&gt;

    &lt;/div&gt;);
    }
}
</code></pre>
<p>在这里，基于和上面同样的设想，我们把变化的部分提取到了<code>model</code>和<code>AddOrEditFormModal</code>这个<code>DecoratedFormComponent</code>中，从而可以创建这样形式的<code>API</code>：</p>
<pre><code class="language-js">(model,AddOrEditFormModal)=&gt; DatagridComponent;
</code></pre>
<p>为各种模型自动生成一个<code>Datagrid</code>组件。为了方便，我们还可以编写一个用于创建默认的<code>AddOrEditForm</code>的函数：</p>
<pre><code class="language-js">createDecoratedAddOrEditForm(PlainAddOrEditForm) =&gt; DecoratedFormComponent
</code></pre>
<p>这样，就可以利用<code>PlainAddOrEditForm</code>创建一个<code>DecoratedFormComponent</code>，再加上一个<code>model</code>定义，我们就可以自动生成最终的模型<code>Datagrid</code>组件。</p>
<h2>Admin UI 的自动生成</h2>
<p>为了方便，我们可以设计一个通用的<code>tiny-admin</code>模块，其基本结构为：</p>
<pre><code class="language-js">
// 默认提供的 DecoratedFormComponent 对象，有两个工厂函数，用于创建普通AddOrEdit表单、和带Modal表单
export const defaultDecoratedForm={

    createDecoratedAddOrEditForm:function(PlainAddOrEditForm){/**/},

    createDecoratedAddOrEditFormModal:function(PlainAddOrEditForm){/**/},  
};



export function addform(model,AddOrEditForm){/**/},

export function datagrid(model,AddOrEditFormModal){/**/ },
</code></pre>
<p>然后针对具体的模型编写<code>model</code>和<code>PlainAddOrEditForm</code>就可以自动生成后台了。</p>
<h2>示例</h2>
<p>比如对于一个角色模型，有角色名、和描述两个字段。</p>
<p><code>PlainAddOrEditForm</code>定义为：</p>
<pre><code class="language-js">
class PlainAddOrEditForm extends React.Component{
    constructor(props){
        super(props);
    }


    render(){
        const {getFieldDecorator,getFieldsError, getFieldError, isFieldTouched,validateFields}=this.props.form;
        const hasFieldError=(fieldname)=&gt;isFieldTouched(fieldname) &amp;&amp; getFieldError(fieldname);
        const hasErrors=(fieldsError)=&gt;Object.keys(fieldsError).some(field =&gt; fieldsError[field]);
        const FormItem=Form.Item;
        return (
        &lt;Form &gt;
            &lt;FormItem label='角色名' validateStatus={hasFieldError('name')} help={hasFieldError('name')||''} &gt;
            {
                getFieldDecorator('name',{
                    rules:[{required:true,message:'角色名必填'}],
                    initialValue:this.props.initialValues.name,
                })(
                    &lt;Input placeholder='角色名' /&gt;
                )
            }
            &lt;/FormItem&gt;
        
            &lt;FormItem label='描述' validateStatus={hasFieldError('description')} help={hasFieldError('description')||''} &gt;
            {
                getFieldDecorator('description',{
                    rules:[{required:true,message:'角色描述必填'}],
                    initialValue:this.props.initialValues.description,
                })(
                    &lt;Input placeholder='description' /&gt;
                )
            }
            &lt;/FormItem&gt;
        
        &lt;/Form&gt;);
        
    }
}

</code></pre>
<p>相应的<code>model</code>定义为：</p>
<pre><code class="language-js">const model={
    name:&quot;role&quot;,
    fields:{
        &quot;name&quot;:{
            title:'角色名',
        },
        &quot;description&quot;:{
            title:&quot;角色描述&quot;,
        },
    },
    methods:{
        create:function(record){
            const {name,description}=record;
            return createRole(name,description);
        },
        remove:removeRole,
        update:function(id,record){
            const{name,description}=record;
            return updateRole(id,name,description);
        },
        list:listRoles,
    }
};
</code></pre>
<p>生成一个用于创建角色的表单：</p>
<pre><code class="language-js">const AddOrEditForm=defaultDecoratedForm.createDecoratedAddOrEditForm(PlainAddOrEditForm);
const AddForm=addform(model,AddOrEditForm);
</code></pre>
<p>生成一个用于管理角色的<code>Datagrid</code>：</p>
<pre><code class="language-js">const AddOrEditFormModal=defaultDecoratedForm.createDecoratedAddOrEditFormModal(PlainAddOrEditForm);
const DG=datagrid(model,AddOrEditFormModal);
</code></pre>
<h2>主从式二级联动表单demo</h2>
<p>{% asset_img &quot;datagrid_admin_demo.gif&quot; &quot;datagrid admin demo&quot; %}</p>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <div class="container">
      <div class="container has-text-centered">
        <a href="posts/page13.html">
          Previous
        </a>
        15 of 32
        <a href="posts/page15.html">
          Next
        </a>
      </div>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
      
 // 处理形如 <code>$E=mc^2$</code> 形式的公式
  var inlineMathNodes=document.querySelectorAll('code');
  var re=/^\$(.*)\$$/;
  for(var j=0;j<inlineMathNodes.length;j++){
    var result=re.exec(inlineMathNodes.item(j).innerText);
    if(result!==null){
      katex.render(result[1], inlineMathNodes.item(j));
    }
  }
  function removeNode(node){
    if(node.remove){
      node.remove();
    }else{
      return first.parentNode.removeChild(node);
    }
  };

  // 查找所有 pre code.language-math 节点 以备筛出数据公式
  var nodes=document.querySelectorAll("pre code.language-math");
  for(var i=0;i<nodes.length;i++){
    var node=nodes.item(i);
    // 魔术标记所在行 
    try{
      var lines = node.innerText.split('\n');
      if((!!lines) && lines.length > 0)
      {
        var first = lines[0];
        if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
          var views = "";
          // 逐行渲染
          for(var k=1; k <lines.length; k++){
              var f=lines[k];
              views += katex.renderToString(f);
          }
          // 消除父级嵌套 
          try{
            node.innerHTML=views;
          }catch(e){
            // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
            console.log('IE9 sucks',e);
            $(tr).html(node.innerHTML);
          }
        }
      }
    }
    catch(err){
      console.log(err)
    }
  }
    
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>