<!DOCTYPE html><html>
  <head>

        <script type="text/javascript">
          var wsUri = "ws://localhost:8080/websocket";
      function init()
      {
        websocket = new WebSocket(wsUri);
        websocket.onclose = function(evt) { onClose(evt) };
      }
      function onClose(evt)
      {
        console.log('closing');
        websocket.close();
        document.location.reload();
      }
      window.addEventListener("load", init, false);
      </script>
            <meta charSet="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>
      Sample Fornax blog
    </title>
    <base href="/newbienewbie/"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.8.0/css/bulma.min.css"/>
    <link rel="stylesheet" type="text/css" href="style/style.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark-reasonable.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  </head>
  <body>
    <nav class="navbar">
      <div class="container">
        <div class="navbar-brand">
          <a class="navbar-item" href="">
            <img src="images/bulma.png" alt="Logo"/>
          </a>
          <span class="navbar-burger burger" data-target="navbarMenu">
            <span></span>
            <span></span>
            <span></span>
          </span>
        </div>
        <div id="navbarMenu" class="navbar-menu">
          <a class="navbar-item is-active" href="">
            Home
          </a>
          <a class="navbar-item" href="about.html">
            About
          </a>
          <a class="navbar-item" href="contact.html">
            Contact
          </a>
        </div>
      </div>
    </nav>
    <section class="hero is-info is-medium is-bold">
      <div class="hero-body">
        <div class="container has-text-centered">
          <h1 class="title">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit
          </h1>
        </div>
      </div>
    </section>
    <div class="container">
      <section class="articles">
        <div class="column is-8 is-offset-2">
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/DesignPattern/责任链模式的一种实现方式.html">
                    责任链模式的一种实现方式
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-06-03
                </p>
              </div>
              <div class="content article-body">
                <p><code>Java</code> 是一门讲究模式的语言（笑）。用其实现责任链模式，传统的做法都为上一个处理器设置好下一个处理器，然后依次调用。也就是说，每个处理器都要意识到下个处理器的存在。我个人觉得这解耦的不够完全——更好的效果是要让每一个处理器意识不到下一个处理器的存在。</p>
<p>对于<code>JavaScript</code>这种动态语言而言，可以借助函数对象实现出一种更优雅的责任链模式——并不是说<code>Java</code>无法实现这种这种优雅的方式，只是用<code>JavaScript</code>这种动态语言实现更方便。</p>
<h2>回归本质——责任链的基本思想</h2>
<p>所谓责任链处理模式，是把要做的某一件事，交由一系列处理器依次处理，每个处理器只完成自己的职责，一旦完成之后就交由下一个处理器处理。</p>
<p>这里用<code>JavaScript</code>来描述这个思想，假设有三个处理器函数（<code>Handler</code>），每个函数都以回调的方式触发下一个调用。</p>
<pre><code class="language-JavaScript">const f1=(next)=&gt;{
    console.log(`f1`);
    next();
};
const f2=(next)=&gt;{
    console.log(`f2`);
    next();
};
const f3=(next)=&gt;{
    console.log(`f3`);
    next();
};

const array=[f1,f2,f3];
</code></pre>
<p>我们想依次调用 <code>f1</code>、<code>f2</code>、<code>f3</code>三个处理器函数，最直观的思路是：</p>
<pre><code class="language-JavaScript">f1(f2(f3))
</code></pre>
<h2>更优雅的处理方式</h2>
<p>上面这种回调传参的写法显然不够优雅，假如我们有一百个这样的处理器函数想依次调用呢？一种比较好的思路是把它们封装为一个包装函数，然后调用这个包装函数，从而自动触发所有处理器函数的依次调用。</p>
<p>观察到这里的处理器数组，有如下特点：</p>
<ul>
<li>最后一个处理器是最后第二个处理器函数的回调函数，</li>
<li>最后第二个处理器是最后第三个的回调函数，</li>
<li>……</li>
<li>最后第<code>n</code>个处理器函数总是最后第<code>n+1</code>个处理器函数的回调</li>
<li>……</li>
<li>第二个是第一个处理器的回调函数</li>
</ul>
<p>对于处理器数组，取两个紧邻的处理器分析。为方便起见，记左边的处理器函数为<code>fl</code>，记右边的处理器为<code>fr</code>，则右边的处理器<code>fr</code>应作为左边的处理器<code>fl</code>回调。这样形成的包装函数为：</p>
<pre><code class="language-JavaScript">()=&gt;{
    return fl(fr);
}
</code></pre>
<p>于是，可以针对函数数组的每个元素，都这么两两处理，从而针对整个函数数组的所有处理器合成出一个包装函数：</p>
<pre><code class="language-JavaScript">const f=array.reduceRight(
    (p,c,i,a)=&gt;()=&gt; c(p) ,
    ()=&gt;{console.log(`done`);} // 作为最后一个函数的 next 参数
);
</code></pre>
<p>调用这个合成的包装函数，即可依次触发相关处理器：</p>
<pre><code class="language-JavaScript">// 调用合成的包装函数：
f();

// 最终输出为：
// f1
// f2
// f3
// done
</code></pre>
<h2>通用容器</h2>
<p>有了上面的思路，我们很容易实现一个通用容器，一旦用户在容器中注册一系列相关函数，即可触发自动调用——如同<code>Express</code>和<code>Koa</code>那样。</p>
<p>通常，处理函数都有相同的目标处理对象，有很多这样的使用场景：</p>
<ul>
<li><code>Java Servlet</code>的<code>Filter API</code></li>
<li><code>Express</code>的<code>req</code>、<code>res</code></li>
<li><code>Koa</code> 的<code>ctx</code></li>
</ul>
<p>我们不妨引入一个上下文对象<code>context</code>作为其参数。假定每一个处理器函数原型都是：</p>
<pre><code class="language-JavaScript">function(context, next){
    // 修改context，然后在合适的时候，以同步或者异步的方式触发 next() 调用
}
</code></pre>
<p>可以编写这样一个通用容器：</p>
<pre><code class="language-JavaScript">
const container={

    // 私有中间件数组，用于存储一系列处理函数
    _middlewares:[],
    
    use(fn){
        this._middlewares.push(fn);
    },
    
    run(context={}){
    
        // 把数组中的每一个函数两两组合，封装得到最终的包装函数
        const wrapper=this._middlewares.reduceRight(
            (p,c,i,a)=&gt;{ return ()=&gt;c(context,p); },// 自右向左
            ()=&gt;{console.log(`done!`);}
        );
        
        // 调用
        wrapper();
    }
};

</code></pre>
<p>于是，可以编写这样的客户端程序来使用这个容器:</p>
<pre><code class="language-JavaScript">container.use((context, next) =&gt; {
  console.log(`process context with f1`);
  next();
})

container.use((context, next) =&gt; {
  console.log(`process context with f2`);
  next();
})

container.use((context, next) =&gt; {
  console.log(`process context with f3`);
  next()
})
</code></pre>
<p>运行容器，即可自动依次执行：</p>
<pre><code class="language-JavaScript">container.run() 
</code></pre>
<p>显而易见，这种责任链容器是支持异步的。</p>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/ECMAScript/Redux/Redux-30分钟极速入门.html">
                    Redux 30分钟极速入门
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-05-10
                </p>
              </div>
              <div class="content article-body">
                <h2>Redux 世界观</h2>
<p><code>Redux</code>遵从的是<code>Flux</code>模式，本质上就是一个 <code>event dispatcher</code>。</p>
<p>由于<code>React</code> 提供了<code>数据-&gt;视图</code>的映射，如果改变<code>数据</code>，<code>React</code>就会自动渲染出相应的<code>视图</code>。为了处理复杂的情况，比如各种用户点击、各种远程加载，传统的方式，可能是为组件添加各种事件监听器，一旦监听器被触发，就执行相关代码逻辑，然后计算出相关数据，最后通过<code>setState()</code>改变状态，从而自动渲染出新的视图。但是当应用复杂度增加到一定数量级时，代码会越来越不可控，也就是说，我们需要单独提炼出一个管理数据的功能，以让<code>React</code>根据数据自动渲染视图。</p>
<p><code>Redux</code>的核心工作就是管理数据，具体而言就是:</p>
<ol>
<li>视图可以在某种情况下创建动作并予以触发</li>
<li>根据当前状态、和所触发动作，生成新的状态</li>
<li><code>React</code>根据新的状态渲染新的视图</li>
</ol>
<p><code>Redux</code>和<code>React</code>是独立的、互不耦合的，其负责的工作就是管理数据，所以为了简单起见，以下我们不再讨论<code>React</code>，只根据纯<code>JavaScript</code>讨论怎么利用<code>Redux</code>管理状态。</p>
<h2>Store 、Action、和 Reducer</h2>
<p>既然<code>Redux</code>是用来管理数据的，那么就需要一个地方来存储数据、然后提供修改数据的机制。这个机制的核心在于<code>store</code>——用于存储<code>state</code>、调度<code>action</code>。</p>
<p><code>Store</code>的功能包括：</p>
<ol>
<li>维持应用状态(state)； 提供 getState() 方法获取 state；</li>
<li>调度动作：提供 dispatch(action) 方法更新 state；</li>
<li>订阅管理：通过 var unsubscribe=subscribe(listener) 注册监听器、注销监听器。</li>
</ol>
<h3>Action</h3>
<p><code>action</code>就是用于改变状态的<code>payload</code>，或者说是一种事件——描述了想要发生的事。它和<code>Sysmfony</code>中的<a href="http://www.itminus.com/2015/04/10/WindWhisper/PHP/Symfony/Symfony-EventDispatcher/">Event</a>作用是一致的。</p>
<p>假设我们有一个任务系统，包括两种任务动作分类，一是探索、而是完成，则可以这样定义<code>action</code>:</p>
<pre><code class="language-JavaScript">// 定义各种 Action 分类字符串常量
const ACTIONS={ QUEST:'task.quest', COMPLETE:'task.complete', };

// 用于创建动作: quest
function quest(ebook){
    return { type:ACTIONS.QUEST, value:ebook, };
}

// 用于创建动作: complete
function complete(ebook){
    return { type:ACTIONS.COMPLETE, value:ebook, };
}

module.exports={ ACTIONS, quest, complete, };
</code></pre>
<h3>Reducer</h3>
<p>上文已经规定了<code>action</code>，但是只定义要发生什么还不够，我们还要定义当发生<code>action</code>的时候程序如何响应。这部分工作便是<code>reducer()</code>函数的职责。本质上，<code>reducer</code>所做的就是实现:</p>
<pre><code class="language-JavaScript">(当前状态,动作)=&gt;新状态。
</code></pre>
<p>完成这种转换的函数，即可称之为<code>reducer</code>。</p>
<p>针对上文的<code>action</code>，编写如下<code>reducer</code>函数:</p>
<pre><code class="language-JavaScript">const taskActions=require('../actions/task');

const reducer = function (state = {}, action) {
    switch (action.type) {
        case taskActions.ACTIONS.QUEST:
            // 这里输出到控制台只是为了方便追踪代码，实际上由于最后返回新的 state，React会自动渲染出新的视图
            console.log(`test ${action.type}\t${action.value}`);
            return Object.assign({},state, {message: action.value})
        case taskActions.ACTIONS.COMPLETE:
            // 这里输出到控制台只是为了方便追踪代码，实际上由于最后返回新的 state，React会自动渲染出新的视图
            console.log(`test ${action.type}\t${action.value}`);
            return Object.assign({},state, {message: action.value})
        default:
            return state;
    }
}
module.exports=reducer;
</code></pre>
<h3>Store</h3>
<p>迄今为止，我们写的都是不涉及其他任何库的<code>plain JavaScript</code>代码(当然也无关于<code>redux</code>库)。从现在开始，我们要引入<code>redux</code>库的几个最核心的函数(每一个都非常简单，有源码说明)。</p>
<h4>创建<code>store</code></h4>
<p><code>store</code> 是<code>Redux</code>的核心，<code>Redux</code>提供了<code>createStore()</code>函数来创建<code>store</code></p>
<p><code>createStore()</code>函数核心源码非常简单：</p>
<pre><code class="language-JavaScript">function createStore(reducer, preloadedState, enhancer) {
    // ... 
    
    var currentReducer = reducer
    var currentState = preloadedState
    var currentListeners = []
    var nextListeners = currentListeners
    var isDispatching = false
    
    function getState() { return currentState ;} 

    function subscribe(listener) {/**/ }
    
    function dispatch(action) {
        
        // ... 必要的检查
        
        // 调用 reducer() 
        try {
            isDispatching = true
            currentState = currentReducer(currentState, action)
        } finally {
            isDispatching = false
        }

        // ... 逐一调用监听器
        
        return action
    }
        
    function replaceReducer(nextReducer) { /**/ }
    
    function observable() {/**/}
    
    // 初始触发一次
    dispatch({ type: ActionTypes.INIT })
    
    return { dispatch, subscribe, getState, replaceReducer, [$$observable]: observable }
}
</code></pre>
<p>从这里的源码顺带可以知道，<code>store.dispath(action)</code>最核心的功能就是调用<code>reducer(currentState,action)</code>函数</p>
<p>利用<code>createStore</code>创建<code>store</code>:</p>
<pre><code class="language-JavaScript">const {createStore}=require('redux');
const reducer=require('./reducers');

const store = createStore(reducer);
</code></pre>
<h4>调度<code>action</code></h4>
<p>调度动作这一步实际上可以拆分为两小步：</p>
<ul>
<li>创建动作：由动作创建器创建动作</li>
<li>派发动作：由<code>store.dispatch()</code>派发动作触发<code>reducer</code></li>
</ul>
<p>对于上述的任务系统，对<code>action</code>进行调度：</p>
<pre><code class="language-JavaScript">let taskActions= require('./actions/task');

// 创建动作
const questAction=taskActions.quest('hello,world');
// 派发动作
store.dispatch(questAction);
</code></pre>
<p>输出为：</p>
<pre><code>test task.quest hello,world
</code></pre>
<h4>创建<code>action</code>后自动触发调度</h4>
<p>可以通过装饰器的思想，构造一个同名函数，每次创建动作就可以自动触发动作派发，从而避免每次手工<code>dispatch</code>。</p>
<p><code>bindActionCreators()</code>就是这样一个函数：绑定各个 <code>action creator</code> 到 <code>dispatch</code> —— 把相应 <code>action creator</code> 包装成会自动触发<code>dispatch</code>动作的对象。</p>
<p>首先看下用于单个绑定的<code>bindActonCreator()</code>装饰器，其实现类似于：</p>
<pre><code class="language-JavaScript">function bindActionCreator(actionCreator, dispatch){
    return function(){
        return dispatch(actionCreator.apply(undefined, arguments));
    };
}
</code></pre>
<p>此函数非常简单，返回一个函数对象，经调用后将生成<code>action</code>并触发<code>dispatch</code>调用。</p>
<p>而<code>bindActionCreators()</code>可以理解为<code>bindActionCreator()</code>的批量模式：</p>
<pre><code class="language-JavaScript">function bindActionCreators(actionCreators, dispatch){
    if (typeof actionCreators === 'function') {
        return bindActionCreator(actionCreators, dispatch);
    }
    
    if (typeof actionCreators !== 'object' || actionCreators === null) {
        throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write &quot;import ActionCreators from&quot; instead of &quot;import * as ActionCreators from&quot;?');
    }
    
    var keys = Object.keys(actionCreators);
    var boundActionCreators = {};
    for (var i = 0; i &lt; keys.length; i++) {
        var key = keys[i];
        var actionCreator = actionCreators[key];
        if (typeof actionCreator === 'function') {
            boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
        }
    }
    return boundActionCreators;
}
</code></pre>
<p>有了<code>bindActionCreators</code>，就可以批量完成动作创建器到调度的绑定，从而实现自动调度：</p>
<pre><code class="language-JavaScript">const {bindActionCreators}=require('redux');
// 装饰
taskActions=bindActionCreators(taskActions,store.dispatch);

// 创建后自动派发动作
taskActions.quest('hello,world');
taskActions.complete('fuck,world');
</code></pre>
<p>输出为：</p>
<pre><code>test task.quest hello,world
test task.complete      fuck,world
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/Python/Python-属性搜索链、descriptor-与-property.html">
                    Python 属性搜索链、descriptor 与@property
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-04-20
                </p>
              </div>
              <div class="content article-body">
                <h2><code>__dict__</code> 魔法属性</h2>
<p>在类的内部，实例是用字典来实现的，可以用实例的 <code>__dict__</code> 属性访问该字典，这个字典包含的数据对每个实例都是唯一的。</p>
<p><code>__dict__</code>表示一个对象的内部字段或者映射，用于存储对象属性，默认情况下，<code>Python</code>将对象的自定义成员以键值对的形式保存到<code>__dict__</code>字典中。</p>
<pre><code class="language-python">class MyClass(object):
    greetings = &quot;hello,world&quot;

mc=MyClass()
mc.greetings=&quot;Fuck,world&quot;
</code></pre>
<p>这里<code>MyClass</code>这个类对象有一个<code>__dict__</code>字典，内部存储了属性<code>greetings</code>及其值<code>hello,world</code>，现在其实例对象<code>mc</code>也有一个<code>__dict__</code>字典，内部存储了<code>greetings=&quot;Fuck,world&quot;</code>。</p>
<p>在任何时候，向对象上添加属性，都会改变到<code>__dict__</code>属性上，而任何时候对<code>__dict__</code>的修改，也会同步反应到属性中。</p>
<p>默认情况下，</p>
<pre><code class="language-python">obj.keyname=value
</code></pre>
<p>等价于：</p>
<pre><code class="language-python">obj.__setattr__(keyname,value)
</code></pre>
<p>这两个方法都会修改<code>__dict__</code>。但是如果对象是一个property或者一个描述符，属性的设置和删除将由相关联的函数执行。</p>
<p>观察一个有意思的案例：</p>
<pre><code class="language-python">class Rectangle(object):
    def __init__(self,width,height):
        self.__width=width
        self.__height=height
    
    @property
    def width(self):
        return self.__width

    @width.setter
    def width(self,value):
        self.__width=value

    @property
    def height(self):
        return self.__height
    @height.setter
    def height(self,value):
        self.__height=value
    
rect=Rectangle(3,4)

print(rect.__dict__)
print(Rectangle.__dict__)
</code></pre>
<p>输出类似于：</p>
<pre><code class="language-python">{'_Rectangle__width': 3, '_Rectangle__height': 4}
</code></pre>
<p>和</p>
<pre><code class="language-python">{'__module__': '__main__', 'height': &lt;property object at 0x0000000002E105E8&gt;, 'width': &lt;property object at 0x0000000002E10638&gt;, '__dict__': &lt;attribute '__dict__' of 'Rectangle' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Rectangle' objects&gt;, '__doc__': None, '__init__': &lt;function __init__ at 0x0000000002E126D8&gt;}
</code></pre>
<ol>
<li>类的每个实例都有自己的 <code>__dict__</code>，</li>
<li>类自身也是一个对象，也有 <code>__dict__</code> ，其中存储了attribute、property等</li>
</ol>
<h2>属性查找</h2>
<p>属性查找的关键是两个魔法方法。</p>
<h3><code>__getattribute__</code>:</h3>
<pre><code class="language-Python">obj.__getattribute__(self, name)
</code></pre>
<p>当访问属性时，此方法会被调用。返回属性值或者引发<code>AttributeError</code> 异常。</p>
<p>注意此方法相对于 <code>__getattr__()</code> 方法拥有绝对优先权，除非 <code>__getattribute__()</code> 内部显式去调用 <code>__getattr__()</code> 或者引发 <code>AttributeError</code>，否则即使定义了 <code>__getattr__()</code> ，也不会去调用。默认情况下，<code>__getattribute__()</code>，会优先调用<code>data descriptor</code>，然后是实例字典，然后是<code>non-data descriptor</code>，这留待后文详述。</p>
<h3><code>__getattr__</code>:</h3>
<pre><code class="language-Python">obj.__getattr__(self,name)
</code></pre>
<p>当<code>obj.__getattribute__(name)</code>找不到相应属性，才会发生调用。这是一个兜底方法，要么返回 attribute value，要么抛出 <code>AttributeError</code>异常。</p>
<h3>查找顺序</h3>
<p>在<code>Python</code>中查找属性时，<code>Python</code>将调用特殊方法<code>obj.__getattribute__(keyname)</code>，先搜索相关属性；如果搜索失败，<code>Python</code>将试图调用类的<code>__getattr__()</code>方法（如果已经定义）；如果还是失败，就抛出<code>AttributeError</code>。</p>
<h2>属性设置和删除函数</h2>
<p><code>Python</code>中，属性的查找通常要回溯到实例的类、超类，这种回溯有利于对象属性的共享；但是属性的赋值、删除更新的是实例字段，永远不会更新类的字典。</p>
<p>在属性进行赋值、删除时候，如果类中定义了<code>__setattr__()</code>、<code>__delattr__()</code>方法 ，则会被调用。</p>
<ol>
<li>属性设置</li>
</ol>
<pre><code class="language-python">obj.__setattr__(self,name,value)
</code></pre>
<p>当属性赋值的时候触发调用，通常的实现会调用 <code>self.__dict__[name]=value</code></p>
<ol start="2">
<li>属性删除</li>
</ol>
<p>等价于</p>
<pre><code class="language-python">obj.__delattr__(self,name)
</code></pre>
<p>当执行 <code>del obj.name</code>的时候触发调用。这些方法的默认行为是修改或者删除 obj 的局部 <code>__dict__</code>值，除非请求的属性是一个 property 或者描述符。</p>
<h2>descriptor</h2>
<p><code>descriptor</code>(描述符)是本质上是一种拥有绑定行为的对象属性——其属性访问行为（<code>get</code>、<code>set</code>、<code>delete</code>）被 <code>__get__()</code>, <code>__set__()</code>, 和 <code>__delete__()</code>所重写。如果一个对象定义了这三个方法中的任意一个，它即称为一个<code>descriptor</code>。而所谓<code>descriptor</code>协议，其实就是以下三个方法(不一定要全部实现，有任意一个都行）：</p>
<pre><code class="language-Python">descr.__get__(self, obj, type=None) --&gt; value

descr.__set__(self, obj, value) --&gt; None

descr.__delete__(self, obj) --&gt; None
</code></pre>
<p>我们知道，默认情况下属性访问会从对象的字典进行 <code>get</code>、<code>set</code>、<code>delete</code>操作，例如，<code>a.x</code>会先搜索<code>a.__dict__['x']</code>，然后搜索<code>type(a)__dict__['x']</code>，然后继续再在<code>type(a)</code>的基类上找，如此不停寻找（不会找到<code>metaclass</code>）。然而，如果所搜索的值定义了<code>descriptor</code>方法之一，那么<code>Python</code>就会转而调用描述符方法.</p>
<p>举一个简单的例子:</p>
<pre><code class="language-python">class MyDescriptor(object):

    def __init__(self, init_val=None ):
        self.val = init_val

    def __get__(self, obj, objtype):
        return self.val

    def __set__(self, obj, val):
        self.val = val


class MyClass(object):
    x = MyDescriptor(10)

print(MyClass.__dict__['x'])
print(MyClass.__dict__['x'].__set__)
print(MyClass.__dict__['x'].__get__)
</code></pre>
<p>描述符可以分为两种：如果一个描述符只定义了<code>__get__()</code>，称之为<code>non-data descriptor</code>，如果一个描述符同时定义了<code>__get__()</code>、<code>__set__()</code>，则称之为<code>data descriptor</code>。</p>
<ol>
<li>如果一个实例的 <em>字典</em> 中，有一项和 <em>描述符对象</em> 有同样的名字，且该描述符是<code>non-data descriptor</code>，则该实例的 <em>字典</em> 优先</li>
<li>如果一个实例的 <em>字典</em> 中，有一个项和 <em>描述符对象</em> 有同样名字，且该描述符是<code>data descriptor</code>，则该 <em>描述符对象</em> 优先</li>
</ol>
<p>关于<code>data descriptor</code>和<code>non-data descriptor</code>的很重要一点区别在于，由于<code>data descriptor</code>优先级更高，属性访问操作和实例的<code>__dict__</code>并不关联；而<code>non-data descriptor</code>则不然，其优先级比实例的字典<code>__dict__</code>更低，故属性访问实际上是在操作<code>__dict__</code>属性。举个例子：</p>
<pre><code class="language-python">class NonDataDescriptor(object):
    def __init__(self,key,value):
        self.key=key
        self.value=value

    def __get__(self,obj,objtype):
        return self.value
    
class DataDescriptor(object):
    def __init__(self,key,value):
        self.key=key
        self.value=value

    def __get__(self,obj,objtype):
        return self.value
    
    def __set__(self,obj,value):
        self.value=&quot;### &quot;+value

class MyClass(object):
    greeting1=NonDataDescriptor(&quot;greeting1&quot;,&quot;### Hello,world&quot;)
    greeting2=DataDescriptor(&quot;greeting2&quot;,&quot;### Hello,world&quot;)

mc=MyClass()
print(mc.greeting1)         # 这里，会输出 '### Hello,world'
mc.greeting1=&quot;Fuck,world&quot;   # 这里，其实是在设置mc.__dict__属性
mc.greeting2=&quot;Fuck,world&quot;   # 这里，并不会去操作mc.__dict__属性
print(mc.__dict__)          # 这里，输出的是 {'greeting1': 'Fuck,world'}
</code></pre>
<h3>描述符<code>__get__()</code>方法的调用优先级</h3>
<p>属性查找的默认优先级别链为：</p>
<ol>
<li><code>data descriptor</code>优先级最高</li>
<li><code>instance variables</code> 优先级次之</li>
<li><code>non-data descriptor</code> 优先级再次之</li>
<li><code>__getattr__()</code> 优先级最低</li>
</ol>
<p>具体调用细节还得区分<code>obj</code>是类和普通对象。
对于对象的<code>data descriptor</code>属性访问，根据<code>object.__getattribute__(self,name)</code>方法，会将<code>b.d</code>的调用转换为了<code>type(b).__dict__['d'].__get__(b,type(b))</code>，注意，这里先去类的<code>__dict__</code>找，然后再调用所找到的描述符的<code>__get__()</code>方法。
对于类的<code>data descriptor</code>，根据<code>type.__getattribute()__</code>方法，会将<code>B.d</code>转换为了<code>B.__dict__['d'].__get___(None,B)</code>，根据<a href="https://docs.python.org/3/howto/descriptor.html"><code>Python</code>官方文档</a>，基本上等同于：</p>
<pre><code class="language-python">def __getattribute__(self, key):
    &quot;Emulate type_getattro() in Objects/typeobject.c&quot;
    v = object.__getattribute__(self, key)
    if hasattr(v, '__get__'):
        return v.__get__(None, self)
    return v
</code></pre>
<p>不管怎么说，<code>descriptor</code>的<code>__get__()</code>方法是用<code>__getattribute__()</code>方法调用的。如果覆盖<code>__getattribute__()</code>方法，则默认的描述符方法调用行为也会被改写。</p>
<h3>描述符<code>__set__()</code>方法和<code>__setattr__()</code>的调用优先级</h3>
<p>实例的属性查找通常需要回溯到超类，而实例属性的设置、删除比然只会操作自身的<code>__dict__</code>字典，不会影响到父类。与这种不对称性相类似的还有<code>__setattr__()</code>方法和<code>__getattr__()</code>相对于<code>descriptor</code>的优先级不对称性！<code>__getattr__()</code>相对于<code>descriptor</code>有最低的优先级；而相对于<code>__set__()</code>，<code>__setattr__()</code>的优先级却更高！</p>
<p>举个例子:</p>
<pre><code class="language-python">class DataDescriptor(object):
    def __init__(self,key,value):
        self.key=key
        self.value=value

    def __get__(self,obj,objtype):
        return self.value
    
    def __set__(self,obj,value):
        print(&quot;### __set__() called : &quot;+ self.key + &quot; = &quot; +value)
        self.value=&quot;### &quot;+value

class MyClass(object):
    greeting2=DataDescriptor(&quot;greeting2&quot;,&quot;### Hello,world&quot;)

    def __getattr__(self,name):
        return object.__getattr__(self,name)

    def __setattr__(self,name,value):
        print(&quot;@@@ __setattr__() called : &quot;+ name +&quot; = &quot; + value)
        self.__dict__[name]=&quot;@@@ &quot;+value

mc=MyClass()
mc.greeting2=&quot;Fuck,world&quot;   # 这里，并不会去操作mc.__dict__属性
print(mc.greeting2)         # 这里，会输出什么？ 是`### Hello,world` !!
print(mc.__dict__)          # 这里，输出的是 {'greeting1': '@@@ Fuck,world'}
</code></pre>
<p>输出的结果是:</p>
<pre><code>@@@ __setattr__() called : greeting2 = Fuck,world
### Hello,world
{'greeting2': '@@@ Fuck,world'}
</code></pre>
<p>这里有两个需要注意的地方：</p>
<ol>
<li>对MyClass的实例<code>mc</code>调用<code>mc.__setattr__()</code>方法，并没有触发<code>data descriptor</code>调用。从而改写了对象实例的<code>__dict__</code></li>
<li>对实例<code>mc</code>调用<code>mc.greeting2</code>，尽管实例的<code>__dict__</code>中存储了<code>greeting2</code>，但是由于<code>data descriptor</code>优先级更高，所以返回的仍然是描述符初始化的<code>### Hello,world</code>。</li>
</ol>
<h3>描述符与对象方法调用机制</h3>
<p>当方法被实例以<code>obj.func()</code>的形式调用，其实可以分成两步：首先会进行属性查找，由于是个<code>descriptor</code>，这一步会利用<code>__get__()</code>返回绑定了<code>self</code>的函数；然后再对函数对象进行调用。</p>
<p>最终从形式上看，<code>obj.f(*args)</code>的调用等同于<code>f(obj, *args)</code>。其内部机理在于类字典中将方法作为函数来存储，而所有的方法都是定义了<code>__get__()</code>的<code>non-data descriptor</code>。这样每次查找方法时，都会利用描述符的<code>__get__()</code>取到绑定了<code>self</code>对象的相应函数。</p>
<p>类似的，对于<code>classmethod</code>(类方法)，也会进行绑定，不过绑定对象变成了类。而对于<code>staticmethod</code>(静态方法)，则无需绑定，直接返回原函数。</p>
<table>
<thead>
<tr>
<th>Transformation</th>
<th>Called from an Object</th>
<th>Called from a Class</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>function</code></td>
<td><code>f(obj, *args)</code></td>
<td><code>f(*args)</code></td>
</tr>
<tr>
<td><code>classmethod</code></td>
<td><code>f(type(obj), *args)</code></td>
<td><code>f(klass, *args)</code></td>
</tr>
<tr>
<td><code>staticmethod</code></td>
<td><code>f(*args)</code></td>
<td><code>f(*args)</code></td>
</tr>
</tbody>
</table>
<pre><code class="language-python">class StaticMethod(object):
    &quot;Emulate PyStaticMethod_Type() in Objects/funcobject.c&quot;

    def __init__(self, f):
        self.f = f

    def __get__(self, obj, objtype=None):
        return self.f
</code></pre>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/Boulevard/Database/Oracle/Oracle-12c-for-Linux-安装历险记.html">
                    Oracle 12c for Linux 安装历险记
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-03-22
                </p>
              </div>
              <div class="content article-body">
                <p>由于项目需要，申请搭建了个虚拟服务器。</p>
<p>硬件：</p>
<ul>
<li>Intel(R) Xeon(R) CPU E7-4830 v2 @ 2.20GHz，8核心 2处理器</li>
<li>MemTotal:       32677076 kB</li>
</ul>
<p>操作系统发行版：Oracle Linux Server release 6.8 （64位）</p>
<p>但是安装 Oracle Database 12c 数据库需要图形环境（当时不知道可以使用命令行的方式静默安装），下载好数据库，在建好相关账号、目录，修改内核参数之后，我让系统管理员开始双击执行<code>runInstaller</code>。
安装完毕系统管理员发来了消息：</p>
<blockquote>
<p>Oracle Enterprise Manager Database Express URL: https://EPBP:5500/em</p>
</blockquote>
<p>然后我在命令行调用命令：</p>
<pre><code>$ wget https://127.0.0.1:5500/em
--2017-03-21 12:40:24--  https://127.0.0.1:5500/em
正在连接 127.0.0.1:5500... 失败：拒绝连接。
</code></pre>
<p>发现貌似服务没起来，系统管理员表示现在可以自己敲命令了呀，又不需要图形化。好吧，人也确实很忙，再说我跟人不熟，也不好意思再麻烦别人。</p>
<p>添加<code>$ORACLE_HOME/bin</code>到<code>PATH</code>,发现<code>emca</code>工具未安装成功：</p>
<pre><code>$ emca -version
Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=128M; support was removed in 8.0
Invalid syntax
</code></pre>
<p>在服务器上使用<code>sqlplus</code>简单测试：</p>
<pre><code>$ sqlplus '/as sysdba'
SQL&gt; select 2+2 from dual;

       2+2
----------
         4
</code></pre>
<p>其他<code>SQL</code>命令也正常，但是在本地通过<code>SQL Developer</code>尝试连接始终无法连接。</p>
<p>尝试重启启动</p>
<pre><code>SQL&gt; shutdown immediate
SQL&gt; startup mount
</code></pre>
<p>依然不正常，接着尝试关掉监听器后再启动：</p>
<pre><code>$ lsnrctl start

LSNRCTL for Linux: Version 12.2.0.1.0 - Production on 22-MAR-2017 11:20:44

Copyright (c) 1991, 2016, Oracle.  All rights reserved.

Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=EPBP)(PORT=1539)))
STATUS of the LISTENER
------------------------
Alias                     LISTENER
Version                   TNSLSNR for Linux: Version 12.2.0.1.0 - Production
Start Date                22-MAR-2017 11:18:50
Uptime                    0 days 0 hr. 1 min. 54 sec
Trace Level               off
Security                  ON: Local OS Authentication
SNMP                      OFF
Listener Parameter File   /home/oracle/app/oracle/product/12.2.0/dbhome_1/network/admin/listener.ora
Listener Log File         /home/oracle/app/oracle/diag/tnslsnr/EPBP/listener/alert/log.xml
Listening Endpoints Summary...
  (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=EPBP)(PORT=1539)))
  (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=EXTPROC1521)))
The listener supports no services
The command completed successfully
</code></pre>
<p>注意到：</p>
<blockquote>
<p>The listener supports no services</p>
</blockquote>
<p>数据库实例services没被注册监听，网上说可以手工注册解决：</p>
<blockquote>
<p>SQL&gt; alter system register;</p>
</blockquote>
<p>经尝试，无果。</p>
<p>然后尝试直接修改监听器的配置文件 <code>/home/oracle/app/oracle/product/12.2.0/dbhome_1/network/admin/listener.ora</code>，
根据<code>sid</code>追加<code>SID_LIST_LISTENER</code>配置，指定<code>Global Database Name</code>和本地实例的<code>SID</code>信息：</p>
<pre><code>LISTENER =
   (DESCRIPTION_LIST =
       (DESCRIPTION =
           (ADDRESS = (PROTOCOL = TCP)(HOST = EPBP)(PORT = 1539))
           (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))
       )
   )

SID_LIST_LISTENER =
   (SID_LIST =
       (SID_DESC =
           (GLOBAL_DBNAME = orcl)
           (SID_NAME = orcl)
       )
   )
</code></pre>
<p>重新加载配置文件：</p>
<pre><code>$ lsnrctl reload

LSNRCTL for Linux: Version 12.2.0.1.0 - Production on 22-MAR-2017 11:26:31

Copyright (c) 1991, 2016, Oracle.  All rights reserved.

Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=EPBP)(PORT=1539)))
The command completed successfully
[oracle@EPBP ~]$ lsnrctl status

LSNRCTL for Linux: Version 12.2.0.1.0 - Production on 22-MAR-2017 11:26:38

Copyright (c) 1991, 2016, Oracle.  All rights reserved.

Connecting to (DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=EPBP)(PORT=1539)))
STATUS of the LISTENER
------------------------
Alias                     LISTENER
Version                   TNSLSNR for Linux: Version 12.2.0.1.0 - Production
Start Date                22-MAR-2017 11:20:58
Uptime                    0 days 0 hr. 5 min. 40 sec
Trace Level               off
Security                  ON: Local OS Authentication
SNMP                      OFF
Listener Parameter File   /home/oracle/app/oracle/product/12.2.0/dbhome_1/network/admin/listener.ora
Listener Log File         /home/oracle/app/oracle/diag/tnslsnr/EPBP/listener/alert/log.xml
Listening Endpoints Summary...
  (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=EPBP)(PORT=1539)))
  (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=EXTPROC1521)))
Services Summary...
Service &quot;orcl&quot; has 1 instance(s).
  Instance &quot;orcl&quot;, status UNKNOWN, has 1 handler(s) for this service...
The command completed successfully
</code></pre>
<p>这时候发现<code>orcl</code>服务已经有了一个实例运行，但是使用<code>Sql Developer</code>连接，报错：</p>
<blockquote>
<p>ORA-01033: ORACLE 正在初始化或关闭</p>
</blockquote>
<p>直接在服务器上清除日志，打开数据库：</p>
<pre><code>SQL&gt; alter database clear logfile group 3;
SQL&gt; alter database open ;
</code></pre>
<p>再次尝试连接，成功。</p>

              </div>
            </div>
          </div>
          <div class="card article">
            <div class="card-content">
              <div class="media-content has-text-centered">
                <p class="title article-title">
                  <a href="posts/WindWhisper/Python/Python-类与三个内置装饰器.html">
                    Python 类与三个内置装饰器
                  </a>
                </p>
                <p class="subtitle is-6 article-subtitle">
                  <a href="#">
                    
                  </a>
                  on 2017-03-12
                </p>
              </div>
              <div class="content article-body">
                <p>在<a href="http://www.itminus.com/2015/04/10/WindWhisper/Python/Python%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">Python函数装饰器原理分析</a>中说到，Python有几个内置装饰器：</p>
<ul>
<li>类属性<code>@property</code></li>
<li>静态方法<code>@staticmethod</code></li>
<li>类方法<code>@classmethod</code></li>
</ul>
<p>可以用来包装属性、静态方法、和类方法。</p>
<p>首先要说明，本文中所有的类都使用的新式类，即使使用了Python2.7.x版本，某些特性在“old-style”类中也不适用。要使用新式类，有两种方法：</p>
<ol>
<li>在<code>module</code>顶部添加语句：<code>__metaclass__ = type</code></li>
<li>定义的类要是内置<code>object</code>对象的子类。</li>
</ol>
<h2><code>staticmethod</code>和<code>classmethod</code></h2>
<p>静态方法和类方法都是不需要具体实例就可以运行的。区别在于<code>classmethod</code>的第一个参数是<code>cls</code>，这是个对“类”的引用。可以通过<code>cls</code>对类的属性进行获取。</p>
<p>在没有装饰器的情况下，我们可以使用原始的<code>staticmethod()</code>和<code>classmethod()</code>函数来定义静态方法和类方法：</p>
<pre><code class="language-Python">class MyClass:
    
    a=3

    def my_static_method():
        print('This is a static method')
    my_static_method = staticmethod(my_static_method)

    def my_class_method(cls,sth):
        print('This is a class method of', cls.a,sth)
    my_class_method = classmethod(my_class_method)
</code></pre>
<p>有了装饰器语法糖，以上代码可以改写为：</p>
<pre><code class="language-Python">class MyClass:

    a=3

    @staticmethod
    def my_static_method():
        print('This is a static method')

    @classmethod
    def my_class_method(cls,sth):
        print('This is a class method of', cls.a,sth)
</code></pre>
<h2>property</h2>
<p>假设现在有个矩形，可以设置其宽、高。</p>
<ul>
<li>如果需要面积，我们可以使用类似于<code>area()</code>的方法来计算。</li>
<li>如果需要周长，我们可以使用类似于<code>perimeter()</code>的方法来计算。</li>
</ul>
<p>现在问题来了，类的用户获取宽度的时候用的是<code>rect.width</code>，获取面积的时候却要使用<code>rect.area()</code>，多了一个冒号！对于这种简单的情况用户似乎还可以分辨，问题是对于一些复杂的类如何保持一致呢？</p>
<p><code>Java</code>中的惯用方法是定义私有的<code>width</code>、<code>height</code>，然后定义公有方法<code>getWidth()</code>、<code>getHeight()</code>、<code>getArea()</code>、<code>getPerimeter()</code>。<code>C#</code>的惯用方法是采用：</p>
<pre><code class="language-CSharp">class Rectangle {
    public double Width { get; set; }
    public double Height { get; set; }
    public double Area {
        get{ return Width*Height; }
    }
    public double Perimeter {
        get{ return (Width+Height)*2; }
    }
}
</code></pre>
<p>对于<code>Python</code>这种动态语言来说，上<code>Java</code>那一套是不符合价值观的，可以用<code>perperty()</code>加以包装：</p>
<pre><code class="language-Python">class Rectangle(object):
    def __init__ (self,width,height):
        self.__width = width
        self.__height = height

    def get_width(self):
        return self.__width
    def set_width(self, size):
        self.__width= size
    width=property(get_width,set_width)
    
    def get_height(self):
        return self.__height
    def set_height(self,size):
        self.__height=size
    height=property(get_height,set_height)

    def area(self):
        return self.width*self.height
    area=property(area)
    

    def perimeter(self):
        return (self.width+self.height)*2
    perimeter=property(perimeter)
</code></pre>
<p>这样，就使用了<code>property()</code>函数包装出了<code>width</code>、<code>height</code>、<code>area</code>、<code>perimeter</code>三个特性:</p>
<pre><code class="language-Python">rect=Rectangle(3,4)
rect.width=5
rect.height=6
print(rect.width)
print(rect.height)
print(rect.area)
print(rect.perimeter)
</code></pre>
<p>有了装饰器语法，以上代码可以简化为：</p>
<pre><code class="language-Python">class Rectangle(object):
    def __init__ (self,width,height):
        self.__width = width
        self.__height = height

    @property
    def width(self):
        return self.__width
    
    @width.setter
    def width(self, size):
        self.__width= size
    
    @property
    def height(self):
        return self.__height
    
    @height.setter
    def height(self,size):
        self.__height=size

    @property
    def area(self):
        return self.width*self.height
    
    @property
    def perimeter(self):
        return (self.width+self.height)*2
</code></pre>
<h2>Property 魔法</h2>
<p>利用<code>@property</code>装饰一个方法函数，看起来非常完美。但是有一个问题，经过<code>property()</code>函数返回的还是一个函数，为什么<code>Python</code>可以直接通过<code>rect.width</code>这种普通属性语法拿到宽度值呢？</p>
<p>这其实是<code>Python</code>的魔法：<code>property</code>返回了一种特殊的属性，访问时会计算它的值！如果没有<code>property</code>，则会以简单属性的方式去访问。</p>
<p>事实上，<code>Python</code>类实例方法的调用也是很意思的，对于这样一个类：</p>
<pre><code class="language-Python">class Foo(object):
    def bar(self,x):
        return x
</code></pre>
<p>实例方法的调用某种程度上可以认为是这样：</p>
<pre><code class="language-Python">foo=Foo()
bar=foo.bar    # 这里返回的方法不是原始的bar函数，是绑定方法对象
bar(x)
</code></pre>
<p>首先获取 Foo 类的 bar 的绑定方法（<code>bound method</code>）对象，它类似于<code>partial</code>方法，已经绑定了<code>self</code>参数，显然，这个绑定方法并原始的函数对象 bar。绑定方法对象是由在后台执行的特性函数静默创建的！</p>
<p><code>@staticmethod</code> <code>@classmethod</code> 定义静态方法和类方法时，实际上就指定了使用不同的特性函数，以不同的方式处理对这些方法的访问。<code>staticmethod</code>表明按原样返回方法函数，不会进行任何包装。</p>

              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
    <div class="container">
      <div class="container has-text-centered">
        <a href="/posts/page16.html">
          Previous
        </a>
        18 of 32
        <a href="/posts/page18.html">
          Next
        </a>
      </div>
    </div>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.css" rel="stylesheet"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.1/katex.min.js"></script>
    <script>
      
 // 处理形如 <code>$E=mc^2$</code> 形式的公式
  var inlineMathNodes=document.querySelectorAll('code');
  var re=/^\$(.*)\$$/;
  for(var j=0;j<inlineMathNodes.length;j++){
    var result=re.exec(inlineMathNodes.item(j).innerText);
    if(result!==null){
      katex.render(result[1], inlineMathNodes.item(j));
    }
  }
  function removeNode(node){
    if(node.remove){
      node.remove();
    }else{
      return first.parentNode.removeChild(node);
    }
  };

  // 查找所有 pre code.language-math 节点 以备筛出数据公式
  var nodes=document.querySelectorAll("pre code.language-math");
  for(var i=0;i<nodes.length;i++){
    var node=nodes.item(i);
    // 魔术标记所在行 
    try{
      var lines = node.innerText.split('\n');
      if((!!lines) && lines.length > 0)
      {
        var first = lines[0];
        if(first.trim().match(/%%(\s?)*KaTeX(\s?)*/i)){
          var views = "";
          // 逐行渲染
          for(var k=1; k <lines.length; k++){
              var f=lines[k];
              views += katex.renderToString(f);
          }
          // 消除父级嵌套 
          try{
            node.innerHTML=views;
          }catch(e){
            // IE9 don't support the method of assignning value to tr.innerHTML. Maybe the code below will be removed in the future
            console.log('IE9 sucks',e);
            $(tr).html(node.innerHTML);
          }
        }
      }
    }
    catch(err){
      console.log(err)
    }
  }
    
    </script>
    <script>
      hljs.highlightAll();
    </script>
  </body>
</html>