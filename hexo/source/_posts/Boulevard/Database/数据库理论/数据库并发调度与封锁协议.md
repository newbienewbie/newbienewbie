---
layout: post
title: 数据库笔记 数据库并发调度与封锁协议
date: 2017-09-29 20:09:06
tags:
- 数据库
- 数据库理论 
- 并发操作
categories:
- 大道
- 数据库
- 数据库理论 
---

## 并发调度

### 事务

事务是在数据库上一个或者多个操作的序列，必须以原子的形式执行。当对数据库进行查询、或者更新的任何SQL语句开始时，事务就开始。

在SQL中事务的开始语句为` begin transaction`。

必须明确地结束一个事务。结束事务通常有两种方式：
* SQL语句 `COMMMIT` 提交事务，使得事务成功结束，事务对数据库的任何改变都将被存放到数据库中。
* SQL语句 `ROLLBACK` 回滚事务，使得事务不成功终止，事务对数据库的任何改变都将撤销。

事务管理必须具有四个特性：
* `acid` 原子性：事务的操作要么都做，要么都不做。
* `consistency` 一致性：当数据库只包含成功事务提交的结果时，称数据库处于一致性状态。事务的执行结果必须保证数据库从一个一致性状态到另一个一致性状态。
* `isolation` 隔离性：事务相互隔离，当多个事务并发执行，任一事务的更新操作直到其成功提交的整个过程，对其他事务不可见。
* `durability` 持久性：一旦事务成功提交，即使数据库崩溃，其对数据库的更新操作也将永久有效。

### 数据不一致

并发操作是指多用户可能对同一个数据进行操作。并发不正确调度会带来数据不一致问题，其主要原因是破坏了数据的 *隔离性* 。

<!-- more -->

数据不一致共有三种情况：
* `丢失修改(lost update)`： 事务T1、T2读入同一数据各自修改，T1先完成修改并将更新的数据写回数据库；随后T2也完成修改并将结果写回数据库，从而覆盖T1的修改，导致T1对数据的修改好像从未发生。
* `读脏数据(dirty read)`： 事务T1修改了某数据并将其写回数据库，事务T2 随之读入T1修改过的值，之后T1被撤销修改，则T2读取的值与数据库中的值不同。
* `不可重复读(non-repeatable read)`： 事务T1按一定条件读入若干数据，随后事务T2对其更新并写回数据库，当T1再次按照同一条件读入数据，发现跟刚才不一致。

### 可串行化调度

要保证并发操作得到正确的结果，可以去要求所有事务都是串行执行的——一个事务执行过程时完全不受其他事务影响，只有一个事务结束之后，另一个事务才开始运行。

但是在实际的执行方式上要求事务串行依次执行是不科学的，并发执行是基本需求。那么，怎么样的并发调度才能认为是对的？对于多个事务，其并发执行的结果只要和其中任意一种串行执行的结果相同，即认为是正确的调度，称之为可串行化的调度。

为了保证对并发操作的调度满足可串行化条件，数据库管理系统必须提供一定的手段，通常采用的是 *封锁机制*

## 封锁管理

*封锁* ： 事务在对数据对象操作前，先申请对其加锁，成功加锁之后，事务就对该数据对象有了控制权，只有该事务对其解锁之后，其他事务才能使用它。

### 封锁分类

封锁包括两类：
* `排他锁(exclusive lock，X lock)`：事务T对对象A加了X锁，则T可以读取和更新A；在T释放对A的X锁之前，其他事务不能再对A加任何类型的锁（从而不能读也不能写A）。
* `共享锁(share lock ，S lock)` : 事务T 对对象A加了S锁之后，T可以读取，但是不能更新A，在T释放对A的S锁之前，其他事务可以再对A进行加锁，但是不能加X锁。

### 封锁协议（`locking protocal`）

#### 三级封锁协议

*`一级封锁协议`*  ：要求事务T在修改数据A之前必须先对其加X锁，直到事务结束才释放该锁。该级协议解决了`丢失修改`问题。但是它不要求事务在读数据之前进行加锁，故不能解决`读脏数据`、`不可重复读取`问题。

*`二级封锁协议`* ：在`一级封锁协议`的基础上，要求事务T在读取数据A之前必须先对其加S锁，读入数据后立刻是否S锁。这样，不仅解决了`丢失修改`问题，还防止了`读脏数据`问题。但是该级协议不能解决`不可重复读取`问题，例如：

1. 现有事务T1，尝试读取A，加共享锁 lock-s(A)；读完之后立刻释放共享锁，unlock-s(A)。此时事务T1尚未继续。
2. 事务T2尝试修改A，加排他锁 lock-x(A)；T2事务执行完毕，释放排他锁，unlock-x(A)。
3. 事务T1再次尝试读取A，加共享锁 lock-s(A)，按照同一条件读取A之后，释放共享锁 unlock-s(A)。

此时，即出现了不可重复读问题。

*`三级封锁协议`* ：在`二级封锁协议`的基础上，要求事务T在读取A之前，必须先对其加S锁，但是直到事务结束，才释放S锁。`三级封锁协议`解决了`丢失修改`、`读脏数据`、`不可重复读`问题。

注意，和`二级封锁协议`规定的共享锁在读完数据后立即释放不同，`一级封锁协议`、`三级封锁协议`都要求锁一旦加上，直到事务结束之前，都不能释放。

### 两段锁协议（`two-phase locking`）

*两段锁协议* ： 事务T对数据A进行读写操作以前，必须先活得对A的封锁；并且，在释放一个封锁之后，T不能再获得其他任何封锁。也即事务分成 *加锁*  和 *解锁* 两个阶段。

事务遵循两段封锁协议是保证操作可串行化的充分条件（但不是必要条件）。

eg: 以下序列遵行两段封锁协议：
```
lock-x(A)
lock-s(B)
lock-s(C)
unlock(A)
unlock(C)
unlock(B)
```

