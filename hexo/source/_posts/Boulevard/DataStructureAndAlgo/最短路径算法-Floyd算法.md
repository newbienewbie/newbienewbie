---
layout: post
title: 数据结构与算法笔记 最短路径算法——Floyd算法
date: 2017-11-2 08:51:10
tags:
- 数据结构与算法
- 图论 
- 最短路径算法
- Floyd
categories:
- 大道
- 数据结构与算法
---

`Floyd-Warshall` 算法也称 Floyd's 算法，是用于求解任意点对之间最短路径的算法。叫这个奇怪的名字是因为`Robert Floyd`和`Stephen Warshal`这两人在同一年(1962年)各自独立提出了这个算法。`Floyd-Warshall`算法是典型的动态规划算法。

对于图`$G=(V,E)$`，各顶点之间弧`$<i,j>$`的权重表示为`$weight(i,j)$`，当两个顶点重合时(也就是`$i=j$`)，规定`$weight(i,j)=0$`；当两个顶点之间无弧连接时，规定`$weight(i,j)=\infty$`。对于稠密图，我们可以执行`$|V|$`次`Dijkstra`算法来获取任意点对的最短路径，但是对于稀疏图，采用结构更简单的`Floyd`算法更简单。

## Floyd's algorithm

在`Dijkstra`算法中我们指定始点为`$v_0$`，并将`$D_{v_0,k}(j)$`定义为从`$v_0$`到`$k$`只用到`$\{1,2,...,j\}$`的子集作为中间顶点的最短路径的值。现在我们把始点和终点扩展到任意点对：`$D_{p,q}(j)$`表示从始点`$p$`到终点`$p$`，期间可能经过、或者不经过、但是最多只能经过集合`$\{1,2,...,j\}$`中顶点的最短路径的长度。<!-- more -->
1. 显然，当不经过其他任何中间顶点，有`$D_{p,q}(0)=weight(p,q)$`
2. 当`$k>0$`，每次加入新的顶点`$k$`，最短路径必然只可能有以下几种情况：
    1. 最短路径还是不经过其他任何中间节点的弧`$<p,q>$`，故最短路径为`$D_{p,q}=weight(p,q)$`。这等同于初始情况。
    2. 尽管加入了顶点`$k$`，但是最短路径`$p \rightarrow q$`并不穿过顶点`$k$`，所以最短路径值仍然为`$D_{p,q}(k-1)$`。
    3. 加入了顶点`$k$`，有新的更短路径`$p \rightarrow q$`穿过了`$k$`。也就是最短路径由路径`$p \rightarrow k$`和`$k \rightarrow q$` 合成，在这两个分段路径中，由于`$k$`要么作为始点，要么作为终点，都不作为中间节点，故二者都只是最多只穿过了前`$(k-1)$`个顶点。即有`$D_{p,q}(k)= D_{p,k}(k-1)+D_{k,q}(k-1)$`。

综合以上情况，我们可以把`$D_{p,q}(k)$`的初值设置为`$D_{p,q}(0)=weight(p,q)$`，这样在每次迭代推算的过程中，必然就有`$D_{p,q}(k)=\displaystyle\min(D_{p,q}(k-1) \enspace,\enspace   D_{p,k}(k-1)+D_{k,q}(k-1) )$`。

注意，递推关系表明：经过、或者不经过、但是最多只经过中间顶点集`$\{1,2,3,...,k\}$`(规模为`$k$`)的问题可以分解为规模为`$k-1$`的问题。根据这个关系，很容易设计出相应算法。
首先引入一个集合`$S$`，表示中间顶点集。我们将按照序号从小到大的顺序，依次把顶点`$i\in V$`加入到集合`$S$`中，然后计算加入顶点`$i$`之后的各点对最短路径。经过`$k$`次加入后，集合`$S=\{1,2,3,...,k\}$`，最终当`$V-S=\emptyset$`时算法结束。为了不失一般性，我们分析图的任意两个顶点`$v_p$`和`$v_q$`，并用`$D[p,q]$`来表示从顶点`$p$`到顶点`$q$`最短路径长度。另外由于在上述过程只计算了最短路径长度，为了记录相应的路径，我们可以引入一个矩阵`$P[][]$`，其中元素`P[p][q]`表示始点`$p$`到终点`$p$`的最短路径一定经过顶点`$k$`，为了区分中间无节点的的情况，可以将其中每个元素初始化为`$-1$`。
，为了计算`$D[p,q]$`，我们需要逐步递推。
1. 在初始状态下，如果二者有弧连接，则`$<v_p,v_q>$`可能是最短路径（相应的路径长可能为`$D[p,q]=weight(p,q)$`）。这里说“可能”，是因为两点之间直接相连的弧的权重不一定比分段连接的弧的权重之和要小。具体是不是，还需要在后续计算过程中加以甄别，如果后续计算过程发现了比之前计算的`$D[p,q]$`更小，则更新之。如果二者之间没有弧链接，我们暂时标记`$D[p,q]=\infty$`，留待后续处理。总而言之，我们在这一步令`$D[p,q]=weight(p,q)$`。
2. 根据递推关系，在每一步推算过程中，选择顶点`$k$`，准备加入到集合`$S$`，计算`$D[p,k]+D[k,q]$`，与之前的`$D[p,q]$`相比，取较小者作为新的最短路径；如果发现是`$D[p,k]+D[k,q]$`更小，同时更新`$P[p,q]=k$`表示此最短路径一定穿过中间节点`$k$`。
3. 经过不停迭代，直至集合`$S$`包含了`$V$`中所有的顶点（也就是`$V-S=\emptyset$`），算法结束。

那么如何根据矩阵`$P$`知道任意两点最短路径`$p \rightarrow q$`中间节点细节呢？根据`$P[p][q]=k$`知道`$p \rightarrow q$`一定穿过`$k$`，所以问题分解为`$P[p][k]$`和`$P[k][q]$`两个子问题，如此递归层层分解，直至不含中间节点即可。

## 示例


例如，有图结构如下：
```
+---+                  2            +---+
|   +------------------------------->   |
| 0 |                               | 1 |
|   +----------------+              |   |
+-^-+       8        |              +-+-+
  |                  |                |
  |                +-v-+              |
  |                |   |       4      |
  |     5          | 2 <--------------+
  +----------------+   |
                   +---+
```

1. 设置初值：`$S=\{\}$`，`$D=\begin{bmatrix} 0 & 2 & 8 \\ \infty & 0 & 4 \\ 5 & \infty & 0 \end{bmatrix}$`
2. 加入`$k=0$`：`$S=\{0\}$`。`$D=\begin{bmatrix} 0 & 2 & 8 \\ \infty & 0 & 4 \\ 5 & \xcancel{\infty}\,7 & 0 \end{bmatrix}$`
3. 加入`$k=1$`：`$S=\{0,1\}$`。`$D=\begin{bmatrix} 0 & 2 & \xcancel{8}\,6 \\ \infty & 0 & 4 \\ 5 & 7 & 0 \end{bmatrix}$`
4. 加入`$k=2$`：`$S=\{0,1,2\}$`。`$D=\begin{bmatrix} 0 & 2 & 6 \\ \xcancel{\infty}\,9 & 0 & 4 \\ 5 & 7 & 0 \end{bmatrix}$`

## 算法实现

说起来很啰嗦，但是代码实现非常简单，去掉初始化代码，剩下的推算过程核心只有几行：
```c
// 逐步加入顶点k到集合S中
for(int k=0;k<n;k++){
    // 计算新的D[p][q]
    for(int p=0;p<n;p++){
        for(int q=0;q<n;q++>){
            // 一旦发现更短的路径，就更新到D[p][q]中
            if(D[p][q] > D[p][k]+D[k][q]){ 
                D[p][q] = D[p][k]+D[k][q]; 
                P[p][q]=k;
            }
        }
    }
}
```
