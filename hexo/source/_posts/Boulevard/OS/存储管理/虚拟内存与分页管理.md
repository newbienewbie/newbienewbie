---
title: 操作系统笔记 存储管理—虚拟内存与分页管理
date: 2017-10-27 10:05:18
tags:
- 操作系统
- 硬件基础
- 虚拟内存
- 地址空间
- 分页管理
categories:
- 大道
- 操作系统
- 存储管理
---

## 虚拟内存与虚拟内存空间

在任何一台计算机上，程序引用一组内存地址，当程序执行指令：
```asm
mov reg , 1000
```
都会把地址为1000的内存内容复制到REG寄存器中。在没有使用虚拟内存的计算机上，系统直接将虚拟地址送到内存总线上；但是现代计算机大部分时候都使用了虚拟内存，相应的这些地址称为虚拟地址。虚拟地址不是被直接送到内存总线上，而是被送到 *内存管理单元* (`Memory Management Unit`，`MMU`)上。然后由`MMU`把虚拟地址映射为物理内存地址。<!--more-->

所谓虚拟内存(`virtual memory`)， 其实是对物理内存的映射。由虚拟内存构成的地址空间称之为 *虚拟内存空间* （`virtual address space`）。虚拟内存的本质就是利用地址空间对物理内存进行抽象，其实现方式是将虚拟内存分解成页，并将每一页映射到物理内存的某个页框。虚拟内存使得每个程序都有自己的地址空间，各进程的地址空间各自独立、互不干扰。

### 页面、页框、页表

大多数情况下，虚拟内存空间较大，而实际的物理内存空间较小。这就需要对虚拟内存和物理内存进行转换和管理:
* 虚拟内存空间按照固定大小分为若干个页面（`page`）
* 页面被映射到在物理内存内，物理内存中对应的单元称之为页框（`page frame`）
* 每个进程都有自己的页表（`page table`），来把页面映射为页框

并不是所有的页都在内存中才能执行，当进程的某条指令试图访问一个未映射的页面，会使CPU陷入操作系统，触发缺页中断(`page fault`)，操作系统会找到一个较少使用的页框将其内容写入磁盘，`RAM`与磁盘之间交互总是以整个页面为单元进行的。然后把需要访问的页面读入刚刚回收的页框中然后修改页表映射关系，然后重新启动引起陷阱的指令。

一个典型的页表项包括：页框号、在/不在标志位、访问位、修改位、保护位、高速缓存禁止位等。

* 修改位(modified)：在写入时，由硬件自动设置修改位。在操作系统重新分配页框时，如果一个页面已经被修改过，必须将其写回磁盘；如果一个页面未被修改过，只需将其简单丢弃。
* 访问位(referenced)：无论读写，系统都会在访问该页面时设置访问位，用于帮助在发生缺页中断时选择要淘汰的页面。
* 高速缓存禁止位：是否禁止高速缓存。

### 映射算法

虚拟地址被人为分为两部分: *虚拟页号* (高位部分)和 *偏移量* (低位部分)。要把虚拟地址映射为物理地址，只要把虚拟地址的页面号部分转换为页框号即可。

假设页面大小=4K，虚拟内存大小=64K，物理内存=32K，则有：
0. 虚拟内存大小`$=64K=2^6*1024=2^{16}$`：需要16位地址来表示虚拟内存。
1. 页面数量`$=64K/4K=16=2^4$`：需要4位地址来表示虚拟页面号。
2. 页框数量`$=32K/4K=8=2^3$`：需要3位地址来表示页框号。

可见为了表示数量为`$16=2^4$`的虚拟页面，至少需要4个比特位，故可以把`16`位虚拟地址拆成高位和低位两个部分：`$\overbrace{\boxed{}\boxed{}\boxed{}\boxed{}}^{4\,bits} \overbrace{\boxed{}\boxed{}\boxed{}...\boxed{}}^{12\,bits} $`。
当程序执行指令需要访问虚拟内存为`$8196D=1024*8+4=2^{13}+2^2=\boxed{0010}\boxed{0000 0000 0100}B$`的时候，将虚拟地址送往`MMU`，`MMU`首先查该虚拟地址的页面号，显然这里有`$page=0010B$`。 然后根据当前页表，找到相应的3位页框号，将其与偏移地址合并得到即可实际的物理地址，假设找到的页框框`$frame=110B$`，则转换后的物理地址为`$\boxed{110}\boxed{0000 0000 0100}B$`。最后把物理地址送到内存总线，内存并不知道虚拟内存的存在，只管对相应位置进行存取。

尽管上述的思路可以解决映射问题，但是仍有两个不足：
1. 虚拟地址到物理地址的映射需要访问内存，这不够快。
2. 如果虚拟地址较大，则虚拟页面必然较多。由于每个页面占据页表的一项，这将耗费大量内存。例如一个32位操作系统、4K虚拟页面，就需要100万个页面，从而占据100万个表项。

### TLB

为了更快的页映射，一种解决办法是增加一个小型硬件设备(或者是概念上的装置)，将虚拟地址直接映射到物理内存，而不必再访问页表。这种装置称之为 *转换检测缓冲区* (`Translation Lookaside Buffer`,`TLB`,`快表`)，有时又称之为 *相联存储器* (`associate memory`)。它如同快速的页表一样，维护了页面信息(少量的)，每一个表项都有如下信息：
* 虚拟页面号
* 页框号
* 有效位: 记录该表项是否在用
* 修改位
* 保护位：读、写、执行的权限

当一个虚拟地址被送入`MMU`，硬件首先通过该虚拟页号与`TLB`中的所有表项同时并行匹配，判断是该虚拟页面是否在其中，如果发现了一个有效的匹配，并且要进行的操作没有违反保护位，则将该页框号直接从`TLB`中取出，而不必再去访问页表。当虚拟页号并不在`TLB`中时，就会进行正常的页面查询，接着从`TLB`中淘汰一个表项，然后用新找到的页表项代替之。

### 大内存页表

`TLB`解决了快速访问问题，但是并没有解决巨大的虚拟地址空间问题。

#### 多级页表

采用多级页表的首要原因是避免把全部页表一直保存在内存中，因为一个程序中有大量未使用的空闲区，这部分就不应该保留。

多级页表的基本思路是对页表进行再分页，每个页面大小与主存物理块大小相同，称之为外层页表（第一级页表，页表目录），其中每个表目是存放某个页表的物理地址；第二级是页表，每个页表的表项存放的页的物理块号。在多级页表机制下，虚拟地址被分为：外层页号(P1)、外层页号内地址(P2)和页内地址偏移地址(Offset)三个部分。如下所示:
```
+-------------------------+--------------
|  外层页号 | 外层页内地址  |   页内地址   |
+-------------------------+--------------
```

假设虚拟地址空间为`32`位（`4G`），有一个二级页表，顶级页表有`10`位，则整个虚拟空间被划分为`$2^{10}=1024$`个块，每个块大小为`4MB`，这`1024`个表项中，每一个都表示`4MB`的虚拟空间。考虑一个虚拟地址`0x00403004H`，其中一级页号占据10位、二级页号也占据10位，剩余12位为页内偏移地址，将其转换为32位二进制：`$\overbrace{\boxed{00 0000 0001}}^{10\,bits} \overbrace{\boxed{00 0000 0011}}^{10\,bits} \overbrace{\boxed{0000 0000 0100}}^{12\,bits} $` ，可以看出:
* P1为`$1B=1D$`，
* P2为`$11B=3D$` ，
* Offset为`$100B=4D$`。

MMU首先使用`PT1`作为索引，得到表项1，地址范围为`4M~8M`；然后使用`PT2`作为索引访问刚刚找到的二级页表，找出实际的页框号，最后和页面地址合成为物理地址。

尽管地址空间超过了100万个页面，但是只需要4个页表：顶级页表、0-4M正文段、4M-8M数据段、和顶端4M堆栈段的二级页表。顶级1021个页表项的`在/不在`位都设置为`0`。

#### 倒排页表

现在假设虚拟地址空间64位，页面大小为4K，则页表项数=`$2^{64}/(4*1024)=2^{52}$`，如果每个表项占据8个字节，那么仅仅页表占据的内存就会超过(30PB)。这是无论如何不可接受的。

解决方案之一就是倒排页表(`inverted page table`)。也就是说，让每个页框有一个表项，而非每个虚拟页面有一个表项。每个表项记录`(进程,虚拟页面)`对，来定位页框。对于64位虚拟地址、4K分页大小、1GRAM，物理页框大小为4K，故物理页框数=1G/4K=262144=256K，所以一个倒排表占据的页表项为只需256K个。

由于倒排表自身的特点，将虚拟地址映射为物理地址可能需要搜索整个倒排表，这会让速度变得很慢，一个解决办法是使用`TLB`，为了避免`TLB`失效引起搜索整个倒排表，还可以建立一个散列表来解决。